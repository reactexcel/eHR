{"ast":null,"code":"/*\r\n Highcharts JS v5.0.14 (2017-07-28)\r\n\r\n (c) 2009-2016 Torstein Honsi\r\n\r\n License: www.highcharts.com/license\r\n*/\n(function (M, S) {\n  \"object\" === typeof module && module.exports ? module.exports = M.document ? S(M) : S : M.Highcharts = S(M);\n})(\"undefined\" !== typeof window ? window : this, function (M) {\n  M = function () {\n    var a = window,\n        C = a.document,\n        A = a.navigator && a.navigator.userAgent || \"\",\n        F = C && C.createElementNS && !!C.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGRect,\n        E = /(edge|msie|trident)/i.test(A) && !window.opera,\n        m = !F,\n        f = /Firefox/.test(A),\n        l = f && 4 > parseInt(A.split(\"Firefox/\")[1], 10);\n    return a.Highcharts ? a.Highcharts.error(16, !0) : {\n      product: \"Highcharts\",\n      version: \"5.0.14\",\n      deg2rad: 2 * Math.PI / 360,\n      doc: C,\n      hasBidiBug: l,\n      hasTouch: C && void 0 !== C.documentElement.ontouchstart,\n      isMS: E,\n      isWebKit: /AppleWebKit/.test(A),\n      isFirefox: f,\n      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(A),\n      SVG_NS: \"http://www.w3.org/2000/svg\",\n      chartCount: 0,\n      seriesTypes: {},\n      symbolSizes: {},\n      svg: F,\n      vml: m,\n      win: a,\n      marginNames: [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"],\n      noop: function noop() {},\n      charts: []\n    };\n  }();\n\n  (function (a) {\n    var C = [],\n        A = a.charts,\n        F = a.doc,\n        E = a.win;\n\n    a.error = function (m, f) {\n      m = a.isNumber(m) ? \"Highcharts error #\" + m + \": www.highcharts.com/errors/\" + m : m;\n      if (f) throw Error(m);\n      E.console && console.log(m);\n    };\n\n    a.Fx = function (a, f, l) {\n      this.options = f;\n      this.elem = a;\n      this.prop = l;\n    };\n\n    a.Fx.prototype = {\n      dSetter: function dSetter() {\n        var a = this.paths[0],\n            f = this.paths[1],\n            l = [],\n            r = this.now,\n            u = a.length,\n            t;\n        if (1 === r) l = this.toD;else if (u === f.length && 1 > r) for (; u--;) {\n          t = parseFloat(a[u]), l[u] = isNaN(t) ? a[u] : r * parseFloat(f[u] - t) + t;\n        } else l = f;\n        this.elem.attr(\"d\", l, null, !0);\n      },\n      update: function update() {\n        var a = this.elem,\n            f = this.prop,\n            l = this.now,\n            r = this.options.step;\n        if (this[f + \"Setter\"]) this[f + \"Setter\"]();else a.attr ? a.element && a.attr(f, l, null, !0) : a.style[f] = l + this.unit;\n        r && r.call(a, l, this);\n      },\n      run: function run(a, f, l) {\n        var r = this,\n            m = function m(a) {\n          return m.stopped ? !1 : r.step(a);\n        },\n            t;\n\n        this.startTime = +new Date();\n        this.start = a;\n        this.end = f;\n        this.unit = l;\n        this.now = this.start;\n        this.pos = 0;\n        m.elem = this.elem;\n        m.prop = this.prop;\n        m() && 1 === C.push(m) && (m.timerId = setInterval(function () {\n          for (t = 0; t < C.length; t++) {\n            C[t]() || C.splice(t--, 1);\n          }\n\n          C.length || clearInterval(m.timerId);\n        }, 13));\n      },\n      step: function step(m) {\n        var f = +new Date(),\n            l,\n            r = this.options,\n            u = this.elem,\n            t = r.complete,\n            g = r.duration,\n            d = r.curAnim;\n        u.attr && !u.element ? m = !1 : m || f >= g + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), l = d[this.prop] = !0, a.objectEach(d, function (a) {\n          !0 !== a && (l = !1);\n        }), l && t && t.call(u), m = !1) : (this.pos = r.easing((f - this.startTime) / g), this.now = this.start + (this.end - this.start) * this.pos, this.update(), m = !0);\n        return m;\n      },\n      initPath: function initPath(m, f, l) {\n        function r(a) {\n          var c, e;\n\n          for (n = a.length; n--;) {\n            c = \"M\" === a[n] || \"L\" === a[n], e = /[a-zA-Z]/.test(a[n + 3]), c && e && a.splice(n + 1, 0, a[n + 1], a[n + 2], a[n + 1], a[n + 2]);\n          }\n        }\n\n        function u(a, c) {\n          for (; a.length < v;) {\n            a[0] = c[v - a.length];\n            var b = a.slice(0, e);\n            [].splice.apply(a, [0, 0].concat(b));\n            D && (b = a.slice(a.length - e), [].splice.apply(a, [a.length, 0].concat(b)), n--);\n          }\n\n          a[0] = \"M\";\n        }\n\n        function t(a, c) {\n          for (var q = (v - a.length) / e; 0 < q && q--;) {\n            y = a.slice().splice(a.length / J - e, e * J), y[0] = c[v - e - q * e], b && (y[e - 6] = y[e - 2], y[e - 5] = y[e - 1]), [].splice.apply(a, [a.length / J, 0].concat(y)), D && q--;\n          }\n        }\n\n        f = f || \"\";\n        var g,\n            d = m.startX,\n            k = m.endX,\n            b = -1 < f.indexOf(\"C\"),\n            e = b ? 7 : 3,\n            v,\n            y,\n            n;\n        f = f.split(\" \");\n        l = l.slice();\n        var D = m.isArea,\n            J = D ? 2 : 1,\n            c;\n        b && (r(f), r(l));\n\n        if (d && k) {\n          for (n = 0; n < d.length; n++) {\n            if (d[n] === k[0]) {\n              g = n;\n              break;\n            } else if (d[0] === k[k.length - d.length + n]) {\n              g = n;\n              c = !0;\n              break;\n            }\n          }\n\n          void 0 === g && (f = []);\n        }\n\n        f.length && a.isNumber(g) && (v = l.length + g * J * e, c ? (u(f, l), t(l, f)) : (u(l, f), t(f, l)));\n        return [f, l];\n      }\n    };\n\n    a.Fx.prototype.fillSetter = a.Fx.prototype.strokeSetter = function () {\n      this.elem.attr(this.prop, a.color(this.start).tweenTo(a.color(this.end), this.pos), null, !0);\n    };\n\n    a.extend = function (a, f) {\n      var m;\n      a || (a = {});\n\n      for (m in f) {\n        a[m] = f[m];\n      }\n\n      return a;\n    };\n\n    a.merge = function () {\n      var m,\n          f = arguments,\n          l,\n          r = {},\n          u = function u(f, g) {\n        \"object\" !== typeof f && (f = {});\n        a.objectEach(g, function (d, k) {\n          !a.isObject(d, !0) || a.isClass(d) || a.isDOMElement(d) ? f[k] = g[k] : f[k] = u(f[k] || {}, d);\n        });\n        return f;\n      };\n\n      !0 === f[0] && (r = f[1], f = Array.prototype.slice.call(f, 2));\n      l = f.length;\n\n      for (m = 0; m < l; m++) {\n        r = u(r, f[m]);\n      }\n\n      return r;\n    };\n\n    a.pInt = function (a, f) {\n      return parseInt(a, f || 10);\n    };\n\n    a.isString = function (a) {\n      return \"string\" === typeof a;\n    };\n\n    a.isArray = function (a) {\n      a = Object.prototype.toString.call(a);\n      return \"[object Array]\" === a || \"[object Array Iterator]\" === a;\n    };\n\n    a.isObject = function (m, f) {\n      return !!m && \"object\" === typeof m && (!f || !a.isArray(m));\n    };\n\n    a.isDOMElement = function (m) {\n      return a.isObject(m) && \"number\" === typeof m.nodeType;\n    };\n\n    a.isClass = function (m) {\n      var f = m && m.constructor;\n      return !(!a.isObject(m, !0) || a.isDOMElement(m) || !f || !f.name || \"Object\" === f.name);\n    };\n\n    a.isNumber = function (a) {\n      return \"number\" === typeof a && !isNaN(a);\n    };\n\n    a.erase = function (a, f) {\n      for (var m = a.length; m--;) {\n        if (a[m] === f) {\n          a.splice(m, 1);\n          break;\n        }\n      }\n    };\n\n    a.defined = function (a) {\n      return void 0 !== a && null !== a;\n    };\n\n    a.attr = function (m, f, l) {\n      var r;\n      a.isString(f) ? a.defined(l) ? m.setAttribute(f, l) : m && m.getAttribute && (r = m.getAttribute(f)) : a.defined(f) && a.isObject(f) && a.objectEach(f, function (a, f) {\n        m.setAttribute(f, a);\n      });\n      return r;\n    };\n\n    a.splat = function (m) {\n      return a.isArray(m) ? m : [m];\n    };\n\n    a.syncTimeout = function (a, f, l) {\n      if (f) return setTimeout(a, f, l);\n      a.call(0, l);\n    };\n\n    a.pick = function () {\n      var a = arguments,\n          f,\n          l,\n          r = a.length;\n\n      for (f = 0; f < r; f++) {\n        if (l = a[f], void 0 !== l && null !== l) return l;\n      }\n    };\n\n    a.css = function (m, f) {\n      a.isMS && !a.svg && f && void 0 !== f.opacity && (f.filter = \"alpha(opacity\\x3d\" + 100 * f.opacity + \")\");\n      a.extend(m.style, f);\n    };\n\n    a.createElement = function (m, f, l, r, u) {\n      m = F.createElement(m);\n      var t = a.css;\n      f && a.extend(m, f);\n      u && t(m, {\n        padding: 0,\n        border: \"none\",\n        margin: 0\n      });\n      l && t(m, l);\n      r && r.appendChild(m);\n      return m;\n    };\n\n    a.extendClass = function (m, f) {\n      var l = function l() {};\n\n      l.prototype = new m();\n      a.extend(l.prototype, f);\n      return l;\n    };\n\n    a.pad = function (a, f, l) {\n      return Array((f || 2) + 1 - String(a).length).join(l || 0) + a;\n    };\n\n    a.relativeLength = function (a, f, l) {\n      return /%$/.test(a) ? f * parseFloat(a) / 100 + (l || 0) : parseFloat(a);\n    };\n\n    a.wrap = function (a, f, l) {\n      var r = a[f];\n\n      a[f] = function () {\n        var a = Array.prototype.slice.call(arguments),\n            f = arguments,\n            g = this;\n\n        g.proceed = function () {\n          r.apply(g, arguments.length ? arguments : f);\n        };\n\n        a.unshift(r);\n        a = l.apply(this, a);\n        g.proceed = null;\n        return a;\n      };\n    };\n\n    a.getTZOffset = function (m) {\n      var f = a.Date;\n      return 6E4 * (f.hcGetTimezoneOffset && f.hcGetTimezoneOffset(m) || f.hcTimezoneOffset || 0);\n    };\n\n    a.dateFormat = function (m, f, l) {\n      if (!a.defined(f) || isNaN(f)) return a.defaultOptions.lang.invalidDate || \"\";\n      m = a.pick(m, \"%Y-%m-%d %H:%M:%S\");\n      var r = a.Date,\n          u = new r(f - a.getTZOffset(f)),\n          t = u[r.hcGetHours](),\n          g = u[r.hcGetDay](),\n          d = u[r.hcGetDate](),\n          k = u[r.hcGetMonth](),\n          b = u[r.hcGetFullYear](),\n          e = a.defaultOptions.lang,\n          v = e.weekdays,\n          y = e.shortWeekdays,\n          n = a.pad,\n          r = a.extend({\n        a: y ? y[g] : v[g].substr(0, 3),\n        A: v[g],\n        d: n(d),\n        e: n(d, 2, \" \"),\n        w: g,\n        b: e.shortMonths[k],\n        B: e.months[k],\n        m: n(k + 1),\n        y: b.toString().substr(2, 2),\n        Y: b,\n        H: n(t),\n        k: t,\n        I: n(t % 12 || 12),\n        l: t % 12 || 12,\n        M: n(u[r.hcGetMinutes]()),\n        p: 12 > t ? \"AM\" : \"PM\",\n        P: 12 > t ? \"am\" : \"pm\",\n        S: n(u.getSeconds()),\n        L: n(Math.round(f % 1E3), 3)\n      }, a.dateFormats);\n      a.objectEach(r, function (a, e) {\n        for (; -1 !== m.indexOf(\"%\" + e);) {\n          m = m.replace(\"%\" + e, \"function\" === typeof a ? a(f) : a);\n        }\n      });\n      return l ? m.substr(0, 1).toUpperCase() + m.substr(1) : m;\n    };\n\n    a.formatSingle = function (m, f) {\n      var l = /\\.([0-9])/,\n          r = a.defaultOptions.lang;\n      /f$/.test(m) ? (l = (l = m.match(l)) ? l[1] : -1, null !== f && (f = a.numberFormat(f, l, r.decimalPoint, -1 < m.indexOf(\",\") ? r.thousandsSep : \"\"))) : f = a.dateFormat(m, f);\n      return f;\n    };\n\n    a.format = function (m, f) {\n      for (var l = \"{\", r = !1, u, t, g, d, k = [], b; m;) {\n        l = m.indexOf(l);\n        if (-1 === l) break;\n        u = m.slice(0, l);\n\n        if (r) {\n          u = u.split(\":\");\n          t = u.shift().split(\".\");\n          d = t.length;\n          b = f;\n\n          for (g = 0; g < d; g++) {\n            b = b[t[g]];\n          }\n\n          u.length && (b = a.formatSingle(u.join(\":\"), b));\n          k.push(b);\n        } else k.push(u);\n\n        m = m.slice(l + 1);\n        l = (r = !r) ? \"}\" : \"{\";\n      }\n\n      k.push(m);\n      return k.join(\"\");\n    };\n\n    a.getMagnitude = function (a) {\n      return Math.pow(10, Math.floor(Math.log(a) / Math.LN10));\n    };\n\n    a.normalizeTickInterval = function (m, f, l, r, u) {\n      var t,\n          g = m;\n      l = a.pick(l, 1);\n      t = m / l;\n      f || (f = u ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === r && (1 === l ? f = a.grep(f, function (a) {\n        return 0 === a % 1;\n      }) : .1 >= l && (f = [1 / l])));\n\n      for (r = 0; r < f.length && !(g = f[r], u && g * l >= m || !u && t <= (f[r] + (f[r + 1] || f[r])) / 2); r++) {\n        ;\n      }\n\n      return g = a.correctFloat(g * l, -Math.round(Math.log(.001) / Math.LN10));\n    };\n\n    a.stableSort = function (a, f) {\n      var l = a.length,\n          r,\n          m;\n\n      for (m = 0; m < l; m++) {\n        a[m].safeI = m;\n      }\n\n      a.sort(function (a, g) {\n        r = f(a, g);\n        return 0 === r ? a.safeI - g.safeI : r;\n      });\n\n      for (m = 0; m < l; m++) {\n        delete a[m].safeI;\n      }\n    };\n\n    a.arrayMin = function (a) {\n      for (var f = a.length, l = a[0]; f--;) {\n        a[f] < l && (l = a[f]);\n      }\n\n      return l;\n    };\n\n    a.arrayMax = function (a) {\n      for (var f = a.length, l = a[0]; f--;) {\n        a[f] > l && (l = a[f]);\n      }\n\n      return l;\n    };\n\n    a.destroyObjectProperties = function (m, f) {\n      a.objectEach(m, function (a, r) {\n        a && a !== f && a.destroy && a.destroy();\n        delete m[r];\n      });\n    };\n\n    a.discardElement = function (m) {\n      var f = a.garbageBin;\n      f || (f = a.createElement(\"div\"));\n      m && f.appendChild(m);\n      f.innerHTML = \"\";\n    };\n\n    a.correctFloat = function (a, f) {\n      return parseFloat(a.toPrecision(f || 14));\n    };\n\n    a.setAnimation = function (m, f) {\n      f.renderer.globalAnimation = a.pick(m, f.options.chart.animation, !0);\n    };\n\n    a.animObject = function (m) {\n      return a.isObject(m) ? a.merge(m) : {\n        duration: m ? 500 : 0\n      };\n    };\n\n    a.timeUnits = {\n      millisecond: 1,\n      second: 1E3,\n      minute: 6E4,\n      hour: 36E5,\n      day: 864E5,\n      week: 6048E5,\n      month: 24192E5,\n      year: 314496E5\n    };\n\n    a.numberFormat = function (m, f, l, r) {\n      m = +m || 0;\n      f = +f;\n      var u = a.defaultOptions.lang,\n          t = (m.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n          g,\n          d,\n          k = m.toString().split(\"e\");\n      -1 === f ? f = Math.min(t, 20) : a.isNumber(f) || (f = 2);\n      d = (Math.abs(k[1] ? k[0] : m) + Math.pow(10, -Math.max(f, t) - 1)).toFixed(f);\n      t = String(a.pInt(d));\n      g = 3 < t.length ? t.length % 3 : 0;\n      l = a.pick(l, u.decimalPoint);\n      r = a.pick(r, u.thousandsSep);\n      m = (0 > m ? \"-\" : \"\") + (g ? t.substr(0, g) + r : \"\");\n      m += t.substr(g).replace(/(\\d{3})(?=\\d)/g, \"$1\" + r);\n      f && (m += l + d.slice(-f));\n      k[1] && (m += \"e\" + k[1]);\n      return m;\n    };\n\n    Math.easeInOutSine = function (a) {\n      return -.5 * (Math.cos(Math.PI * a) - 1);\n    };\n\n    a.getStyle = function (m, f, l) {\n      if (\"width\" === f) return Math.min(m.offsetWidth, m.scrollWidth) - a.getStyle(m, \"padding-left\") - a.getStyle(m, \"padding-right\");\n      if (\"height\" === f) return Math.min(m.offsetHeight, m.scrollHeight) - a.getStyle(m, \"padding-top\") - a.getStyle(m, \"padding-bottom\");\n      if (m = E.getComputedStyle(m, void 0)) m = m.getPropertyValue(f), a.pick(l, !0) && (m = a.pInt(m));\n      return m;\n    };\n\n    a.inArray = function (a, f) {\n      return f.indexOf ? f.indexOf(a) : [].indexOf.call(f, a);\n    };\n\n    a.grep = function (a, f) {\n      return [].filter.call(a, f);\n    };\n\n    a.find = function (a, f) {\n      return [].find.call(a, f);\n    };\n\n    a.map = function (a, f) {\n      for (var l = [], r = 0, m = a.length; r < m; r++) {\n        l[r] = f.call(a[r], a[r], r, a);\n      }\n\n      return l;\n    };\n\n    a.offset = function (a) {\n      var f = F.documentElement;\n      a = a.getBoundingClientRect();\n      return {\n        top: a.top + (E.pageYOffset || f.scrollTop) - (f.clientTop || 0),\n        left: a.left + (E.pageXOffset || f.scrollLeft) - (f.clientLeft || 0)\n      };\n    };\n\n    a.stop = function (a, f) {\n      for (var l = C.length; l--;) {\n        C[l].elem !== a || f && f !== C[l].prop || (C[l].stopped = !0);\n      }\n    };\n\n    a.each = function (a, f, l) {\n      return Array.prototype.forEach.call(a, f, l);\n    };\n\n    a.objectEach = function (a, f, l) {\n      for (var r in a) {\n        a.hasOwnProperty(r) && f.call(l, a[r], r, a);\n      }\n    };\n\n    a.addEvent = function (m, f, l) {\n      function r(a) {\n        a.target = a.srcElement || E;\n        l.call(m, a);\n      }\n\n      var u = m.hcEvents = m.hcEvents || {};\n      m.addEventListener ? m.addEventListener(f, l, !1) : m.attachEvent && (m.hcEventsIE || (m.hcEventsIE = {}), l.hcGetKey || (l.hcGetKey = a.uniqueKey()), m.hcEventsIE[l.hcGetKey] = r, m.attachEvent(\"on\" + f, r));\n      u[f] || (u[f] = []);\n      u[f].push(l);\n      return function () {\n        a.removeEvent(m, f, l);\n      };\n    };\n\n    a.removeEvent = function (m, f, l) {\n      function r(a, b) {\n        m.removeEventListener ? m.removeEventListener(a, b, !1) : m.attachEvent && (b = m.hcEventsIE[b.hcGetKey], m.detachEvent(\"on\" + a, b));\n      }\n\n      function u() {\n        var d, b;\n        m.nodeName && (f ? (d = {}, d[f] = !0) : d = g, a.objectEach(d, function (a, d) {\n          if (g[d]) for (b = g[d].length; b--;) {\n            r(d, g[d][b]);\n          }\n        }));\n      }\n\n      var t,\n          g = m.hcEvents,\n          d;\n      g && (f ? (t = g[f] || [], l ? (d = a.inArray(l, t), -1 < d && (t.splice(d, 1), g[f] = t), r(f, l)) : (u(), g[f] = [])) : (u(), m.hcEvents = {}));\n    };\n\n    a.fireEvent = function (m, f, l, r) {\n      var u;\n      u = m.hcEvents;\n      var t, g;\n      l = l || {};\n      if (F.createEvent && (m.dispatchEvent || m.fireEvent)) u = F.createEvent(\"Events\"), u.initEvent(f, !0, !0), a.extend(u, l), m.dispatchEvent ? m.dispatchEvent(u) : m.fireEvent(f, u);else if (u) for (u = u[f] || [], t = u.length, l.target || a.extend(l, {\n        preventDefault: function preventDefault() {\n          l.defaultPrevented = !0;\n        },\n        target: m,\n        type: f\n      }), f = 0; f < t; f++) {\n        (g = u[f]) && !1 === g.call(m, l) && l.preventDefault();\n      }\n      r && !l.defaultPrevented && r(l);\n    };\n\n    a.animate = function (m, f, l) {\n      var r,\n          u = \"\",\n          t,\n          g,\n          d;\n      a.isObject(l) || (d = arguments, l = {\n        duration: d[2],\n        easing: d[3],\n        complete: d[4]\n      });\n      a.isNumber(l.duration) || (l.duration = 400);\n      l.easing = \"function\" === typeof l.easing ? l.easing : Math[l.easing] || Math.easeInOutSine;\n      l.curAnim = a.merge(f);\n      a.objectEach(f, function (d, b) {\n        a.stop(m, b);\n        g = new a.Fx(m, l, b);\n        t = null;\n        \"d\" === b ? (g.paths = g.initPath(m, m.d, f.d), g.toD = f.d, r = 0, t = 1) : m.attr ? r = m.attr(b) : (r = parseFloat(a.getStyle(m, b)) || 0, \"opacity\" !== b && (u = \"px\"));\n        t || (t = d);\n        t && t.match && t.match(\"px\") && (t = t.replace(/px/g, \"\"));\n        g.run(r, t, u);\n      });\n    };\n\n    a.seriesType = function (m, f, l, r, u) {\n      var t = a.getOptions(),\n          g = a.seriesTypes;\n      t.plotOptions[m] = a.merge(t.plotOptions[f], l);\n      g[m] = a.extendClass(g[f] || function () {}, r);\n      g[m].prototype.type = m;\n      u && (g[m].prototype.pointClass = a.extendClass(a.Point, u));\n      return g[m];\n    };\n\n    a.uniqueKey = function () {\n      var a = Math.random().toString(36).substring(2, 9),\n          f = 0;\n      return function () {\n        return \"highcharts-\" + a + \"-\" + f++;\n      };\n    }();\n\n    E.jQuery && (E.jQuery.fn.highcharts = function () {\n      var m = [].slice.call(arguments);\n      if (this[0]) return m[0] ? (new a[a.isString(m[0]) ? m.shift() : \"Chart\"](this[0], m[0], m[1]), this) : A[a.attr(this[0], \"data-highcharts-chart\")];\n    });\n    F && !F.defaultView && (a.getStyle = function (m, f) {\n      var l = {\n        width: \"clientWidth\",\n        height: \"clientHeight\"\n      }[f];\n      if (m.style[f]) return a.pInt(m.style[f]);\n      \"opacity\" === f && (f = \"filter\");\n      if (l) return m.style.zoom = 1, Math.max(m[l] - 2 * a.getStyle(m, \"padding\"), 0);\n      m = m.currentStyle[f.replace(/\\-(\\w)/g, function (a, f) {\n        return f.toUpperCase();\n      })];\n      \"filter\" === f && (m = m.replace(/alpha\\(opacity=([0-9]+)\\)/, function (a, f) {\n        return f / 100;\n      }));\n      return \"\" === m ? 1 : a.pInt(m);\n    });\n    Array.prototype.forEach || (a.each = function (a, f, l) {\n      for (var r = 0, m = a.length; r < m; r++) {\n        if (!1 === f.call(l, a[r], r, a)) return r;\n      }\n    });\n    Array.prototype.indexOf || (a.inArray = function (a, f) {\n      var l,\n          r = 0;\n      if (f) for (l = f.length; r < l; r++) {\n        if (f[r] === a) return r;\n      }\n      return -1;\n    });\n    Array.prototype.filter || (a.grep = function (a, f) {\n      for (var l = [], r = 0, m = a.length; r < m; r++) {\n        f(a[r], r) && l.push(a[r]);\n      }\n\n      return l;\n    });\n    Array.prototype.find || (a.find = function (a, f) {\n      var l,\n          r = a.length;\n\n      for (l = 0; l < r; l++) {\n        if (f(a[l], l)) return a[l];\n      }\n    });\n  })(M);\n\n  (function (a) {\n    var C = a.each,\n        A = a.isNumber,\n        F = a.map,\n        E = a.merge,\n        m = a.pInt;\n\n    a.Color = function (f) {\n      if (!(this instanceof a.Color)) return new a.Color(f);\n      this.init(f);\n    };\n\n    a.Color.prototype = {\n      parsers: [{\n        regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n        parse: function parse(a) {\n          return [m(a[1]), m(a[2]), m(a[3]), parseFloat(a[4], 10)];\n        }\n      }, {\n        regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n        parse: function parse(a) {\n          return [m(a[1]), m(a[2]), m(a[3]), 1];\n        }\n      }],\n      names: {\n        none: \"rgba(255,255,255,0)\",\n        white: \"#ffffff\",\n        black: \"#000000\"\n      },\n      init: function init(f) {\n        var l, r, m, t;\n        if ((this.input = f = this.names[f && f.toLowerCase ? f.toLowerCase() : \"\"] || f) && f.stops) this.stops = F(f.stops, function (g) {\n          return new a.Color(g[1]);\n        });else if (f && \"#\" === f.charAt() && (l = f.length, f = parseInt(f.substr(1), 16), 7 === l ? r = [(f & 16711680) >> 16, (f & 65280) >> 8, f & 255, 1] : 4 === l && (r = [(f & 3840) >> 4 | (f & 3840) >> 8, (f & 240) >> 4 | f & 240, (f & 15) << 4 | f & 15, 1])), !r) for (m = this.parsers.length; m-- && !r;) {\n          t = this.parsers[m], (l = t.regex.exec(f)) && (r = t.parse(l));\n        }\n        this.rgba = r || [];\n      },\n      get: function get(a) {\n        var f = this.input,\n            r = this.rgba,\n            m;\n        this.stops ? (m = E(f), m.stops = [].concat(m.stops), C(this.stops, function (f, g) {\n          m.stops[g] = [m.stops[g][0], f.get(a)];\n        })) : m = r && A(r[0]) ? \"rgb\" === a || !a && 1 === r[3] ? \"rgb(\" + r[0] + \",\" + r[1] + \",\" + r[2] + \")\" : \"a\" === a ? r[3] : \"rgba(\" + r.join(\",\") + \")\" : f;\n        return m;\n      },\n      brighten: function brighten(a) {\n        var f,\n            r = this.rgba;\n        if (this.stops) C(this.stops, function (f) {\n          f.brighten(a);\n        });else if (A(a) && 0 !== a) for (f = 0; 3 > f; f++) {\n          r[f] += m(255 * a), 0 > r[f] && (r[f] = 0), 255 < r[f] && (r[f] = 255);\n        }\n        return this;\n      },\n      setOpacity: function setOpacity(a) {\n        this.rgba[3] = a;\n        return this;\n      },\n      tweenTo: function tweenTo(a, l) {\n        var f, m;\n        a.rgba.length ? (f = this.rgba, a = a.rgba, m = 1 !== a[3] || 1 !== f[3], a = (m ? \"rgba(\" : \"rgb(\") + Math.round(a[0] + (f[0] - a[0]) * (1 - l)) + \",\" + Math.round(a[1] + (f[1] - a[1]) * (1 - l)) + \",\" + Math.round(a[2] + (f[2] - a[2]) * (1 - l)) + (m ? \",\" + (a[3] + (f[3] - a[3]) * (1 - l)) : \"\") + \")\") : a = a.input || \"none\";\n        return a;\n      }\n    };\n\n    a.color = function (f) {\n      return new a.Color(f);\n    };\n  })(M);\n\n  (function (a) {\n    var C,\n        A,\n        F = a.addEvent,\n        E = a.animate,\n        m = a.attr,\n        f = a.charts,\n        l = a.color,\n        r = a.css,\n        u = a.createElement,\n        t = a.defined,\n        g = a.deg2rad,\n        d = a.destroyObjectProperties,\n        k = a.doc,\n        b = a.each,\n        e = a.extend,\n        v = a.erase,\n        y = a.grep,\n        n = a.hasTouch,\n        D = a.inArray,\n        J = a.isArray,\n        c = a.isFirefox,\n        G = a.isMS,\n        q = a.isObject,\n        B = a.isString,\n        K = a.isWebKit,\n        p = a.merge,\n        z = a.noop,\n        I = a.objectEach,\n        L = a.pick,\n        h = a.pInt,\n        w = a.removeEvent,\n        P = a.stop,\n        H = a.svg,\n        O = a.SVG_NS,\n        Q = a.symbolSizes,\n        R = a.win;\n\n    C = a.SVGElement = function () {\n      return this;\n    };\n\n    e(C.prototype, {\n      opacity: 1,\n      SVG_NS: O,\n      textProps: \"direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline\".split(\" \"),\n      init: function init(a, h) {\n        this.element = \"span\" === h ? u(h) : k.createElementNS(this.SVG_NS, h);\n        this.renderer = a;\n      },\n      animate: function animate(x, h, c) {\n        h = a.animObject(L(h, this.renderer.globalAnimation, !0));\n        0 !== h.duration ? (c && (h.complete = c), E(this, x, h)) : (this.attr(x, null, c), h.step && h.step.call(this));\n        return this;\n      },\n      colorGradient: function colorGradient(x, h, c) {\n        var w = this.renderer,\n            e,\n            q,\n            N,\n            d,\n            n,\n            g,\n            k,\n            H,\n            G,\n            v,\n            z = [],\n            f;\n        x.radialGradient ? q = \"radialGradient\" : x.linearGradient && (q = \"linearGradient\");\n        q && (N = x[q], n = w.gradients, k = x.stops, v = c.radialReference, J(N) && (x[q] = N = {\n          x1: N[0],\n          y1: N[1],\n          x2: N[2],\n          y2: N[3],\n          gradientUnits: \"userSpaceOnUse\"\n        }), \"radialGradient\" === q && v && !t(N.gradientUnits) && (d = N, N = p(N, w.getRadialAttr(v, d), {\n          gradientUnits: \"userSpaceOnUse\"\n        })), I(N, function (a, x) {\n          \"id\" !== x && z.push(x, a);\n        }), I(k, function (a) {\n          z.push(a);\n        }), z = z.join(\",\"), n[z] ? v = n[z].attr(\"id\") : (N.id = v = a.uniqueKey(), n[z] = g = w.createElement(q).attr(N).add(w.defs), g.radAttr = d, g.stops = [], b(k, function (x) {\n          0 === x[1].indexOf(\"rgba\") ? (e = a.color(x[1]), H = e.get(\"rgb\"), G = e.get(\"a\")) : (H = x[1], G = 1);\n          x = w.createElement(\"stop\").attr({\n            offset: x[0],\n            \"stop-color\": H,\n            \"stop-opacity\": G\n          }).add(g);\n          g.stops.push(x);\n        })), f = \"url(\" + w.url + \"#\" + v + \")\", c.setAttribute(h, f), c.gradient = z, x.toString = function () {\n          return f;\n        });\n      },\n      applyTextOutline: function applyTextOutline(x) {\n        var h = this.element,\n            c,\n            w,\n            p,\n            e,\n            q;\n        -1 !== x.indexOf(\"contrast\") && (x = x.replace(/contrast/g, this.renderer.getContrast(h.style.fill)));\n        x = x.split(\" \");\n        w = x[x.length - 1];\n\n        if ((p = x[0]) && \"none\" !== p && a.svg) {\n          this.fakeTS = !0;\n          x = [].slice.call(h.getElementsByTagName(\"tspan\"));\n          this.ySetter = this.xSetter;\n          p = p.replace(/(^[\\d\\.]+)(.*?)$/g, function (a, x, h) {\n            return 2 * x + h;\n          });\n\n          for (q = x.length; q--;) {\n            c = x[q], \"highcharts-text-outline\" === c.getAttribute(\"class\") && v(x, h.removeChild(c));\n          }\n\n          e = h.firstChild;\n          b(x, function (a, x) {\n            0 === x && (a.setAttribute(\"x\", h.getAttribute(\"x\")), x = h.getAttribute(\"y\"), a.setAttribute(\"y\", x || 0), null === x && h.setAttribute(\"y\", 0));\n            a = a.cloneNode(1);\n            m(a, {\n              \"class\": \"highcharts-text-outline\",\n              fill: w,\n              stroke: w,\n              \"stroke-width\": p,\n              \"stroke-linejoin\": \"round\"\n            });\n            h.insertBefore(a, e);\n          });\n        }\n      },\n      attr: function attr(a, h, c, w) {\n        var x,\n            p = this.element,\n            e,\n            q = this,\n            b,\n            N;\n        \"string\" === typeof a && void 0 !== h && (x = a, a = {}, a[x] = h);\n        \"string\" === typeof a ? q = (this[a + \"Getter\"] || this._defaultGetter).call(this, a, p) : (I(a, function (x, h) {\n          b = !1;\n          w || P(this, h);\n          this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/.test(h) && (e || (this.symbolAttr(a), e = !0), b = !0);\n          !this.rotation || \"x\" !== h && \"y\" !== h || (this.doTransform = !0);\n          b || (N = this[h + \"Setter\"] || this._defaultSetter, N.call(this, x, h, p), this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(h) && this.updateShadows(h, x, N));\n        }, this), this.afterSetters());\n        c && c();\n        return q;\n      },\n      afterSetters: function afterSetters() {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      },\n      updateShadows: function updateShadows(a, h, c) {\n        for (var x = this.shadows, w = x.length; w--;) {\n          c.call(x[w], \"height\" === a ? Math.max(h - (x[w].cutHeight || 0), 0) : \"d\" === a ? this.d : h, a, x[w]);\n        }\n      },\n      addClass: function addClass(a, h) {\n        var x = this.attr(\"class\") || \"\";\n        -1 === x.indexOf(a) && (h || (a = (x + (x ? \" \" : \"\") + a).replace(\"  \", \" \")), this.attr(\"class\", a));\n        return this;\n      },\n      hasClass: function hasClass(a) {\n        return -1 !== D(a, (this.attr(\"class\") || \"\").split(\" \"));\n      },\n      removeClass: function removeClass(a) {\n        return this.attr(\"class\", (this.attr(\"class\") || \"\").replace(a, \"\"));\n      },\n      symbolAttr: function symbolAttr(a) {\n        var x = this;\n        b(\"x y r start end width height innerR anchorX anchorY\".split(\" \"), function (h) {\n          x[h] = L(a[h], x[h]);\n        });\n        x.attr({\n          d: x.renderer.symbols[x.symbolName](x.x, x.y, x.width, x.height, x)\n        });\n      },\n      clip: function clip(a) {\n        return this.attr(\"clip-path\", a ? \"url(\" + this.renderer.url + \"#\" + a.id + \")\" : \"none\");\n      },\n      crisp: function crisp(a, h) {\n        var x = this,\n            c = {},\n            w;\n        h = h || a.strokeWidth || 0;\n        w = Math.round(h) % 2 / 2;\n        a.x = Math.floor(a.x || x.x || 0) + w;\n        a.y = Math.floor(a.y || x.y || 0) + w;\n        a.width = Math.floor((a.width || x.width || 0) - 2 * w);\n        a.height = Math.floor((a.height || x.height || 0) - 2 * w);\n        t(a.strokeWidth) && (a.strokeWidth = h);\n        I(a, function (a, h) {\n          x[h] !== a && (x[h] = c[h] = a);\n        });\n        return c;\n      },\n      css: function css(a) {\n        var x = this.styles,\n            c = {},\n            w = this.element,\n            p,\n            q = \"\",\n            b,\n            d = !x,\n            n = [\"textOutline\", \"textOverflow\", \"width\"];\n        a && a.color && (a.fill = a.color);\n        x && I(a, function (a, h) {\n          a !== x[h] && (c[h] = a, d = !0);\n        });\n        d && (x && (a = e(x, c)), p = this.textWidth = a && a.width && \"auto\" !== a.width && \"text\" === w.nodeName.toLowerCase() && h(a.width), this.styles = a, p && !H && this.renderer.forExport && delete a.width, G && !H ? r(this.element, a) : (b = function b(a, x) {\n          return \"-\" + x.toLowerCase();\n        }, I(a, function (a, x) {\n          -1 === D(x, n) && (q += x.replace(/([A-Z])/g, b) + \":\" + a + \";\");\n        }), q && m(w, \"style\", q)), this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), a && a.textOutline && this.applyTextOutline(a.textOutline)));\n        return this;\n      },\n      strokeWidth: function strokeWidth() {\n        return this[\"stroke-width\"] || 0;\n      },\n      on: function on(a, h) {\n        var x = this,\n            c = x.element;\n        n && \"click\" === a ? (c.ontouchstart = function (a) {\n          x.touchEventFired = Date.now();\n          a.preventDefault();\n          h.call(c, a);\n        }, c.onclick = function (a) {\n          (-1 === R.navigator.userAgent.indexOf(\"Android\") || 1100 < Date.now() - (x.touchEventFired || 0)) && h.call(c, a);\n        }) : c[\"on\" + a] = h;\n        return this;\n      },\n      setRadialReference: function setRadialReference(a) {\n        var x = this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = a;\n        x && x.radAttr && x.animate(this.renderer.getRadialAttr(a, x.radAttr));\n        return this;\n      },\n      translate: function translate(a, h) {\n        return this.attr({\n          translateX: a,\n          translateY: h\n        });\n      },\n      invert: function invert(a) {\n        this.inverted = a;\n        this.updateTransform();\n        return this;\n      },\n      updateTransform: function updateTransform() {\n        var a = this.translateX || 0,\n            h = this.translateY || 0,\n            c = this.scaleX,\n            w = this.scaleY,\n            p = this.inverted,\n            e = this.rotation,\n            q = this.element;\n        p && (a += this.width, h += this.height);\n        a = [\"translate(\" + a + \",\" + h + \")\"];\n        p ? a.push(\"rotate(90) scale(-1,1)\") : e && a.push(\"rotate(\" + e + \" \" + (q.getAttribute(\"x\") || 0) + \" \" + (q.getAttribute(\"y\") || 0) + \")\");\n        (t(c) || t(w)) && a.push(\"scale(\" + L(c, 1) + \" \" + L(w, 1) + \")\");\n        a.length && q.setAttribute(\"transform\", a.join(\" \"));\n      },\n      toFront: function toFront() {\n        var a = this.element;\n        a.parentNode.appendChild(a);\n        return this;\n      },\n      align: function align(a, h, c) {\n        var x,\n            w,\n            p,\n            e,\n            q = {};\n        w = this.renderer;\n        p = w.alignedObjects;\n        var b, d;\n\n        if (a) {\n          if (this.alignOptions = a, this.alignByTranslate = h, !c || B(c)) this.alignTo = x = c || \"renderer\", v(p, this), p.push(this), c = null;\n        } else a = this.alignOptions, h = this.alignByTranslate, x = this.alignTo;\n\n        c = L(c, w[x], w);\n        x = a.align;\n        w = a.verticalAlign;\n        p = (c.x || 0) + (a.x || 0);\n        e = (c.y || 0) + (a.y || 0);\n        \"right\" === x ? b = 1 : \"center\" === x && (b = 2);\n        b && (p += (c.width - (a.width || 0)) / b);\n        q[h ? \"translateX\" : \"x\"] = Math.round(p);\n        \"bottom\" === w ? d = 1 : \"middle\" === w && (d = 2);\n        d && (e += (c.height - (a.height || 0)) / d);\n        q[h ? \"translateY\" : \"y\"] = Math.round(e);\n        this[this.placed ? \"animate\" : \"attr\"](q);\n        this.placed = !0;\n        this.alignAttr = q;\n        return this;\n      },\n      getBBox: function getBBox(a, h) {\n        var x,\n            c = this.renderer,\n            w,\n            p = this.element,\n            q = this.styles,\n            d,\n            n = this.textStr,\n            k,\n            N = c.cache,\n            H = c.cacheKeys,\n            G;\n        h = L(h, this.rotation);\n        w = h * g;\n        d = q && q.fontSize;\n        void 0 !== n && (G = n.toString(), -1 === G.indexOf(\"\\x3c\") && (G = G.replace(/[0-9]/g, \"0\")), G += [\"\", h || 0, d, q && q.width, q && q.textOverflow].join());\n        G && !a && (x = N[G]);\n\n        if (!x) {\n          if (p.namespaceURI === this.SVG_NS || c.forExport) {\n            try {\n              (k = this.fakeTS && function (a) {\n                b(p.querySelectorAll(\".highcharts-text-outline\"), function (x) {\n                  x.style.display = a;\n                });\n              }) && k(\"none\"), x = p.getBBox ? e({}, p.getBBox()) : {\n                width: p.offsetWidth,\n                height: p.offsetHeight\n              }, k && k(\"\");\n            } catch (W) {}\n\n            if (!x || 0 > x.width) x = {\n              width: 0,\n              height: 0\n            };\n          } else x = this.htmlGetBBox();\n\n          c.isSVG && (a = x.width, c = x.height, q && \"11px\" === q.fontSize && 17 === Math.round(c) && (x.height = c = 14), h && (x.width = Math.abs(c * Math.sin(w)) + Math.abs(a * Math.cos(w)), x.height = Math.abs(c * Math.cos(w)) + Math.abs(a * Math.sin(w))));\n\n          if (G && 0 < x.height) {\n            for (; 250 < H.length;) {\n              delete N[H.shift()];\n            }\n\n            N[G] || H.push(G);\n            N[G] = x;\n          }\n        }\n\n        return x;\n      },\n      show: function show(a) {\n        return this.attr({\n          visibility: a ? \"inherit\" : \"visible\"\n        });\n      },\n      hide: function hide() {\n        return this.attr({\n          visibility: \"hidden\"\n        });\n      },\n      fadeOut: function fadeOut(a) {\n        var x = this;\n        x.animate({\n          opacity: 0\n        }, {\n          duration: a || 150,\n          complete: function complete() {\n            x.attr({\n              y: -9999\n            });\n          }\n        });\n      },\n      add: function add(a) {\n        var x = this.renderer,\n            h = this.element,\n            c;\n        a && (this.parentGroup = a);\n        this.parentInverted = a && a.inverted;\n        void 0 !== this.textStr && x.buildText(this);\n        this.added = !0;\n        if (!a || a.handleZ || this.zIndex) c = this.zIndexSetter();\n        c || (a ? a.element : x.box).appendChild(h);\n        if (this.onAdd) this.onAdd();\n        return this;\n      },\n      safeRemoveChild: function safeRemoveChild(a) {\n        var x = a.parentNode;\n        x && x.removeChild(a);\n      },\n      destroy: function destroy() {\n        var a = this,\n            h = a.element || {},\n            c = a.renderer.isSVG && \"SPAN\" === h.nodeName && a.parentGroup,\n            w = h.ownerSVGElement;\n        h.onclick = h.onmouseout = h.onmouseover = h.onmousemove = h.point = null;\n        P(a);\n        a.clipPath && w && (b(w.querySelectorAll(\"[clip-path]\"), function (x) {\n          -1 < x.getAttribute(\"clip-path\").indexOf(a.clipPath.element.id + \")\") && x.removeAttribute(\"clip-path\");\n        }), a.clipPath = a.clipPath.destroy());\n\n        if (a.stops) {\n          for (w = 0; w < a.stops.length; w++) {\n            a.stops[w] = a.stops[w].destroy();\n          }\n\n          a.stops = null;\n        }\n\n        a.safeRemoveChild(h);\n\n        for (a.destroyShadows(); c && c.div && 0 === c.div.childNodes.length;) {\n          h = c.parentGroup, a.safeRemoveChild(c.div), delete c.div, c = h;\n        }\n\n        a.alignTo && v(a.renderer.alignedObjects, a);\n        I(a, function (x, h) {\n          delete a[h];\n        });\n        return null;\n      },\n      shadow: function shadow(a, h, c) {\n        var x = [],\n            w,\n            p,\n            q = this.element,\n            e,\n            b,\n            d,\n            n;\n        if (!a) this.destroyShadows();else if (!this.shadows) {\n          b = L(a.width, 3);\n          d = (a.opacity || .15) / b;\n          n = this.parentInverted ? \"(-1,-1)\" : \"(\" + L(a.offsetX, 1) + \", \" + L(a.offsetY, 1) + \")\";\n\n          for (w = 1; w <= b; w++) {\n            p = q.cloneNode(0), e = 2 * b + 1 - 2 * w, m(p, {\n              isShadow: \"true\",\n              stroke: a.color || \"#000000\",\n              \"stroke-opacity\": d * w,\n              \"stroke-width\": e,\n              transform: \"translate\" + n,\n              fill: \"none\"\n            }), c && (m(p, \"height\", Math.max(m(p, \"height\") - e, 0)), p.cutHeight = e), h ? h.element.appendChild(p) : q.parentNode.insertBefore(p, q), x.push(p);\n          }\n\n          this.shadows = x;\n        }\n        return this;\n      },\n      destroyShadows: function destroyShadows() {\n        b(this.shadows || [], function (a) {\n          this.safeRemoveChild(a);\n        }, this);\n        this.shadows = void 0;\n      },\n      xGetter: function xGetter(a) {\n        \"circle\" === this.element.nodeName && (\"x\" === a ? a = \"cx\" : \"y\" === a && (a = \"cy\"));\n        return this._defaultGetter(a);\n      },\n      _defaultGetter: function _defaultGetter(a) {\n        a = L(this[a], this.element ? this.element.getAttribute(a) : null, 0);\n        /^[\\-0-9\\.]+$/.test(a) && (a = parseFloat(a));\n        return a;\n      },\n      dSetter: function dSetter(a, h, c) {\n        a && a.join && (a = a.join(\" \"));\n        /(NaN| {2}|^$)/.test(a) && (a = \"M 0 0\");\n        this[h] !== a && (c.setAttribute(h, a), this[h] = a);\n      },\n      dashstyleSetter: function dashstyleSetter(a) {\n        var x,\n            c = this[\"stroke-width\"];\n        \"inherit\" === c && (c = 1);\n\n        if (a = a && a.toLowerCase()) {\n          a = a.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n\n          for (x = a.length; x--;) {\n            a[x] = h(a[x]) * c;\n          }\n\n          a = a.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", a);\n        }\n      },\n      alignSetter: function alignSetter(a) {\n        this.element.setAttribute(\"text-anchor\", {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        }[a]);\n      },\n      opacitySetter: function opacitySetter(a, h, c) {\n        this[h] = a;\n        c.setAttribute(h, a);\n      },\n      titleSetter: function titleSetter(a) {\n        var h = this.element.getElementsByTagName(\"title\")[0];\n        h || (h = k.createElementNS(this.SVG_NS, \"title\"), this.element.appendChild(h));\n        h.firstChild && h.removeChild(h.firstChild);\n        h.appendChild(k.createTextNode(String(L(a), \"\").replace(/<[^>]*>/g, \"\")));\n      },\n      textSetter: function textSetter(a) {\n        a !== this.textStr && (delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this));\n      },\n      fillSetter: function fillSetter(a, h, c) {\n        \"string\" === typeof a ? c.setAttribute(h, a) : a && this.colorGradient(a, h, c);\n      },\n      visibilitySetter: function visibilitySetter(a, h, c) {\n        \"inherit\" === a ? c.removeAttribute(h) : this[h] !== a && c.setAttribute(h, a);\n        this[h] = a;\n      },\n      zIndexSetter: function zIndexSetter(a, c) {\n        var x = this.renderer,\n            w = this.parentGroup,\n            p = (w || x).element || x.box,\n            q,\n            e = this.element,\n            b;\n        q = this.added;\n        var d;\n        t(a) && (e.zIndex = a, a = +a, this[c] === a && (q = !1), this[c] = a);\n\n        if (q) {\n          (a = this.zIndex) && w && (w.handleZ = !0);\n          c = p.childNodes;\n\n          for (d = 0; d < c.length && !b; d++) {\n            w = c[d], q = w.zIndex, w !== e && (h(q) > a || !t(a) && t(q) || 0 > a && !t(q) && p !== x.box) && (p.insertBefore(e, w), b = !0);\n          }\n\n          b || p.appendChild(e);\n        }\n\n        return b;\n      },\n      _defaultSetter: function _defaultSetter(a, h, c) {\n        c.setAttribute(h, a);\n      }\n    });\n    C.prototype.yGetter = C.prototype.xGetter;\n\n    C.prototype.translateXSetter = C.prototype.translateYSetter = C.prototype.rotationSetter = C.prototype.verticalAlignSetter = C.prototype.scaleXSetter = C.prototype.scaleYSetter = function (a, h) {\n      this[h] = a;\n      this.doTransform = !0;\n    };\n\n    C.prototype[\"stroke-widthSetter\"] = C.prototype.strokeSetter = function (a, h, c) {\n      this[h] = a;\n      this.stroke && this[\"stroke-width\"] ? (C.prototype.fillSetter.call(this, this.stroke, \"stroke\", c), c.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0) : \"stroke-width\" === h && 0 === a && this.hasStroke && (c.removeAttribute(\"stroke\"), this.hasStroke = !1);\n    };\n\n    A = a.SVGRenderer = function () {\n      this.init.apply(this, arguments);\n    };\n\n    e(A.prototype, {\n      Element: C,\n      SVG_NS: O,\n      init: function init(a, h, w, p, q, e) {\n        var x;\n        p = this.createElement(\"svg\").attr({\n          version: \"1.1\",\n          \"class\": \"highcharts-root\"\n        }).css(this.getStyle(p));\n        x = p.element;\n        a.appendChild(x);\n        -1 === a.innerHTML.indexOf(\"xmlns\") && m(x, \"xmlns\", this.SVG_NS);\n        this.isSVG = !0;\n        this.box = x;\n        this.boxWrapper = p;\n        this.alignedObjects = [];\n        this.url = (c || K) && k.getElementsByTagName(\"base\").length ? R.location.href.replace(/#.*?$/, \"\").replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\") : \"\";\n        this.createElement(\"desc\").add().element.appendChild(k.createTextNode(\"Created with Highcharts 5.0.14\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = e;\n        this.forExport = q;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.setSize(h, w, !1);\n        var b;\n        c && a.getBoundingClientRect && (h = function h() {\n          r(a, {\n            left: 0,\n            top: 0\n          });\n          b = a.getBoundingClientRect();\n          r(a, {\n            left: Math.ceil(b.left) - b.left + \"px\",\n            top: Math.ceil(b.top) - b.top + \"px\"\n          });\n        }, h(), this.unSubPixelFix = F(R, \"resize\", h));\n      },\n      getStyle: function getStyle(a) {\n        return this.style = e({\n          fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',\n          fontSize: \"12px\"\n        }, a);\n      },\n      setStyle: function setStyle(a) {\n        this.boxWrapper.css(this.getStyle(a));\n      },\n      isHidden: function isHidden() {\n        return !this.boxWrapper.getBBox().width;\n      },\n      destroy: function destroy() {\n        var a = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        d(this.gradients || {});\n        this.gradients = null;\n        a && (this.defs = a.destroy());\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      },\n      createElement: function createElement(a) {\n        var h = new this.Element();\n        h.init(this, a);\n        return h;\n      },\n      draw: z,\n      getRadialAttr: function getRadialAttr(a, h) {\n        return {\n          cx: a[0] - a[2] / 2 + h.cx * a[2],\n          cy: a[1] - a[2] / 2 + h.cy * a[2],\n          r: h.r * a[2]\n        };\n      },\n      getSpanWidth: function getSpanWidth(a, h) {\n        var c = a.getBBox(!0).width;\n        !H && this.forExport && (c = this.measureSpanWidth(h.firstChild.data, a.styles));\n        return c;\n      },\n      applyEllipsis: function applyEllipsis(a, h, c, w) {\n        var x = a.rotation,\n            p = c,\n            q,\n            e = 0,\n            b = c.length,\n            d = function d(a) {\n          h.removeChild(h.firstChild);\n          a && h.appendChild(k.createTextNode(a));\n        },\n            n;\n\n        a.rotation = 0;\n        p = this.getSpanWidth(a, h);\n\n        if (n = p > w) {\n          for (; e <= b;) {\n            q = Math.ceil((e + b) / 2), p = c.substring(0, q) + \"\\u2026\", d(p), p = this.getSpanWidth(a, h), e === b ? e = b + 1 : p > w ? b = q - 1 : e = q;\n          }\n\n          0 === b && d(\"\");\n        }\n\n        a.rotation = x;\n        return n;\n      },\n      buildText: function buildText(a) {\n        var c = a.element,\n            w = this,\n            x = w.forExport,\n            p = L(a.textStr, \"\").toString(),\n            q = -1 !== p.indexOf(\"\\x3c\"),\n            e = c.childNodes,\n            d,\n            n,\n            g,\n            G,\n            v = m(c, \"x\"),\n            z = a.styles,\n            f = a.textWidth,\n            I = z && z.lineHeight,\n            B = z && z.textOutline,\n            D = z && \"ellipsis\" === z.textOverflow,\n            l = z && \"nowrap\" === z.whiteSpace,\n            P = z && z.fontSize,\n            t,\n            J,\n            u = e.length,\n            z = f && !a.added && this.box,\n            K = function K(a) {\n          var x;\n          x = /(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : P || w.style.fontSize || 12;\n          return I ? h(I) : w.fontMetrics(x, a.getAttribute(\"style\") ? a : c).h;\n        };\n\n        t = [p, D, l, I, B, P, f].join();\n\n        if (t !== a.textCache) {\n          for (a.textCache = t; u--;) {\n            c.removeChild(e[u]);\n          }\n\n          q || B || D || f || -1 !== p.indexOf(\" \") ? (d = /<.*class=\"([^\"]+)\".*>/, n = /<.*style=\"([^\"]+)\".*>/, g = /<.*href=\"([^\"]+)\".*>/, z && z.appendChild(c), p = q ? p.replace(/<(b|strong)>/g, '\\x3cspan style\\x3d\"font-weight:bold\"\\x3e').replace(/<(i|em)>/g, '\\x3cspan style\\x3d\"font-style:italic\"\\x3e').replace(/<a/g, \"\\x3cspan\").replace(/<\\/(b|strong|i|em|a)>/g, \"\\x3c/span\\x3e\").split(/<br.*?>/g) : [p], p = y(p, function (a) {\n            return \"\" !== a;\n          }), b(p, function (h, p) {\n            var q,\n                e = 0;\n            h = h.replace(/^\\s+|\\s+$/g, \"\").replace(/<span/g, \"|||\\x3cspan\").replace(/<\\/span>/g, \"\\x3c/span\\x3e|||\");\n            q = h.split(\"|||\");\n            b(q, function (h) {\n              if (\"\" !== h || 1 === q.length) {\n                var b = {},\n                    z = k.createElementNS(w.SVG_NS, \"tspan\"),\n                    y,\n                    I;\n                d.test(h) && (y = h.match(d)[1], m(z, \"class\", y));\n                n.test(h) && (I = h.match(n)[1].replace(/(;| |^)color([ :])/, \"$1fill$2\"), m(z, \"style\", I));\n                g.test(h) && !x && (m(z, \"onclick\", 'location.href\\x3d\"' + h.match(g)[1] + '\"'), r(z, {\n                  cursor: \"pointer\"\n                }));\n                h = (h.replace(/<(.|\\n)*?>/g, \"\") || \" \").replace(/&lt;/g, \"\\x3c\").replace(/&gt;/g, \"\\x3e\");\n\n                if (\" \" !== h) {\n                  z.appendChild(k.createTextNode(h));\n                  e ? b.dx = 0 : p && null !== v && (b.x = v);\n                  m(z, b);\n                  c.appendChild(z);\n                  !e && J && (!H && x && r(z, {\n                    display: \"block\"\n                  }), m(z, \"dy\", K(z)));\n\n                  if (f) {\n                    b = h.replace(/([^\\^])-/g, \"$1- \").split(\" \");\n                    y = 1 < q.length || p || 1 < b.length && !l;\n                    var B = [],\n                        N,\n                        P = K(z),\n                        t = a.rotation;\n\n                    for (D && (G = w.applyEllipsis(a, z, h, f)); !D && y && (b.length || B.length);) {\n                      a.rotation = 0, N = w.getSpanWidth(a, z), h = N > f, void 0 === G && (G = h), h && 1 !== b.length ? (z.removeChild(z.firstChild), B.unshift(b.pop())) : (b = B, B = [], b.length && !l && (z = k.createElementNS(O, \"tspan\"), m(z, {\n                        dy: P,\n                        x: v\n                      }), I && m(z, \"style\", I), c.appendChild(z)), N > f && (f = N)), b.length && z.appendChild(k.createTextNode(b.join(\" \").replace(/- /g, \"-\")));\n                    }\n\n                    a.rotation = t;\n                  }\n\n                  e++;\n                }\n              }\n            });\n            J = J || c.childNodes.length;\n          }), G && a.attr(\"title\", a.textStr), z && z.removeChild(c), B && a.applyTextOutline && a.applyTextOutline(B)) : c.appendChild(k.createTextNode(p.replace(/&lt;/g, \"\\x3c\").replace(/&gt;/g, \"\\x3e\")));\n        }\n      },\n      getContrast: function getContrast(a) {\n        a = l(a).rgba;\n        return 510 < a[0] + a[1] + a[2] ? \"#000000\" : \"#FFFFFF\";\n      },\n      button: function button(a, h, c, w, q, b, d, n, g) {\n        var x = this.label(a, h, c, g, null, null, null, null, \"button\"),\n            k = 0;\n        x.attr(p({\n          padding: 8,\n          r: 2\n        }, q));\n        var z, H, v, f;\n        q = p({\n          fill: \"#f7f7f7\",\n          stroke: \"#cccccc\",\n          \"stroke-width\": 1,\n          style: {\n            color: \"#333333\",\n            cursor: \"pointer\",\n            fontWeight: \"normal\"\n          }\n        }, q);\n        z = q.style;\n        delete q.style;\n        b = p(q, {\n          fill: \"#e6e6e6\"\n        }, b);\n        H = b.style;\n        delete b.style;\n        d = p(q, {\n          fill: \"#e6ebf5\",\n          style: {\n            color: \"#000000\",\n            fontWeight: \"bold\"\n          }\n        }, d);\n        v = d.style;\n        delete d.style;\n        n = p(q, {\n          style: {\n            color: \"#cccccc\"\n          }\n        }, n);\n        f = n.style;\n        delete n.style;\n        F(x.element, G ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== k && x.setState(1);\n        });\n        F(x.element, G ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== k && x.setState(k);\n        });\n\n        x.setState = function (a) {\n          1 !== a && (x.state = k = a);\n          x.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][a || 0]);\n          x.attr([q, b, d, n][a || 0]).css([z, H, v, f][a || 0]);\n        };\n\n        x.attr(q).css(e({\n          cursor: \"default\"\n        }, z));\n        return x.on(\"click\", function (a) {\n          3 !== k && w.call(x, a);\n        });\n      },\n      crispLine: function crispLine(a, h) {\n        a[1] === a[4] && (a[1] = a[4] = Math.round(a[1]) - h % 2 / 2);\n        a[2] === a[5] && (a[2] = a[5] = Math.round(a[2]) + h % 2 / 2);\n        return a;\n      },\n      path: function path(a) {\n        var h = {\n          fill: \"none\"\n        };\n        J(a) ? h.d = a : q(a) && e(h, a);\n        return this.createElement(\"path\").attr(h);\n      },\n      circle: function circle(a, h, c) {\n        a = q(a) ? a : {\n          x: a,\n          y: h,\n          r: c\n        };\n        h = this.createElement(\"circle\");\n\n        h.xSetter = h.ySetter = function (a, h, c) {\n          c.setAttribute(\"c\" + h, a);\n        };\n\n        return h.attr(a);\n      },\n      arc: function arc(a, h, c, w, p, b) {\n        q(a) ? (w = a, h = w.y, c = w.r, a = w.x) : w = {\n          innerR: w,\n          start: p,\n          end: b\n        };\n        a = this.symbol(\"arc\", a, h, c, c, w);\n        a.r = c;\n        return a;\n      },\n      rect: function rect(a, h, c, w, p, b) {\n        p = q(a) ? a.r : p;\n        var x = this.createElement(\"rect\");\n        a = q(a) ? a : void 0 === a ? {} : {\n          x: a,\n          y: h,\n          width: Math.max(c, 0),\n          height: Math.max(w, 0)\n        };\n        void 0 !== b && (a.strokeWidth = b, a = x.crisp(a));\n        a.fill = \"none\";\n        p && (a.r = p);\n\n        x.rSetter = function (a, h, c) {\n          m(c, {\n            rx: a,\n            ry: a\n          });\n        };\n\n        return x.attr(a);\n      },\n      setSize: function setSize(a, h, c) {\n        var w = this.alignedObjects,\n            p = w.length;\n        this.width = a;\n        this.height = h;\n\n        for (this.boxWrapper.animate({\n          width: a,\n          height: h\n        }, {\n          step: function step() {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: L(c, !0) ? void 0 : 0\n        }); p--;) {\n          w[p].align();\n        }\n      },\n      g: function g(a) {\n        var h = this.createElement(\"g\");\n        return a ? h.attr({\n          \"class\": \"highcharts-\" + a\n        }) : h;\n      },\n      image: function image(a, h, c, w, p) {\n        var x = {\n          preserveAspectRatio: \"none\"\n        };\n        1 < arguments.length && e(x, {\n          x: h,\n          y: c,\n          width: w,\n          height: p\n        });\n        x = this.createElement(\"image\").attr(x);\n        x.element.setAttributeNS ? x.element.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", a) : x.element.setAttribute(\"hc-svg-href\", a);\n        return x;\n      },\n      symbol: function symbol(a, h, c, w, p, q) {\n        var x = this,\n            d,\n            n = /^url\\((.*?)\\)$/,\n            g = n.test(a),\n            z = !g && (this.symbols[a] ? a : \"circle\"),\n            G = z && this.symbols[z],\n            H = t(h) && G && G.call(this.symbols, Math.round(h), Math.round(c), w, p, q),\n            v,\n            y;\n        G ? (d = this.path(H), d.attr(\"fill\", \"none\"), e(d, {\n          symbolName: z,\n          x: h,\n          y: c,\n          width: w,\n          height: p\n        }), q && e(d, q)) : g && (v = a.match(n)[1], d = this.image(v), d.imgwidth = L(Q[v] && Q[v].width, q && q.width), d.imgheight = L(Q[v] && Q[v].height, q && q.height), y = function y() {\n          d.attr({\n            width: d.width,\n            height: d.height\n          });\n        }, b([\"width\", \"height\"], function (a) {\n          d[a + \"Setter\"] = function (a, h) {\n            var c = {},\n                w = this[\"img\" + h],\n                p = \"width\" === h ? \"translateX\" : \"translateY\";\n            this[h] = a;\n            t(w) && (this.element && this.element.setAttribute(h, w), this.alignByTranslate || (c[p] = ((this[h] || 0) - w) / 2, this.attr(c)));\n          };\n        }), t(h) && d.attr({\n          x: h,\n          y: c\n        }), d.isImg = !0, t(d.imgwidth) && t(d.imgheight) ? y() : (d.attr({\n          width: 0,\n          height: 0\n        }), u(\"img\", {\n          onload: function onload() {\n            var a = f[x.chartIndex];\n            0 === this.width && (r(this, {\n              position: \"absolute\",\n              top: \"-999em\"\n            }), k.body.appendChild(this));\n            Q[v] = {\n              width: this.width,\n              height: this.height\n            };\n            d.imgwidth = this.width;\n            d.imgheight = this.height;\n            d.element && y();\n            this.parentNode && this.parentNode.removeChild(this);\n            x.imgCount--;\n            if (!x.imgCount && a && a.onload) a.onload();\n          },\n          src: v\n        }), this.imgCount++));\n        return d;\n      },\n      symbols: {\n        circle: function circle(a, h, c, w) {\n          return this.arc(a + c / 2, h + w / 2, c / 2, w / 2, {\n            start: 0,\n            end: 2 * Math.PI,\n            open: !1\n          });\n        },\n        square: function square(a, h, c, w) {\n          return [\"M\", a, h, \"L\", a + c, h, a + c, h + w, a, h + w, \"Z\"];\n        },\n        triangle: function triangle(a, h, c, w) {\n          return [\"M\", a + c / 2, h, \"L\", a + c, h + w, a, h + w, \"Z\"];\n        },\n        \"triangle-down\": function triangleDown(a, h, c, w) {\n          return [\"M\", a, h, \"L\", a + c, h, a + c / 2, h + w, \"Z\"];\n        },\n        diamond: function diamond(a, h, c, w) {\n          return [\"M\", a + c / 2, h, \"L\", a + c, h + w / 2, a + c / 2, h + w, a, h + w / 2, \"Z\"];\n        },\n        arc: function arc(a, h, c, w, p) {\n          var q = p.start,\n              b = p.r || c,\n              x = p.r || w || c,\n              e = p.end - .001;\n          c = p.innerR;\n          w = L(p.open, .001 > Math.abs(p.end - p.start - 2 * Math.PI));\n          var d = Math.cos(q),\n              n = Math.sin(q),\n              g = Math.cos(e),\n              e = Math.sin(e);\n          p = .001 > p.end - q - Math.PI ? 0 : 1;\n          b = [\"M\", a + b * d, h + x * n, \"A\", b, x, 0, p, 1, a + b * g, h + x * e];\n          t(c) && b.push(w ? \"M\" : \"L\", a + c * g, h + c * e, \"A\", c, c, 0, p, 0, a + c * d, h + c * n);\n          b.push(w ? \"\" : \"Z\");\n          return b;\n        },\n        callout: function callout(a, h, c, w, p) {\n          var q = Math.min(p && p.r || 0, c, w),\n              b = q + 6,\n              e = p && p.anchorX;\n          p = p && p.anchorY;\n          var d;\n          d = [\"M\", a + q, h, \"L\", a + c - q, h, \"C\", a + c, h, a + c, h, a + c, h + q, \"L\", a + c, h + w - q, \"C\", a + c, h + w, a + c, h + w, a + c - q, h + w, \"L\", a + q, h + w, \"C\", a, h + w, a, h + w, a, h + w - q, \"L\", a, h + q, \"C\", a, h, a, h, a + q, h];\n          e && e > c ? p > h + b && p < h + w - b ? d.splice(13, 3, \"L\", a + c, p - 6, a + c + 6, p, a + c, p + 6, a + c, h + w - q) : d.splice(13, 3, \"L\", a + c, w / 2, e, p, a + c, w / 2, a + c, h + w - q) : e && 0 > e ? p > h + b && p < h + w - b ? d.splice(33, 3, \"L\", a, p + 6, a - 6, p, a, p - 6, a, h + q) : d.splice(33, 3, \"L\", a, w / 2, e, p, a, w / 2, a, h + q) : p && p > w && e > a + b && e < a + c - b ? d.splice(23, 3, \"L\", e + 6, h + w, e, h + w + 6, e - 6, h + w, a + q, h + w) : p && 0 > p && e > a + b && e < a + c - b && d.splice(3, 3, \"L\", e - 6, h, e, h - 6, e + 6, h, c - q, h);\n          return d;\n        }\n      },\n      clipRect: function clipRect(h, c, w, p) {\n        var q = a.uniqueKey(),\n            b = this.createElement(\"clipPath\").attr({\n          id: q\n        }).add(this.defs);\n        h = this.rect(h, c, w, p, 0).add(b);\n        h.id = q;\n        h.clipPath = b;\n        h.count = 0;\n        return h;\n      },\n      text: function text(a, h, c, w) {\n        var p = !H && this.forExport,\n            q = {};\n        if (w && (this.allowHTML || !this.forExport)) return this.html(a, h, c);\n        q.x = Math.round(h || 0);\n        c && (q.y = Math.round(c));\n        if (a || 0 === a) q.text = a;\n        a = this.createElement(\"text\").attr(q);\n        p && a.css({\n          position: \"absolute\"\n        });\n        w || (a.xSetter = function (a, h, c) {\n          var w = c.getElementsByTagName(\"tspan\"),\n              p,\n              q = c.getAttribute(h),\n              b;\n\n          for (b = 0; b < w.length; b++) {\n            p = w[b], p.getAttribute(h) === q && p.setAttribute(h, a);\n          }\n\n          c.setAttribute(h, a);\n        });\n        return a;\n      },\n      fontMetrics: function fontMetrics(a, c) {\n        a = a || c && c.style && c.style.fontSize || this.style && this.style.fontSize;\n        a = /px/.test(a) ? h(a) : /em/.test(a) ? parseFloat(a) * (c ? this.fontMetrics(null, c.parentNode).f : 16) : 12;\n        c = 24 > a ? a + 3 : Math.round(1.2 * a);\n        return {\n          h: c,\n          b: Math.round(.8 * c),\n          f: a\n        };\n      },\n      rotCorr: function rotCorr(a, h, c) {\n        var w = a;\n        h && c && (w = Math.max(w * Math.cos(h * g), 4));\n        return {\n          x: -a / 3 * Math.sin(h * g),\n          y: w\n        };\n      },\n      label: function label(h, c, q, d, n, g, k, z, G) {\n        var x = this,\n            H = x.g(\"button\" !== G && \"label\"),\n            v = H.text = x.text(\"\", 0, 0, k).attr({\n          zIndex: 1\n        }),\n            f,\n            y,\n            I = 0,\n            B = 3,\n            D = 0,\n            r,\n            l,\n            P,\n            m,\n            J,\n            O = {},\n            L,\n            u,\n            N = /^url\\((.*?)\\)$/.test(d),\n            K = N,\n            U,\n            T,\n            Q,\n            R;\n        G && H.addClass(\"highcharts-\" + G);\n        K = N;\n\n        U = function U() {\n          return (L || 0) % 2 / 2;\n        };\n\n        T = function T() {\n          var a = v.element.style,\n              h = {};\n          y = (void 0 === r || void 0 === l || J) && t(v.textStr) && v.getBBox();\n          H.width = (r || y.width || 0) + 2 * B + D;\n          H.height = (l || y.height || 0) + 2 * B;\n          u = B + x.fontMetrics(a && a.fontSize, v).b;\n          K && (f || (H.box = f = x.symbols[d] || N ? x.symbol(d) : x.rect(), f.addClass((\"button\" === G ? \"\" : \"highcharts-label-box\") + (G ? \" highcharts-\" + G + \"-box\" : \"\")), f.add(H), a = U(), h.x = a, h.y = (z ? -u : 0) + a), h.width = Math.round(H.width), h.height = Math.round(H.height), f.attr(e(h, O)), O = {});\n        };\n\n        Q = function Q() {\n          var a = D + B,\n              h;\n          h = z ? 0 : u;\n          t(r) && y && (\"center\" === J || \"right\" === J) && (a += {\n            center: .5,\n            right: 1\n          }[J] * (r - y.width));\n          if (a !== v.x || h !== v.y) v.attr(\"x\", a), void 0 !== h && v.attr(\"y\", h);\n          v.x = a;\n          v.y = h;\n        };\n\n        R = function R(a, h) {\n          f ? f.attr(a, h) : O[a] = h;\n        };\n\n        H.onAdd = function () {\n          v.add(H);\n          H.attr({\n            text: h || 0 === h ? h : \"\",\n            x: c,\n            y: q\n          });\n          f && t(n) && H.attr({\n            anchorX: n,\n            anchorY: g\n          });\n        };\n\n        H.widthSetter = function (h) {\n          r = a.isNumber(h) ? h : null;\n        };\n\n        H.heightSetter = function (a) {\n          l = a;\n        };\n\n        H[\"text-alignSetter\"] = function (a) {\n          J = a;\n        };\n\n        H.paddingSetter = function (a) {\n          t(a) && a !== B && (B = H.padding = a, Q());\n        };\n\n        H.paddingLeftSetter = function (a) {\n          t(a) && a !== D && (D = a, Q());\n        };\n\n        H.alignSetter = function (a) {\n          a = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[a];\n          a !== I && (I = a, y && H.attr({\n            x: P\n          }));\n        };\n\n        H.textSetter = function (a) {\n          void 0 !== a && v.textSetter(a);\n          T();\n          Q();\n        };\n\n        H[\"stroke-widthSetter\"] = function (a, h) {\n          a && (K = !0);\n          L = this[\"stroke-width\"] = a;\n          R(h, a);\n        };\n\n        H.strokeSetter = H.fillSetter = H.rSetter = function (a, h) {\n          \"r\" !== h && (\"fill\" === h && a && (K = !0), H[h] = a);\n          R(h, a);\n        };\n\n        H.anchorXSetter = function (a, h) {\n          n = H.anchorX = a;\n          R(h, Math.round(a) - U() - P);\n        };\n\n        H.anchorYSetter = function (a, h) {\n          g = H.anchorY = a;\n          R(h, a - m);\n        };\n\n        H.xSetter = function (a) {\n          H.x = a;\n          I && (a -= I * ((r || y.width) + 2 * B));\n          P = Math.round(a);\n          H.attr(\"translateX\", P);\n        };\n\n        H.ySetter = function (a) {\n          m = H.y = Math.round(a);\n          H.attr(\"translateY\", m);\n        };\n\n        var V = H.css;\n        return e(H, {\n          css: function css(a) {\n            if (a) {\n              var h = {};\n              a = p(a);\n              b(H.textProps, function (c) {\n                void 0 !== a[c] && (h[c] = a[c], delete a[c]);\n              });\n              v.css(h);\n            }\n\n            return V.call(H, a);\n          },\n          getBBox: function getBBox() {\n            return {\n              width: y.width + 2 * B,\n              height: y.height + 2 * B,\n              x: y.x - B,\n              y: y.y - B\n            };\n          },\n          shadow: function shadow(a) {\n            a && (T(), f && f.shadow(a));\n            return H;\n          },\n          destroy: function destroy() {\n            w(H.element, \"mouseenter\");\n            w(H.element, \"mouseleave\");\n            v && (v = v.destroy());\n            f && (f = f.destroy());\n            C.prototype.destroy.call(H);\n            H = x = T = Q = R = null;\n          }\n        });\n      }\n    });\n    a.Renderer = A;\n  })(M);\n\n  (function (a) {\n    var C = a.attr,\n        A = a.createElement,\n        F = a.css,\n        E = a.defined,\n        m = a.each,\n        f = a.extend,\n        l = a.isFirefox,\n        r = a.isMS,\n        u = a.isWebKit,\n        t = a.pInt,\n        g = a.SVGRenderer,\n        d = a.win,\n        k = a.wrap;\n    f(a.SVGElement.prototype, {\n      htmlCss: function htmlCss(a) {\n        var b = this.element;\n        if (b = a && \"SPAN\" === b.tagName && a.width) delete a.width, this.textWidth = b, this.updateTransform();\n        a && \"ellipsis\" === a.textOverflow && (a.whiteSpace = \"nowrap\", a.overflow = \"hidden\");\n        this.styles = f(this.styles, a);\n        F(this.element, a);\n        return this;\n      },\n      htmlGetBBox: function htmlGetBBox() {\n        var a = this.element;\n        \"text\" === a.nodeName && (a.style.position = \"absolute\");\n        return {\n          x: a.offsetLeft,\n          y: a.offsetTop,\n          width: a.offsetWidth,\n          height: a.offsetHeight\n        };\n      },\n      htmlUpdateTransform: function htmlUpdateTransform() {\n        if (this.added) {\n          var a = this.renderer,\n              e = this.element,\n              d = this.translateX || 0,\n              g = this.translateY || 0,\n              n = this.x || 0,\n              k = this.y || 0,\n              f = this.textAlign || \"left\",\n              c = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[f],\n              G = this.styles;\n          F(e, {\n            marginLeft: d,\n            marginTop: g\n          });\n          this.shadows && m(this.shadows, function (a) {\n            F(a, {\n              marginLeft: d + 1,\n              marginTop: g + 1\n            });\n          });\n          this.inverted && m(e.childNodes, function (c) {\n            a.invertChild(c, e);\n          });\n\n          if (\"SPAN\" === e.tagName) {\n            var q = this.rotation,\n                B = t(this.textWidth),\n                r = G && G.whiteSpace,\n                p = [q, f, e.innerHTML, this.textWidth, this.textAlign].join();\n            p !== this.cTT && (G = a.fontMetrics(e.style.fontSize).b, E(q) && this.setSpanRotation(q, c, G), F(e, {\n              width: \"\",\n              whiteSpace: r || \"nowrap\"\n            }), e.offsetWidth > B && /[ \\-]/.test(e.textContent || e.innerText) && F(e, {\n              width: B + \"px\",\n              display: \"block\",\n              whiteSpace: r || \"normal\"\n            }), this.getSpanCorrection(e.offsetWidth, G, c, q, f));\n            F(e, {\n              left: n + (this.xCorr || 0) + \"px\",\n              top: k + (this.yCorr || 0) + \"px\"\n            });\n            u && (G = e.offsetHeight);\n            this.cTT = p;\n          }\n        } else this.alignOnAdd = !0;\n      },\n      setSpanRotation: function setSpanRotation(a, e, g) {\n        var b = {},\n            n = r ? \"-ms-transform\" : u ? \"-webkit-transform\" : l ? \"MozTransform\" : d.opera ? \"-o-transform\" : \"\";\n        b[n] = b.transform = \"rotate(\" + a + \"deg)\";\n        b[n + (l ? \"Origin\" : \"-origin\")] = b.transformOrigin = 100 * e + \"% \" + g + \"px\";\n        F(this.element, b);\n      },\n      getSpanCorrection: function getSpanCorrection(a, e, d) {\n        this.xCorr = -a * d;\n        this.yCorr = -e;\n      }\n    });\n    f(g.prototype, {\n      html: function html(a, e, d) {\n        var b = this.createElement(\"span\"),\n            n = b.element,\n            g = b.renderer,\n            v = g.isSVG,\n            c = function c(a, _c) {\n          m([\"opacity\", \"visibility\"], function (q) {\n            k(a, q + \"Setter\", function (a, p, q, b) {\n              a.call(this, p, q, b);\n              _c[q] = p;\n            });\n          });\n        };\n\n        b.textSetter = function (a) {\n          a !== n.innerHTML && delete this.bBox;\n          n.innerHTML = this.textStr = a;\n          b.htmlUpdateTransform();\n        };\n\n        v && c(b, b.element.style);\n\n        b.xSetter = b.ySetter = b.alignSetter = b.rotationSetter = function (a, c) {\n          \"align\" === c && (c = \"textAlign\");\n          b[c] = a;\n          b.htmlUpdateTransform();\n        };\n\n        b.attr({\n          text: a,\n          x: Math.round(e),\n          y: Math.round(d)\n        }).css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize,\n          position: \"absolute\"\n        });\n        n.style.whiteSpace = \"nowrap\";\n        b.css = b.htmlCss;\n        v && (b.add = function (a) {\n          var q,\n              e = g.box.parentNode,\n              d = [];\n\n          if (this.parentGroup = a) {\n            if (q = a.div, !q) {\n              for (; a;) {\n                d.push(a), a = a.parentGroup;\n              }\n\n              m(d.reverse(), function (a) {\n                var p,\n                    n = C(a.element, \"class\");\n                n && (n = {\n                  className: n\n                });\n                q = a.div = a.div || A(\"div\", n, {\n                  position: \"absolute\",\n                  left: (a.translateX || 0) + \"px\",\n                  top: (a.translateY || 0) + \"px\",\n                  display: a.display,\n                  opacity: a.opacity,\n                  pointerEvents: a.styles && a.styles.pointerEvents\n                }, q || e);\n                p = q.style;\n                f(a, {\n                  classSetter: function classSetter(a) {\n                    this.element.setAttribute(\"class\", a);\n                    q.className = a;\n                  },\n                  on: function on() {\n                    d[0].div && b.on.apply({\n                      element: d[0].div\n                    }, arguments);\n                    return a;\n                  },\n                  translateXSetter: function translateXSetter(c, h) {\n                    p.left = c + \"px\";\n                    a[h] = c;\n                    a.doTransform = !0;\n                  },\n                  translateYSetter: function translateYSetter(c, h) {\n                    p.top = c + \"px\";\n                    a[h] = c;\n                    a.doTransform = !0;\n                  }\n                });\n                c(a, p);\n              });\n            }\n          } else q = e;\n\n          q.appendChild(n);\n          b.added = !0;\n          b.alignOnAdd && b.htmlUpdateTransform();\n          return b;\n        });\n        return b;\n      }\n    });\n  })(M);\n\n  (function (a) {\n    var C,\n        A,\n        F = a.createElement,\n        E = a.css,\n        m = a.defined,\n        f = a.deg2rad,\n        l = a.discardElement,\n        r = a.doc,\n        u = a.each,\n        t = a.erase,\n        g = a.extend;\n    C = a.extendClass;\n    var d = a.isArray,\n        k = a.isNumber,\n        b = a.isObject,\n        e = a.merge;\n    A = a.noop;\n    var v = a.pick,\n        y = a.pInt,\n        n = a.SVGElement,\n        D = a.SVGRenderer,\n        J = a.win;\n    a.svg || (A = {\n      docMode8: r && 8 === r.documentMode,\n      init: function init(a, b) {\n        var c = [\"\\x3c\", b, ' filled\\x3d\"f\" stroked\\x3d\"f\"'],\n            e = [\"position: \", \"absolute\", \";\"],\n            d = \"div\" === b;\n        (\"shape\" === b || d) && e.push(\"left:0;top:0;width:1px;height:1px;\");\n        e.push(\"visibility: \", d ? \"hidden\" : \"visible\");\n        c.push(' style\\x3d\"', e.join(\"\"), '\"/\\x3e');\n        b && (c = d || \"span\" === b || \"img\" === b ? c.join(\"\") : a.prepVML(c), this.element = F(c));\n        this.renderer = a;\n      },\n      add: function add(a) {\n        var c = this.renderer,\n            b = this.element,\n            e = c.box,\n            d = a && a.inverted,\n            e = a ? a.element || a : e;\n        a && (this.parentGroup = a);\n        d && c.invertChild(b, e);\n        e.appendChild(b);\n        this.added = !0;\n        this.alignOnAdd && !this.deferUpdateTransform && this.updateTransform();\n        if (this.onAdd) this.onAdd();\n        this.className && this.attr(\"class\", this.className);\n        return this;\n      },\n      updateTransform: n.prototype.htmlUpdateTransform,\n      setSpanRotation: function setSpanRotation() {\n        var a = this.rotation,\n            b = Math.cos(a * f),\n            q = Math.sin(a * f);\n        E(this.element, {\n          filter: a ? [\"progid:DXImageTransform.Microsoft.Matrix(M11\\x3d\", b, \", M12\\x3d\", -q, \", M21\\x3d\", q, \", M22\\x3d\", b, \", sizingMethod\\x3d'auto expand')\"].join(\"\") : \"none\"\n        });\n      },\n      getSpanCorrection: function getSpanCorrection(a, b, q, e, d) {\n        var c = e ? Math.cos(e * f) : 1,\n            n = e ? Math.sin(e * f) : 0,\n            g = v(this.elemHeight, this.element.offsetHeight),\n            k;\n        this.xCorr = 0 > c && -a;\n        this.yCorr = 0 > n && -g;\n        k = 0 > c * n;\n        this.xCorr += n * b * (k ? 1 - q : q);\n        this.yCorr -= c * b * (e ? k ? q : 1 - q : 1);\n        d && \"left\" !== d && (this.xCorr -= a * q * (0 > c ? -1 : 1), e && (this.yCorr -= g * q * (0 > n ? -1 : 1)), E(this.element, {\n          textAlign: d\n        }));\n      },\n      pathToVML: function pathToVML(a) {\n        for (var c = a.length, b = []; c--;) {\n          k(a[c]) ? b[c] = Math.round(10 * a[c]) - 5 : \"Z\" === a[c] ? b[c] = \"x\" : (b[c] = a[c], !a.isArc || \"wa\" !== a[c] && \"at\" !== a[c] || (b[c + 5] === b[c + 7] && (b[c + 7] += a[c + 7] > a[c + 5] ? 1 : -1), b[c + 6] === b[c + 8] && (b[c + 8] += a[c + 8] > a[c + 6] ? 1 : -1)));\n        }\n\n        return b.join(\" \") || \"x\";\n      },\n      clip: function clip(a) {\n        var c = this,\n            b;\n        a ? (b = a.members, t(b, c), b.push(c), c.destroyClip = function () {\n          t(b, c);\n        }, a = a.getCSS(c)) : (c.destroyClip && c.destroyClip(), a = {\n          clip: c.docMode8 ? \"inherit\" : \"rect(auto)\"\n        });\n        return c.css(a);\n      },\n      css: n.prototype.htmlCss,\n      safeRemoveChild: function safeRemoveChild(a) {\n        a.parentNode && l(a);\n      },\n      destroy: function destroy() {\n        this.destroyClip && this.destroyClip();\n        return n.prototype.destroy.apply(this);\n      },\n      on: function on(a, b) {\n        this.element[\"on\" + a] = function () {\n          var a = J.event;\n          a.target = a.srcElement;\n          b(a);\n        };\n\n        return this;\n      },\n      cutOffPath: function cutOffPath(a, b) {\n        var c;\n        a = a.split(/[ ,]/);\n        c = a.length;\n        if (9 === c || 11 === c) a[c - 4] = a[c - 2] = y(a[c - 2]) - 10 * b;\n        return a.join(\" \");\n      },\n      shadow: function shadow(a, b, e) {\n        var c = [],\n            q,\n            p = this.element,\n            d = this.renderer,\n            n,\n            g = p.style,\n            h,\n            w = p.path,\n            k,\n            H,\n            f,\n            D;\n        w && \"string\" !== typeof w.value && (w = \"x\");\n        H = w;\n\n        if (a) {\n          f = v(a.width, 3);\n          D = (a.opacity || .15) / f;\n\n          for (q = 1; 3 >= q; q++) {\n            k = 2 * f + 1 - 2 * q, e && (H = this.cutOffPath(w.value, k + .5)), h = ['\\x3cshape isShadow\\x3d\"true\" strokeweight\\x3d\"', k, '\" filled\\x3d\"false\" path\\x3d\"', H, '\" coordsize\\x3d\"10 10\" style\\x3d\"', p.style.cssText, '\" /\\x3e'], n = F(d.prepVML(h), null, {\n              left: y(g.left) + v(a.offsetX, 1),\n              top: y(g.top) + v(a.offsetY, 1)\n            }), e && (n.cutOff = k + 1), h = ['\\x3cstroke color\\x3d\"', a.color || \"#000000\", '\" opacity\\x3d\"', D * q, '\"/\\x3e'], F(d.prepVML(h), null, null, n), b ? b.element.appendChild(n) : p.parentNode.insertBefore(n, p), c.push(n);\n          }\n\n          this.shadows = c;\n        }\n\n        return this;\n      },\n      updateShadows: A,\n      setAttr: function setAttr(a, b) {\n        this.docMode8 ? this.element[a] = b : this.element.setAttribute(a, b);\n      },\n      classSetter: function classSetter(a) {\n        (this.added ? this.element : this).className = a;\n      },\n      dashstyleSetter: function dashstyleSetter(a, b, e) {\n        (e.getElementsByTagName(\"stroke\")[0] || F(this.renderer.prepVML([\"\\x3cstroke/\\x3e\"]), null, null, e))[b] = a || \"solid\";\n        this[b] = a;\n      },\n      dSetter: function dSetter(a, b, e) {\n        var c = this.shadows;\n        a = a || [];\n        this.d = a.join && a.join(\" \");\n        e.path = a = this.pathToVML(a);\n        if (c) for (e = c.length; e--;) {\n          c[e].path = c[e].cutOff ? this.cutOffPath(a, c[e].cutOff) : a;\n        }\n        this.setAttr(b, a);\n      },\n      fillSetter: function fillSetter(a, b, e) {\n        var c = e.nodeName;\n        \"SPAN\" === c ? e.style.color = a : \"IMG\" !== c && (e.filled = \"none\" !== a, this.setAttr(\"fillcolor\", this.renderer.color(a, e, b, this)));\n      },\n      \"fill-opacitySetter\": function fillOpacitySetter(a, b, e) {\n        F(this.renderer.prepVML([\"\\x3c\", b.split(\"-\")[0], ' opacity\\x3d\"', a, '\"/\\x3e']), null, null, e);\n      },\n      opacitySetter: A,\n      rotationSetter: function rotationSetter(a, b, e) {\n        e = e.style;\n        this[b] = e[b] = a;\n        e.left = -Math.round(Math.sin(a * f) + 1) + \"px\";\n        e.top = Math.round(Math.cos(a * f)) + \"px\";\n      },\n      strokeSetter: function strokeSetter(a, b, e) {\n        this.setAttr(\"strokecolor\", this.renderer.color(a, e, b, this));\n      },\n      \"stroke-widthSetter\": function strokeWidthSetter(a, b, e) {\n        e.stroked = !!a;\n        this[b] = a;\n        k(a) && (a += \"px\");\n        this.setAttr(\"strokeweight\", a);\n      },\n      titleSetter: function titleSetter(a, b) {\n        this.setAttr(b, a);\n      },\n      visibilitySetter: function visibilitySetter(a, b, e) {\n        \"inherit\" === a && (a = \"visible\");\n        this.shadows && u(this.shadows, function (c) {\n          c.style[b] = a;\n        });\n        \"DIV\" === e.nodeName && (a = \"hidden\" === a ? \"-999em\" : 0, this.docMode8 || (e.style[b] = a ? \"visible\" : \"hidden\"), b = \"top\");\n        e.style[b] = a;\n      },\n      xSetter: function xSetter(a, b, e) {\n        this[b] = a;\n        \"x\" === b ? b = \"left\" : \"y\" === b && (b = \"top\");\n        this.updateClipping ? (this[b] = a, this.updateClipping()) : e.style[b] = a;\n      },\n      zIndexSetter: function zIndexSetter(a, b, e) {\n        e.style[b] = a;\n      }\n    }, A[\"stroke-opacitySetter\"] = A[\"fill-opacitySetter\"], a.VMLElement = A = C(n, A), A.prototype.ySetter = A.prototype.widthSetter = A.prototype.heightSetter = A.prototype.xSetter, A = {\n      Element: A,\n      isIE8: -1 < J.navigator.userAgent.indexOf(\"MSIE 8.0\"),\n      init: function init(a, b, e) {\n        var c, d;\n        this.alignedObjects = [];\n        c = this.createElement(\"div\").css({\n          position: \"relative\"\n        });\n        d = c.element;\n        a.appendChild(c.element);\n        this.isVML = !0;\n        this.box = d;\n        this.boxWrapper = c;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.setSize(b, e, !1);\n\n        if (!r.namespaces.hcv) {\n          r.namespaces.add(\"hcv\", \"urn:schemas-microsoft-com:vml\");\n\n          try {\n            r.createStyleSheet().cssText = \"hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke{ behavior:url(#default#VML); display: inline-block; } \";\n          } catch (p) {\n            r.styleSheets[0].cssText += \"hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke{ behavior:url(#default#VML); display: inline-block; } \";\n          }\n        }\n      },\n      isHidden: function isHidden() {\n        return !this.box.offsetWidth;\n      },\n      clipRect: function clipRect(a, e, d, n) {\n        var c = this.createElement(),\n            p = b(a);\n        return g(c, {\n          members: [],\n          count: 0,\n          left: (p ? a.x : a) + 1,\n          top: (p ? a.y : e) + 1,\n          width: (p ? a.width : d) - 1,\n          height: (p ? a.height : n) - 1,\n          getCSS: function getCSS(a) {\n            var c = a.element,\n                b = c.nodeName,\n                h = a.inverted,\n                w = this.top - (\"shape\" === b ? c.offsetTop : 0),\n                p = this.left,\n                c = p + this.width,\n                e = w + this.height,\n                w = {\n              clip: \"rect(\" + Math.round(h ? p : w) + \"px,\" + Math.round(h ? e : c) + \"px,\" + Math.round(h ? c : e) + \"px,\" + Math.round(h ? w : p) + \"px)\"\n            };\n            !h && a.docMode8 && \"DIV\" === b && g(w, {\n              width: c + \"px\",\n              height: e + \"px\"\n            });\n            return w;\n          },\n          updateClipping: function updateClipping() {\n            u(c.members, function (a) {\n              a.element && a.css(c.getCSS(a));\n            });\n          }\n        });\n      },\n      color: function color(c, b, e, d) {\n        var q = this,\n            p,\n            n = /^rgba/,\n            g,\n            k,\n            h = \"none\";\n        c && c.linearGradient ? k = \"gradient\" : c && c.radialGradient && (k = \"pattern\");\n\n        if (k) {\n          var w,\n              v,\n              H = c.linearGradient || c.radialGradient,\n              f,\n              D,\n              y,\n              x,\n              r,\n              B = \"\";\n          c = c.stops;\n\n          var l,\n              G = [],\n              m = function m() {\n            g = ['\\x3cfill colors\\x3d\"' + G.join(\",\") + '\" opacity\\x3d\"', y, '\" o:opacity2\\x3d\"', D, '\" type\\x3d\"', k, '\" ', B, 'focus\\x3d\"100%\" method\\x3d\"any\" /\\x3e'];\n            F(q.prepVML(g), null, null, b);\n          };\n\n          f = c[0];\n          l = c[c.length - 1];\n          0 < f[0] && c.unshift([0, f[1]]);\n          1 > l[0] && c.push([1, l[1]]);\n          u(c, function (h, c) {\n            n.test(h[1]) ? (p = a.color(h[1]), w = p.get(\"rgb\"), v = p.get(\"a\")) : (w = h[1], v = 1);\n            G.push(100 * h[0] + \"% \" + w);\n            c ? (y = v, x = w) : (D = v, r = w);\n          });\n          if (\"fill\" === e) {\n            if (\"gradient\" === k) e = H.x1 || H[0] || 0, c = H.y1 || H[1] || 0, f = H.x2 || H[2] || 0, H = H.y2 || H[3] || 0, B = 'angle\\x3d\"' + (90 - 180 * Math.atan((H - c) / (f - e)) / Math.PI) + '\"', m();else {\n              var h = H.r,\n                  t = 2 * h,\n                  J = 2 * h,\n                  A = H.cx,\n                  C = H.cy,\n                  E = b.radialReference,\n                  M,\n                  h = function h() {\n                E && (M = d.getBBox(), A += (E[0] - M.x) / M.width - .5, C += (E[1] - M.y) / M.height - .5, t *= E[2] / M.width, J *= E[2] / M.height);\n                B = 'src\\x3d\"' + a.getOptions().global.VMLRadialGradientURL + '\" size\\x3d\"' + t + \",\" + J + '\" origin\\x3d\"0.5,0.5\" position\\x3d\"' + A + \",\" + C + '\" color2\\x3d\"' + r + '\" ';\n                m();\n              };\n\n              d.added ? h() : d.onAdd = h;\n              h = x;\n            }\n          } else h = w;\n        } else n.test(c) && \"IMG\" !== b.tagName ? (p = a.color(c), d[e + \"-opacitySetter\"](p.get(\"a\"), e, b), h = p.get(\"rgb\")) : (h = b.getElementsByTagName(e), h.length && (h[0].opacity = 1, h[0].type = \"solid\"), h = c);\n\n        return h;\n      },\n      prepVML: function prepVML(a) {\n        var c = this.isIE8;\n        a = a.join(\"\");\n        c ? (a = a.replace(\"/\\x3e\", ' xmlns\\x3d\"urn:schemas-microsoft-com:vml\" /\\x3e'), a = -1 === a.indexOf('style\\x3d\"') ? a.replace(\"/\\x3e\", ' style\\x3d\"display:inline-block;behavior:url(#default#VML);\" /\\x3e') : a.replace('style\\x3d\"', 'style\\x3d\"display:inline-block;behavior:url(#default#VML);')) : a = a.replace(\"\\x3c\", \"\\x3chcv:\");\n        return a;\n      },\n      text: D.prototype.html,\n      path: function path(a) {\n        var c = {\n          coordsize: \"10 10\"\n        };\n        d(a) ? c.d = a : b(a) && g(c, a);\n        return this.createElement(\"shape\").attr(c);\n      },\n      circle: function circle(a, e, d) {\n        var c = this.symbol(\"circle\");\n        b(a) && (d = a.r, e = a.y, a = a.x);\n        c.isCircle = !0;\n        c.r = d;\n        return c.attr({\n          x: a,\n          y: e\n        });\n      },\n      g: function g(a) {\n        var c;\n        a && (c = {\n          className: \"highcharts-\" + a,\n          \"class\": \"highcharts-\" + a\n        });\n        return this.createElement(\"div\").attr(c);\n      },\n      image: function image(a, b, e, d, n) {\n        var c = this.createElement(\"img\").attr({\n          src: a\n        });\n        1 < arguments.length && c.attr({\n          x: b,\n          y: e,\n          width: d,\n          height: n\n        });\n        return c;\n      },\n      createElement: function createElement(a) {\n        return \"rect\" === a ? this.symbol(a) : D.prototype.createElement.call(this, a);\n      },\n      invertChild: function invertChild(a, b) {\n        var c = this;\n        b = b.style;\n        var e = \"IMG\" === a.tagName && a.style;\n        E(a, {\n          flip: \"x\",\n          left: y(b.width) - (e ? y(e.top) : 1),\n          top: y(b.height) - (e ? y(e.left) : 1),\n          rotation: -90\n        });\n        u(a.childNodes, function (b) {\n          c.invertChild(b, a);\n        });\n      },\n      symbols: {\n        arc: function arc(a, b, e, d, n) {\n          var c = n.start,\n              q = n.end,\n              g = n.r || e || d;\n          e = n.innerR;\n          d = Math.cos(c);\n          var k = Math.sin(c),\n              h = Math.cos(q),\n              w = Math.sin(q);\n          if (0 === q - c) return [\"x\"];\n          c = [\"wa\", a - g, b - g, a + g, b + g, a + g * d, b + g * k, a + g * h, b + g * w];\n          n.open && !e && c.push(\"e\", \"M\", a, b);\n          c.push(\"at\", a - e, b - e, a + e, b + e, a + e * h, b + e * w, a + e * d, b + e * k, \"x\", \"e\");\n          c.isArc = !0;\n          return c;\n        },\n        circle: function circle(a, b, e, d, n) {\n          n && m(n.r) && (e = d = 2 * n.r);\n          n && n.isCircle && (a -= e / 2, b -= d / 2);\n          return [\"wa\", a, b, a + e, b + d, a + e, b + d / 2, a + e, b + d / 2, \"e\"];\n        },\n        rect: function rect(a, b, e, d, n) {\n          return D.prototype.symbols[m(n) && n.r ? \"callout\" : \"square\"].call(0, a, b, e, d, n);\n        }\n      }\n    }, a.VMLRenderer = C = function C() {\n      this.init.apply(this, arguments);\n    }, C.prototype = e(D.prototype, A), a.Renderer = C);\n\n    D.prototype.measureSpanWidth = function (a, b) {\n      var c = r.createElement(\"span\");\n      a = r.createTextNode(a);\n      c.appendChild(a);\n      E(c, b);\n      this.box.appendChild(c);\n      b = c.offsetWidth;\n      l(c);\n      return b;\n    };\n  })(M);\n\n  (function (a) {\n    function C() {\n      var f = a.defaultOptions.global,\n          l = r.moment;\n\n      if (f.timezone) {\n        if (l) return function (a) {\n          return -l.tz(a, f.timezone).utcOffset();\n        };\n        a.error(25);\n      }\n\n      return f.useUTC && f.getTimezoneOffset;\n    }\n\n    function A() {\n      var f = a.defaultOptions.global,\n          t,\n          g = f.useUTC,\n          d = g ? \"getUTC\" : \"get\",\n          k = g ? \"setUTC\" : \"set\";\n      a.Date = t = f.Date || r.Date;\n      t.hcTimezoneOffset = g && f.timezoneOffset;\n      t.hcGetTimezoneOffset = C();\n\n      t.hcMakeTime = function (a, e, d, k, n, f) {\n        var b;\n        g ? (b = t.UTC.apply(0, arguments), b += m(b)) : b = new t(a, e, l(d, 1), l(k, 0), l(n, 0), l(f, 0)).getTime();\n        return b;\n      };\n\n      E(\"Minutes Hours Day Date Month FullYear\".split(\" \"), function (a) {\n        t[\"hcGet\" + a] = d + a;\n      });\n      E(\"Milliseconds Seconds Minutes Hours Date Month FullYear\".split(\" \"), function (a) {\n        t[\"hcSet\" + a] = k + a;\n      });\n    }\n\n    var F = a.color,\n        E = a.each,\n        m = a.getTZOffset,\n        f = a.merge,\n        l = a.pick,\n        r = a.win;\n    a.defaultOptions = {\n      colors: \"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \"),\n      symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n      lang: {\n        loading: \"Loading...\",\n        months: \"January February March April May June July August September October November December\".split(\" \"),\n        shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n        decimalPoint: \".\",\n        numericSymbols: \"kMGTPE\".split(\"\"),\n        resetZoom: \"Reset zoom\",\n        resetZoomTitle: \"Reset zoom level 1:1\",\n        thousandsSep: \" \"\n      },\n      global: {\n        useUTC: !0,\n        VMLRadialGradientURL: \"http://code.highcharts.com/5.0.14/gfx/vml-radial-gradient.png\"\n      },\n      chart: {\n        borderRadius: 0,\n        defaultSeriesType: \"line\",\n        ignoreHiddenSeries: !0,\n        spacing: [10, 10, 15, 10],\n        resetZoomButton: {\n          theme: {\n            zIndex: 20\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        },\n        width: null,\n        height: null,\n        borderColor: \"#335cad\",\n        backgroundColor: \"#ffffff\",\n        plotBorderColor: \"#cccccc\"\n      },\n      title: {\n        text: \"Chart title\",\n        align: \"center\",\n        margin: 15,\n        widthAdjust: -44\n      },\n      subtitle: {\n        text: \"\",\n        align: \"center\",\n        widthAdjust: -44\n      },\n      plotOptions: {},\n      labels: {\n        style: {\n          position: \"absolute\",\n          color: \"#333333\"\n        }\n      },\n      legend: {\n        enabled: !0,\n        align: \"center\",\n        layout: \"horizontal\",\n        labelFormatter: function labelFormatter() {\n          return this.name;\n        },\n        borderColor: \"#999999\",\n        borderRadius: 0,\n        navigation: {\n          activeColor: \"#003399\",\n          inactiveColor: \"#cccccc\"\n        },\n        itemStyle: {\n          color: \"#333333\",\n          fontSize: \"12px\",\n          fontWeight: \"bold\",\n          textOverflow: \"ellipsis\"\n        },\n        itemHoverStyle: {\n          color: \"#000000\"\n        },\n        itemHiddenStyle: {\n          color: \"#cccccc\"\n        },\n        shadow: !1,\n        itemCheckboxStyle: {\n          position: \"absolute\",\n          width: \"13px\",\n          height: \"13px\"\n        },\n        squareSymbol: !0,\n        symbolPadding: 5,\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        title: {\n          style: {\n            fontWeight: \"bold\"\n          }\n        }\n      },\n      loading: {\n        labelStyle: {\n          fontWeight: \"bold\",\n          position: \"relative\",\n          top: \"45%\"\n        },\n        style: {\n          position: \"absolute\",\n          backgroundColor: \"#ffffff\",\n          opacity: .5,\n          textAlign: \"center\"\n        }\n      },\n      tooltip: {\n        enabled: !0,\n        animation: a.svg,\n        borderRadius: 3,\n        dateTimeLabelFormats: {\n          millisecond: \"%A, %b %e, %H:%M:%S.%L\",\n          second: \"%A, %b %e, %H:%M:%S\",\n          minute: \"%A, %b %e, %H:%M\",\n          hour: \"%A, %b %e, %H:%M\",\n          day: \"%A, %b %e, %Y\",\n          week: \"Week from %A, %b %e, %Y\",\n          month: \"%B %Y\",\n          year: \"%Y\"\n        },\n        footerFormat: \"\",\n        padding: 8,\n        snap: a.isTouchDevice ? 25 : 10,\n        backgroundColor: F(\"#f7f7f7\").setOpacity(.85).get(),\n        borderWidth: 1,\n        headerFormat: '\\x3cspan style\\x3d\"font-size: 10px\"\\x3e{point.key}\\x3c/span\\x3e\\x3cbr/\\x3e',\n        pointFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> {series.name}: <b>{point.y}</b><br/>\",\n        shadow: !0,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"12px\",\n          pointerEvents: \"none\",\n          whiteSpace: \"nowrap\"\n        }\n      },\n      credits: {\n        enabled: !0,\n        href: \"http://www.highcharts.com\",\n        position: {\n          align: \"right\",\n          x: -10,\n          verticalAlign: \"bottom\",\n          y: -5\n        },\n        style: {\n          cursor: \"pointer\",\n          color: \"#999999\",\n          fontSize: \"9px\"\n        },\n        text: \"Highcharts.com\"\n      }\n    };\n\n    a.setOptions = function (r) {\n      a.defaultOptions = f(!0, a.defaultOptions, r);\n      A();\n      return a.defaultOptions;\n    };\n\n    a.getOptions = function () {\n      return a.defaultOptions;\n    };\n\n    a.defaultPlotOptions = a.defaultOptions.plotOptions;\n    A();\n  })(M);\n\n  (function (a) {\n    var C = a.correctFloat,\n        A = a.defined,\n        F = a.destroyObjectProperties,\n        E = a.isNumber,\n        m = a.merge,\n        f = a.pick,\n        l = a.deg2rad;\n\n    a.Tick = function (a, f, l, g) {\n      this.axis = a;\n      this.pos = f;\n      this.type = l || \"\";\n      this.isNewLabel = this.isNew = !0;\n      l || g || this.addLabel();\n    };\n\n    a.Tick.prototype = {\n      addLabel: function addLabel() {\n        var a = this.axis,\n            l = a.options,\n            t = a.chart,\n            g = a.categories,\n            d = a.names,\n            k = this.pos,\n            b = l.labels,\n            e = a.tickPositions,\n            v = k === e[0],\n            y = k === e[e.length - 1],\n            d = g ? f(g[k], d[k], k) : k,\n            g = this.label,\n            e = e.info,\n            n;\n        a.isDatetimeAxis && e && (n = l.dateTimeLabelFormats[e.higherRanks[k] || e.unitName]);\n        this.isFirst = v;\n        this.isLast = y;\n        l = a.labelFormatter.call({\n          axis: a,\n          chart: t,\n          isFirst: v,\n          isLast: y,\n          dateTimeLabelFormat: n,\n          value: a.isLog ? C(a.lin2log(d)) : d,\n          pos: k\n        });\n        A(g) ? g && g.attr({\n          text: l\n        }) : (this.labelLength = (this.label = g = A(l) && b.enabled ? t.renderer.text(l, 0, 0, b.useHTML).css(m(b.style)).add(a.labelGroup) : null) && g.getBBox().width, this.rotation = 0);\n      },\n      getLabelSize: function getLabelSize() {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      },\n      handleOverflow: function handleOverflow(a) {\n        var r = this.axis,\n            m = a.x,\n            g = r.chart.chartWidth,\n            d = r.chart.spacing,\n            k = f(r.labelLeft, Math.min(r.pos, d[3])),\n            d = f(r.labelRight, Math.max(r.pos + r.len, g - d[1])),\n            b = this.label,\n            e = this.rotation,\n            v = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[r.labelAlign],\n            y = b.getBBox().width,\n            n = r.getSlotWidth(),\n            D = n,\n            J = 1,\n            c,\n            G = {};\n        if (e) 0 > e && m - v * y < k ? c = Math.round(m / Math.cos(e * l) - k) : 0 < e && m + v * y > d && (c = Math.round((g - m) / Math.cos(e * l)));else if (g = m + (1 - v) * y, m - v * y < k ? D = a.x + D * (1 - v) - k : g > d && (D = d - a.x + D * v, J = -1), D = Math.min(n, D), D < n && \"center\" === r.labelAlign && (a.x += J * (n - D - v * (n - Math.min(y, D)))), y > D || r.autoRotation && (b.styles || {}).width) c = D;\n        c && (G.width = c, (r.options.labels.style || {}).textOverflow || (G.textOverflow = \"ellipsis\"), b.css(G));\n      },\n      getPosition: function getPosition(a, f, l, g) {\n        var d = this.axis,\n            k = d.chart,\n            b = g && k.oldChartHeight || k.chartHeight;\n        return {\n          x: a ? d.translate(f + l, null, null, g) + d.transB : d.left + d.offset + (d.opposite ? (g && k.oldChartWidth || k.chartWidth) - d.right - d.left : 0),\n          y: a ? b - d.bottom + d.offset - (d.opposite ? d.height : 0) : b - d.translate(f + l, null, null, g) - d.transB\n        };\n      },\n      getLabelPosition: function getLabelPosition(a, f, m, g, d, k, b, e) {\n        var v = this.axis,\n            y = v.transA,\n            n = v.reversed,\n            D = v.staggerLines,\n            r = v.tickRotCorr || {\n          x: 0,\n          y: 0\n        },\n            c = d.y;\n        A(c) || (c = 0 === v.side ? m.rotation ? -8 : -m.getBBox().height : 2 === v.side ? r.y + 8 : Math.cos(m.rotation * l) * (r.y - m.getBBox(!1, 0).height / 2));\n        a = a + d.x + r.x - (k && g ? k * y * (n ? -1 : 1) : 0);\n        f = f + c - (k && !g ? k * y * (n ? 1 : -1) : 0);\n        D && (m = b / (e || 1) % D, v.opposite && (m = D - m - 1), f += v.labelOffset / D * m);\n        return {\n          x: a,\n          y: Math.round(f)\n        };\n      },\n      getMarkPath: function getMarkPath(a, f, l, g, d, k) {\n        return k.crispLine([\"M\", a, f, \"L\", a + (d ? 0 : -l), f + (d ? l : 0)], g);\n      },\n      renderGridLine: function renderGridLine(a, f, l) {\n        var g = this.axis,\n            d = g.options,\n            k = this.gridLine,\n            b = {},\n            e = this.pos,\n            v = this.type,\n            y = g.tickmarkOffset,\n            n = g.chart.renderer,\n            D = v ? v + \"Grid\" : \"grid\",\n            r = d[D + \"LineWidth\"],\n            c = d[D + \"LineColor\"],\n            d = d[D + \"LineDashStyle\"];\n        k || (b.stroke = c, b[\"stroke-width\"] = r, d && (b.dashstyle = d), v || (b.zIndex = 1), a && (b.opacity = 0), this.gridLine = k = n.path().attr(b).addClass(\"highcharts-\" + (v ? v + \"-\" : \"\") + \"grid-line\").add(g.gridGroup));\n        if (!a && k && (a = g.getPlotLinePath(e + y, k.strokeWidth() * l, a, !0))) k[this.isNew ? \"attr\" : \"animate\"]({\n          d: a,\n          opacity: f\n        });\n      },\n      renderMark: function renderMark(a, l, m) {\n        var g = this.axis,\n            d = g.options,\n            k = g.chart.renderer,\n            b = this.type,\n            e = b ? b + \"Tick\" : \"tick\",\n            v = g.tickSize(e),\n            y = this.mark,\n            n = !y,\n            D = a.x;\n        a = a.y;\n        var r = f(d[e + \"Width\"], !b && g.isXAxis ? 1 : 0),\n            d = d[e + \"Color\"];\n        v && (g.opposite && (v[0] = -v[0]), n && (this.mark = y = k.path().addClass(\"highcharts-\" + (b ? b + \"-\" : \"\") + \"tick\").add(g.axisGroup), y.attr({\n          stroke: d,\n          \"stroke-width\": r\n        })), y[n ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(D, a, v[0], y.strokeWidth() * m, g.horiz, k),\n          opacity: l\n        }));\n      },\n      renderLabel: function renderLabel(a, l, m, g) {\n        var d = this.axis,\n            k = d.horiz,\n            b = d.options,\n            e = this.label,\n            v = b.labels,\n            y = v.step,\n            n = d.tickmarkOffset,\n            D = !0,\n            r = a.x;\n        a = a.y;\n        e && E(r) && (e.xy = a = this.getLabelPosition(r, a, e, k, v, n, g, y), this.isFirst && !this.isLast && !f(b.showFirstLabel, 1) || this.isLast && !this.isFirst && !f(b.showLastLabel, 1) ? D = !1 : !k || d.isRadial || v.step || v.rotation || l || 0 === m || this.handleOverflow(a), y && g % y && (D = !1), D && E(a.y) ? (a.opacity = m, e[this.isNewLabel ? \"attr\" : \"animate\"](a), this.isNewLabel = !1) : (e.attr(\"y\", -9999), this.isNewLabel = !0), this.isNew = !1);\n      },\n      render: function render(a, l, m) {\n        var g = this.axis,\n            d = g.horiz,\n            k = this.getPosition(d, this.pos, g.tickmarkOffset, l),\n            b = k.x,\n            e = k.y,\n            g = d && b === g.pos + g.len || !d && e === g.pos ? -1 : 1;\n        m = f(m, 1);\n        this.isActive = !0;\n        this.renderGridLine(l, m, g);\n        this.renderMark(k, m, g);\n        this.renderLabel(k, l, m, a);\n      },\n      destroy: function destroy() {\n        F(this, this.axis);\n      }\n    };\n  })(M);\n\n  var S = function (a) {\n    var C = a.addEvent,\n        A = a.animObject,\n        F = a.arrayMax,\n        E = a.arrayMin,\n        m = a.color,\n        f = a.correctFloat,\n        l = a.defaultOptions,\n        r = a.defined,\n        u = a.deg2rad,\n        t = a.destroyObjectProperties,\n        g = a.each,\n        d = a.extend,\n        k = a.fireEvent,\n        b = a.format,\n        e = a.getMagnitude,\n        v = a.grep,\n        y = a.inArray,\n        n = a.isArray,\n        D = a.isNumber,\n        J = a.isString,\n        c = a.merge,\n        G = a.normalizeTickInterval,\n        q = a.objectEach,\n        B = a.pick,\n        K = a.removeEvent,\n        p = a.splat,\n        z = a.syncTimeout,\n        I = a.Tick,\n        L = function L() {\n      this.init.apply(this, arguments);\n    };\n\n    a.extend(L.prototype, {\n      defaultOptions: {\n        dateTimeLabelFormats: {\n          millisecond: \"%H:%M:%S.%L\",\n          second: \"%H:%M:%S\",\n          minute: \"%H:%M\",\n          hour: \"%H:%M\",\n          day: \"%e. %b\",\n          week: \"%e. %b\",\n          month: \"%b '%y\",\n          year: \"%Y\"\n        },\n        endOnTick: !1,\n        labels: {\n          enabled: !0,\n          style: {\n            color: \"#666666\",\n            cursor: \"default\",\n            fontSize: \"11px\"\n          },\n          x: 0\n        },\n        minPadding: .01,\n        maxPadding: .01,\n        minorTickLength: 2,\n        minorTickPosition: \"outside\",\n        startOfWeek: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickmarkPlacement: \"between\",\n        tickPixelInterval: 100,\n        tickPosition: \"outside\",\n        title: {\n          align: \"middle\",\n          style: {\n            color: \"#666666\"\n          }\n        },\n        type: \"linear\",\n        minorGridLineColor: \"#f2f2f2\",\n        minorGridLineWidth: 1,\n        minorTickColor: \"#999999\",\n        lineColor: \"#ccd6eb\",\n        lineWidth: 1,\n        gridLineColor: \"#e6e6e6\",\n        tickColor: \"#ccd6eb\"\n      },\n      defaultYAxisOptions: {\n        endOnTick: !0,\n        tickPixelInterval: 72,\n        showLastLabel: !0,\n        labels: {\n          x: -8\n        },\n        maxPadding: .05,\n        minPadding: .05,\n        startOnTick: !0,\n        title: {\n          rotation: 270,\n          text: \"Values\"\n        },\n        stackLabels: {\n          allowOverlap: !1,\n          enabled: !1,\n          formatter: function formatter() {\n            return a.numberFormat(this.total, -1);\n          },\n          style: {\n            fontSize: \"11px\",\n            fontWeight: \"bold\",\n            color: \"#000000\",\n            textOutline: \"1px contrast\"\n          }\n        },\n        gridLineWidth: 1,\n        lineWidth: 0\n      },\n      defaultLeftAxisOptions: {\n        labels: {\n          x: -15\n        },\n        title: {\n          rotation: 270\n        }\n      },\n      defaultRightAxisOptions: {\n        labels: {\n          x: 15\n        },\n        title: {\n          rotation: 90\n        }\n      },\n      defaultBottomAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        title: {\n          rotation: 0\n        }\n      },\n      defaultTopAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        title: {\n          rotation: 0\n        }\n      },\n      init: function init(a, c) {\n        var h = c.isX,\n            b = this;\n        b.chart = a;\n        b.horiz = a.inverted && !b.isZAxis ? !h : h;\n        b.isXAxis = h;\n        b.coll = b.coll || (h ? \"xAxis\" : \"yAxis\");\n        b.opposite = c.opposite;\n        b.side = c.side || (b.horiz ? b.opposite ? 0 : 2 : b.opposite ? 1 : 3);\n        b.setOptions(c);\n        var w = this.options,\n            e = w.type;\n        b.labelFormatter = w.labels.formatter || b.defaultLabelFormatter;\n        b.userOptions = c;\n        b.minPixelPadding = 0;\n        b.reversed = w.reversed;\n        b.visible = !1 !== w.visible;\n        b.zoomEnabled = !1 !== w.zoomEnabled;\n        b.hasNames = \"category\" === e || !0 === w.categories;\n        b.categories = w.categories || b.hasNames;\n        b.names = b.names || [];\n        b.plotLinesAndBandsGroups = {};\n        b.isLog = \"logarithmic\" === e;\n        b.isDatetimeAxis = \"datetime\" === e;\n        b.positiveValuesOnly = b.isLog && !b.allowNegativeLog;\n        b.isLinked = r(w.linkedTo);\n        b.ticks = {};\n        b.labelEdge = [];\n        b.minorTicks = {};\n        b.plotLinesAndBands = [];\n        b.alternateBands = {};\n        b.len = 0;\n        b.minRange = b.userMinRange = w.minRange || w.maxZoom;\n        b.range = w.range;\n        b.offset = w.offset || 0;\n        b.stacks = {};\n        b.oldStacks = {};\n        b.stacksTouched = 0;\n        b.max = null;\n        b.min = null;\n        b.crosshair = B(w.crosshair, p(a.options.tooltip.crosshairs)[h ? 0 : 1], !1);\n        c = b.options.events;\n        -1 === y(b, a.axes) && (h ? a.axes.splice(a.xAxis.length, 0, b) : a.axes.push(b), a[b.coll].push(b));\n        b.series = b.series || [];\n        a.inverted && !b.isZAxis && h && void 0 === b.reversed && (b.reversed = !0);\n        q(c, function (a, h) {\n          C(b, h, a);\n        });\n        b.lin2log = w.linearToLogConverter || b.lin2log;\n        b.isLog && (b.val2lin = b.log2lin, b.lin2val = b.lin2log);\n      },\n      setOptions: function setOptions(a) {\n        this.options = c(this.defaultOptions, \"yAxis\" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], c(l[this.coll], a));\n      },\n      defaultLabelFormatter: function defaultLabelFormatter() {\n        var h = this.axis,\n            c = this.value,\n            e = h.categories,\n            p = this.dateTimeLabelFormat,\n            d = l.lang,\n            n = d.numericSymbols,\n            d = d.numericSymbolMagnitude || 1E3,\n            q = n && n.length,\n            x,\n            g = h.options.labels.format,\n            h = h.isLog ? Math.abs(c) : h.tickInterval;\n        if (g) x = b(g, this);else if (e) x = c;else if (p) x = a.dateFormat(p, c);else if (q && 1E3 <= h) for (; q-- && void 0 === x;) {\n          e = Math.pow(d, q + 1), h >= e && 0 === 10 * c % e && null !== n[q] && 0 !== c && (x = a.numberFormat(c / e, -1) + n[q]);\n        }\n        void 0 === x && (x = 1E4 <= Math.abs(c) ? a.numberFormat(c, -1) : a.numberFormat(c, -1, void 0, \"\"));\n        return x;\n      },\n      getSeriesExtremes: function getSeriesExtremes() {\n        var a = this,\n            b = a.chart;\n        a.hasVisibleSeries = !1;\n        a.dataMin = a.dataMax = a.threshold = null;\n        a.softThreshold = !a.isXAxis;\n        a.buildStacks && a.buildStacks();\n        g(a.series, function (h) {\n          if (h.visible || !b.options.chart.ignoreHiddenSeries) {\n            var c = h.options,\n                w = c.threshold,\n                e;\n            a.hasVisibleSeries = !0;\n            a.positiveValuesOnly && 0 >= w && (w = null);\n            if (a.isXAxis) c = h.xData, c.length && (h = E(c), D(h) || h instanceof Date || (c = v(c, function (a) {\n              return D(a);\n            }), h = E(c)), a.dataMin = Math.min(B(a.dataMin, c[0]), h), a.dataMax = Math.max(B(a.dataMax, c[0]), F(c)));else if (h.getExtremes(), e = h.dataMax, h = h.dataMin, r(h) && r(e) && (a.dataMin = Math.min(B(a.dataMin, h), h), a.dataMax = Math.max(B(a.dataMax, e), e)), r(w) && (a.threshold = w), !c.softThreshold || a.positiveValuesOnly) a.softThreshold = !1;\n          }\n        });\n      },\n      translate: function translate(a, b, c, e, p, d) {\n        var h = this.linkedParent || this,\n            w = 1,\n            n = 0,\n            q = e ? h.oldTransA : h.transA;\n        e = e ? h.oldMin : h.min;\n        var g = h.minPixelPadding;\n        p = (h.isOrdinal || h.isBroken || h.isLog && p) && h.lin2val;\n        q || (q = h.transA);\n        c && (w *= -1, n = h.len);\n        h.reversed && (w *= -1, n -= w * (h.sector || h.len));\n        b ? (a = (a * w + n - g) / q + e, p && (a = h.lin2val(a))) : (p && (a = h.val2lin(a)), a = w * (a - e) * q + n + w * g + (D(d) ? q * d : 0));\n        return a;\n      },\n      toPixels: function toPixels(a, b) {\n        return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);\n      },\n      toValue: function toValue(a, b) {\n        return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);\n      },\n      getPlotLinePath: function getPlotLinePath(a, b, c, e, p) {\n        var h = this.chart,\n            w = this.left,\n            d = this.top,\n            n,\n            q,\n            g = c && h.oldChartHeight || h.chartHeight,\n            k = c && h.oldChartWidth || h.chartWidth,\n            f;\n        n = this.transB;\n\n        var v = function v(a, h, b) {\n          if (a < h || a > b) e ? a = Math.min(Math.max(h, a), b) : f = !0;\n          return a;\n        };\n\n        p = B(p, this.translate(a, null, null, c));\n        a = c = Math.round(p + n);\n        n = q = Math.round(g - p - n);\n        D(p) ? this.horiz ? (n = d, q = g - this.bottom, a = c = v(a, w, w + this.width)) : (a = w, c = k - this.right, n = q = v(n, d, d + this.height)) : f = !0;\n        return f && !e ? null : h.renderer.crispLine([\"M\", a, n, \"L\", c, q], b || 1);\n      },\n      getLinearTickPositions: function getLinearTickPositions(a, b, c) {\n        var h,\n            w = f(Math.floor(b / a) * a);\n        c = f(Math.ceil(c / a) * a);\n        var e = [];\n        if (this.single) return [b];\n\n        for (b = w; b <= c;) {\n          e.push(b);\n          b = f(b + a);\n          if (b === h) break;\n          h = b;\n        }\n\n        return e;\n      },\n      getMinorTickPositions: function getMinorTickPositions() {\n        var a = this,\n            b = a.options,\n            c = a.tickPositions,\n            e = a.minorTickInterval,\n            p = [],\n            d = a.pointRangePadding || 0,\n            n = a.min - d,\n            d = a.max + d,\n            q = d - n;\n        if (q && q / e < a.len / 3) if (a.isLog) g(this.paddedTicks, function (h, b, c) {\n          b && p.push.apply(p, a.getLogTickPositions(e, c[b - 1], c[b], !0));\n        });else if (a.isDatetimeAxis && \"auto\" === b.minorTickInterval) p = p.concat(a.getTimeTicks(a.normalizeTimeTickInterval(e), n, d, b.startOfWeek));else for (b = n + (c[0] - n) % e; b <= d && b !== p[0]; b += e) {\n          p.push(b);\n        }\n        0 !== p.length && a.trimTicks(p);\n        return p;\n      },\n      adjustForMinRange: function adjustForMinRange() {\n        var a = this.options,\n            b = this.min,\n            c = this.max,\n            e,\n            p,\n            d,\n            n,\n            q,\n            k,\n            f,\n            v;\n        this.isXAxis && void 0 === this.minRange && !this.isLog && (r(a.min) || r(a.max) ? this.minRange = null : (g(this.series, function (a) {\n          k = a.xData;\n\n          for (n = f = a.xIncrement ? 1 : k.length - 1; 0 < n; n--) {\n            if (q = k[n] - k[n - 1], void 0 === d || q < d) d = q;\n          }\n        }), this.minRange = Math.min(5 * d, this.dataMax - this.dataMin)));\n        c - b < this.minRange && (p = this.dataMax - this.dataMin >= this.minRange, v = this.minRange, e = (v - c + b) / 2, e = [b - e, B(a.min, b - e)], p && (e[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin), b = F(e), c = [b + v, B(a.max, b + v)], p && (c[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax), c = E(c), c - b < v && (e[0] = c - v, e[1] = B(a.min, c - v), b = F(e)));\n        this.min = b;\n        this.max = c;\n      },\n      getClosest: function getClosest() {\n        var a;\n        this.categories ? a = 1 : g(this.series, function (h) {\n          var b = h.closestPointRange,\n              c = h.visible || !h.chart.options.chart.ignoreHiddenSeries;\n          !h.noSharedTooltip && r(b) && c && (a = r(a) ? Math.min(a, b) : b);\n        });\n        return a;\n      },\n      nameToX: function nameToX(a) {\n        var h = n(this.categories),\n            b = h ? this.categories : this.names,\n            c = a.options.x,\n            e;\n        a.series.requireSorting = !1;\n        r(c) || (c = !1 === this.options.uniqueNames ? a.series.autoIncrement() : y(a.name, b));\n        -1 === c ? h || (e = b.length) : e = c;\n        void 0 !== e && (this.names[e] = a.name);\n        return e;\n      },\n      updateNames: function updateNames() {\n        var a = this;\n        0 < this.names.length && (this.names.length = 0, this.minRange = this.userMinRange, g(this.series || [], function (h) {\n          h.xIncrement = null;\n          if (!h.points || h.isDirtyData) h.processData(), h.generatePoints();\n          g(h.points, function (b, c) {\n            var e;\n            b.options && (e = a.nameToX(b), void 0 !== e && e !== b.x && (b.x = e, h.xData[c] = e));\n          });\n        }));\n      },\n      setAxisTranslation: function setAxisTranslation(a) {\n        var h = this,\n            b = h.max - h.min,\n            c = h.axisPointRange || 0,\n            e,\n            p = 0,\n            d = 0,\n            n = h.linkedParent,\n            q = !!h.categories,\n            k = h.transA,\n            f = h.isXAxis;\n        if (f || q || c) e = h.getClosest(), n ? (p = n.minPointOffset, d = n.pointRangePadding) : g(h.series, function (a) {\n          var b = q ? 1 : f ? B(a.options.pointRange, e, 0) : h.axisPointRange || 0;\n          a = a.options.pointPlacement;\n          c = Math.max(c, b);\n          h.single || (p = Math.max(p, J(a) ? 0 : b / 2), d = Math.max(d, \"on\" === a ? 0 : b));\n        }), n = h.ordinalSlope && e ? h.ordinalSlope / e : 1, h.minPointOffset = p *= n, h.pointRangePadding = d *= n, h.pointRange = Math.min(c, b), f && (h.closestPointRange = e);\n        a && (h.oldTransA = k);\n        h.translationSlope = h.transA = k = h.options.staticScale || h.len / (b + d || 1);\n        h.transB = h.horiz ? h.left : h.bottom;\n        h.minPixelPadding = k * p;\n      },\n      minFromRange: function minFromRange() {\n        return this.max - this.range;\n      },\n      setTickInterval: function setTickInterval(h) {\n        var b = this,\n            c = b.chart,\n            p = b.options,\n            d = b.isLog,\n            n = b.log2lin,\n            q = b.isDatetimeAxis,\n            x = b.isXAxis,\n            v = b.isLinked,\n            z = p.maxPadding,\n            y = p.minPadding,\n            l = p.tickInterval,\n            I = p.tickPixelInterval,\n            m = b.categories,\n            J = b.threshold,\n            t = b.softThreshold,\n            L,\n            u,\n            K,\n            A;\n        q || m || v || this.getTickAmount();\n        K = B(b.userMin, p.min);\n        A = B(b.userMax, p.max);\n        v ? (b.linkedParent = c[b.coll][p.linkedTo], c = b.linkedParent.getExtremes(), b.min = B(c.min, c.dataMin), b.max = B(c.max, c.dataMax), p.type !== b.linkedParent.options.type && a.error(11, 1)) : (!t && r(J) && (b.dataMin >= J ? (L = J, y = 0) : b.dataMax <= J && (u = J, z = 0)), b.min = B(K, L, b.dataMin), b.max = B(A, u, b.dataMax));\n        d && (b.positiveValuesOnly && !h && 0 >= Math.min(b.min, B(b.dataMin, b.min)) && a.error(10, 1), b.min = f(n(b.min), 15), b.max = f(n(b.max), 15));\n        b.range && r(b.max) && (b.userMin = b.min = K = Math.max(b.dataMin, b.minFromRange()), b.userMax = A = b.max, b.range = null);\n        k(b, \"foundExtremes\");\n        b.beforePadding && b.beforePadding();\n        b.adjustForMinRange();\n        !(m || b.axisPointRange || b.usePercentage || v) && r(b.min) && r(b.max) && (n = b.max - b.min) && (!r(K) && y && (b.min -= n * y), !r(A) && z && (b.max += n * z));\n        D(p.softMin) && (b.min = Math.min(b.min, p.softMin));\n        D(p.softMax) && (b.max = Math.max(b.max, p.softMax));\n        D(p.floor) && (b.min = Math.max(b.min, p.floor));\n        D(p.ceiling) && (b.max = Math.min(b.max, p.ceiling));\n        t && r(b.dataMin) && (J = J || 0, !r(K) && b.min < J && b.dataMin >= J ? b.min = J : !r(A) && b.max > J && b.dataMax <= J && (b.max = J));\n        b.tickInterval = b.min === b.max || void 0 === b.min || void 0 === b.max ? 1 : v && !l && I === b.linkedParent.options.tickPixelInterval ? l = b.linkedParent.tickInterval : B(l, this.tickAmount ? (b.max - b.min) / Math.max(this.tickAmount - 1, 1) : void 0, m ? 1 : (b.max - b.min) * I / Math.max(b.len, I));\n        x && !h && g(b.series, function (a) {\n          a.processData(b.min !== b.oldMin || b.max !== b.oldMax);\n        });\n        b.setAxisTranslation(!0);\n        b.beforeSetTickPositions && b.beforeSetTickPositions();\n        b.postProcessTickInterval && (b.tickInterval = b.postProcessTickInterval(b.tickInterval));\n        b.pointRange && !l && (b.tickInterval = Math.max(b.pointRange, b.tickInterval));\n        h = B(p.minTickInterval, b.isDatetimeAxis && b.closestPointRange);\n        !l && b.tickInterval < h && (b.tickInterval = h);\n        q || d || l || (b.tickInterval = G(b.tickInterval, null, e(b.tickInterval), B(p.allowDecimals, !(.5 < b.tickInterval && 5 > b.tickInterval && 1E3 < b.max && 9999 > b.max)), !!this.tickAmount));\n        this.tickAmount || (b.tickInterval = b.unsquish());\n        this.setTickPositions();\n      },\n      setTickPositions: function setTickPositions() {\n        var a = this.options,\n            b,\n            c = a.tickPositions,\n            e = a.tickPositioner,\n            p = a.startOnTick,\n            d = a.endOnTick;\n        this.tickmarkOffset = this.categories && \"between\" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === a.minorTickInterval && this.tickInterval ? this.tickInterval / 5 : a.minorTickInterval;\n        this.single = this.min === this.max && r(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== a.allowDecimals);\n        this.tickPositions = b = c && c.slice();\n        !b && (b = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), b.length > this.len && (b = [b[0], b.pop()]), this.tickPositions = b, e && (e = e.apply(this, [this.min, this.max]))) && (this.tickPositions = b = e);\n        this.paddedTicks = b.slice(0);\n        this.trimTicks(b, p, d);\n        this.isLinked || (this.single && 2 > b.length && (this.min -= .5, this.max += .5), c || e || this.adjustTickAmount());\n      },\n      trimTicks: function trimTicks(a, b, c) {\n        var h = a[0],\n            e = a[a.length - 1],\n            p = this.minPointOffset || 0;\n\n        if (!this.isLinked) {\n          if (b && -Infinity !== h) this.min = h;else for (; this.min - p > a[0];) {\n            a.shift();\n          }\n          if (c) this.max = e;else for (; this.max + p < a[a.length - 1];) {\n            a.pop();\n          }\n          0 === a.length && r(h) && a.push((e + h) / 2);\n        }\n      },\n      alignToOthers: function alignToOthers() {\n        var a = {},\n            b,\n            c = this.options;\n        !1 === this.chart.options.chart.alignTicks || !1 === c.alignTicks || this.isLog || g(this.chart[this.coll], function (h) {\n          var c = h.options,\n              c = [h.horiz ? c.left : c.top, c.width, c.height, c.pane].join();\n          h.series.length && (a[c] ? b = !0 : a[c] = 1);\n        });\n        return b;\n      },\n      getTickAmount: function getTickAmount() {\n        var a = this.options,\n            b = a.tickAmount,\n            c = a.tickPixelInterval;\n        !r(a.tickInterval) && this.len < c && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (b = 2);\n        !b && this.alignToOthers() && (b = Math.ceil(this.len / c) + 1);\n        4 > b && (this.finalTickAmt = b, b = 5);\n        this.tickAmount = b;\n      },\n      adjustTickAmount: function adjustTickAmount() {\n        var a = this.tickInterval,\n            b = this.tickPositions,\n            c = this.tickAmount,\n            e = this.finalTickAmt,\n            p = b && b.length;\n\n        if (p < c) {\n          for (; b.length < c;) {\n            b.push(f(b[b.length - 1] + a));\n          }\n\n          this.transA *= (p - 1) / (c - 1);\n          this.max = b[b.length - 1];\n        } else p > c && (this.tickInterval *= 2, this.setTickPositions());\n\n        if (r(e)) {\n          for (a = c = b.length; a--;) {\n            (3 === e && 1 === a % 2 || 2 >= e && 0 < a && a < c - 1) && b.splice(a, 1);\n          }\n\n          this.finalTickAmt = void 0;\n        }\n      },\n      setScale: function setScale() {\n        var a, b;\n        this.oldMin = this.min;\n        this.oldMax = this.max;\n        this.oldAxisLength = this.len;\n        this.setAxisSize();\n        b = this.len !== this.oldAxisLength;\n        g(this.series, function (b) {\n          if (b.isDirtyData || b.isDirty || b.xAxis.isDirty) a = !0;\n        });\n        b || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();\n      },\n      setExtremes: function setExtremes(a, b, c, e, p) {\n        var h = this,\n            n = h.chart;\n        c = B(c, !0);\n        g(h.series, function (a) {\n          delete a.kdTree;\n        });\n        p = d(p, {\n          min: a,\n          max: b\n        });\n        k(h, \"setExtremes\", p, function () {\n          h.userMin = a;\n          h.userMax = b;\n          h.eventArgs = p;\n          c && n.redraw(e);\n        });\n      },\n      zoom: function zoom(a, b) {\n        var h = this.dataMin,\n            c = this.dataMax,\n            e = this.options,\n            p = Math.min(h, B(e.min, h)),\n            e = Math.max(c, B(e.max, c));\n        if (a !== this.min || b !== this.max) this.allowZoomOutside || (r(h) && (a < p && (a = p), a > e && (a = e)), r(c) && (b < p && (b = p), b > e && (b = e))), this.displayBtn = void 0 !== a || void 0 !== b, this.setExtremes(a, b, !1, void 0, {\n          trigger: \"zoom\"\n        });\n        return !0;\n      },\n      setAxisSize: function setAxisSize() {\n        var b = this.chart,\n            c = this.options,\n            e = c.offsets || [0, 0, 0, 0],\n            p = this.horiz,\n            d = this.width = Math.round(a.relativeLength(B(c.width, b.plotWidth - e[3] + e[1]), b.plotWidth)),\n            n = this.height = Math.round(a.relativeLength(B(c.height, b.plotHeight - e[0] + e[2]), b.plotHeight)),\n            q = this.top = Math.round(a.relativeLength(B(c.top, b.plotTop + e[0]), b.plotHeight, b.plotTop)),\n            c = this.left = Math.round(a.relativeLength(B(c.left, b.plotLeft + e[3]), b.plotWidth, b.plotLeft));\n        this.bottom = b.chartHeight - n - q;\n        this.right = b.chartWidth - d - c;\n        this.len = Math.max(p ? d : n, 0);\n        this.pos = p ? c : q;\n      },\n      getExtremes: function getExtremes() {\n        var a = this.isLog,\n            b = this.lin2log;\n        return {\n          min: a ? f(b(this.min)) : this.min,\n          max: a ? f(b(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      },\n      getThreshold: function getThreshold(a) {\n        var b = this.isLog,\n            h = this.lin2log,\n            c = b ? h(this.min) : this.min,\n            b = b ? h(this.max) : this.max;\n        null === a ? a = c : c > a ? a = c : b < a && (a = b);\n        return this.translate(a, 0, 1, 0, 1);\n      },\n      autoLabelAlign: function autoLabelAlign(a) {\n        a = (B(a, 0) - 90 * this.side + 720) % 360;\n        return 15 < a && 165 > a ? \"right\" : 195 < a && 345 > a ? \"left\" : \"center\";\n      },\n      tickSize: function tickSize(a) {\n        var b = this.options,\n            h = b[a + \"Length\"],\n            c = B(b[a + \"Width\"], \"tick\" === a && this.isXAxis ? 1 : 0);\n        if (c && h) return \"inside\" === b[a + \"Position\"] && (h = -h), [h, c];\n      },\n      labelMetrics: function labelMetrics() {\n        var a = this.tickPositions && this.tickPositions[0] || 0;\n        return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);\n      },\n      unsquish: function unsquish() {\n        var a = this.options.labels,\n            b = this.horiz,\n            c = this.tickInterval,\n            e = c,\n            p = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / c),\n            d,\n            n = a.rotation,\n            q = this.labelMetrics(),\n            k,\n            f = Number.MAX_VALUE,\n            v,\n            z = function z(a) {\n          a /= p || 1;\n          a = 1 < a ? Math.ceil(a) : 1;\n          return a * c;\n        };\n\n        b ? (v = !a.staggerLines && !a.step && (r(n) ? [n] : p < B(a.autoRotationLimit, 80) && a.autoRotation)) && g(v, function (a) {\n          var b;\n          if (a === n || a && -90 <= a && 90 >= a) k = z(Math.abs(q.h / Math.sin(u * a))), b = k + Math.abs(a / 360), b < f && (f = b, d = a, e = k);\n        }) : a.step || (e = z(q.h));\n        this.autoRotation = v;\n        this.labelRotation = B(d, n);\n        return e;\n      },\n      getSlotWidth: function getSlotWidth() {\n        var a = this.chart,\n            b = this.horiz,\n            c = this.options.labels,\n            e = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            p = a.margin[3];\n        return b && 2 > (c.step || 0) && !c.rotation && (this.staggerLines || 1) * this.len / e || !b && (p && p - a.spacing[3] || .33 * a.chartWidth);\n      },\n      renderUnsquish: function renderUnsquish() {\n        var a = this.chart,\n            b = a.renderer,\n            e = this.tickPositions,\n            p = this.ticks,\n            d = this.options.labels,\n            n = this.horiz,\n            q = this.getSlotWidth(),\n            k = Math.max(1, Math.round(q - 2 * (d.padding || 5))),\n            f = {},\n            v = this.labelMetrics(),\n            z = d.style && d.style.textOverflow,\n            D,\n            y = 0,\n            l,\n            I;\n        J(d.rotation) || (f.rotation = d.rotation || 0);\n        g(e, function (a) {\n          (a = p[a]) && a.labelLength > y && (y = a.labelLength);\n        });\n        this.maxLabelLength = y;\n        if (this.autoRotation) y > k && y > v.h ? f.rotation = this.labelRotation : this.labelRotation = 0;else if (q && (D = {\n          width: k + \"px\"\n        }, !z)) for (D.textOverflow = \"clip\", l = e.length; !n && l--;) {\n          if (I = e[l], k = p[I].label) k.styles && \"ellipsis\" === k.styles.textOverflow ? k.css({\n            textOverflow: \"clip\"\n          }) : p[I].labelLength > q && k.css({\n            width: q + \"px\"\n          }), k.getBBox().height > this.len / e.length - (v.h - v.f) && (k.specCss = {\n            textOverflow: \"ellipsis\"\n          });\n        }\n        f.rotation && (D = {\n          width: (y > .5 * a.chartHeight ? .33 * a.chartHeight : a.chartHeight) + \"px\"\n        }, z || (D.textOverflow = \"ellipsis\"));\n        if (this.labelAlign = d.align || this.autoLabelAlign(this.labelRotation)) f.align = this.labelAlign;\n        g(e, function (a) {\n          var b = (a = p[a]) && a.label;\n          b && (b.attr(f), D && b.css(c(D, b.specCss)), delete b.specCss, a.rotation = f.rotation);\n        });\n        this.tickRotCorr = b.rotCorr(v.b, this.labelRotation || 0, 0 !== this.side);\n      },\n      hasData: function hasData() {\n        return this.hasVisibleSeries || r(this.min) && r(this.max) && !!this.tickPositions;\n      },\n      addTitle: function addTitle(a) {\n        var b = this.chart.renderer,\n            c = this.horiz,\n            h = this.opposite,\n            e = this.options.title,\n            p;\n        this.axisTitle || ((p = e.textAlign) || (p = (c ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: h ? \"right\" : \"left\",\n          middle: \"center\",\n          high: h ? \"left\" : \"right\"\n        })[e.align]), this.axisTitle = b.text(e.text, 0, 0, e.useHTML).attr({\n          zIndex: 7,\n          rotation: e.rotation || 0,\n          align: p\n        }).addClass(\"highcharts-axis-title\").css(e.style).add(this.axisGroup), this.axisTitle.isNew = !0);\n        e.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len\n        });\n        this.axisTitle[a ? \"show\" : \"hide\"](!0);\n      },\n      generateTick: function generateTick(a) {\n        var b = this.ticks;\n        b[a] ? b[a].addLabel() : b[a] = new I(this, a);\n      },\n      getOffset: function getOffset() {\n        var a = this,\n            b = a.chart,\n            c = b.renderer,\n            e = a.options,\n            p = a.tickPositions,\n            d = a.ticks,\n            n = a.horiz,\n            k = a.side,\n            f = b.inverted && !a.isZAxis ? [1, 0, 3, 2][k] : k,\n            v,\n            z,\n            D = 0,\n            y,\n            l = 0,\n            I = e.title,\n            m = e.labels,\n            G = 0,\n            J = b.axisOffset,\n            b = b.clipOffset,\n            t = [-1, 1, 1, -1][k],\n            L = e.className,\n            u = a.axisParent,\n            K = this.tickSize(\"tick\");\n        v = a.hasData();\n        a.showAxis = z = v || B(e.showEmpty, !0);\n        a.staggerLines = a.horiz && m.staggerLines;\n        a.axisGroup || (a.gridGroup = c.g(\"grid\").attr({\n          zIndex: e.gridZIndex || 1\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \"-grid \" + (L || \"\")).add(u), a.axisGroup = c.g(\"axis\").attr({\n          zIndex: e.zIndex || 2\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \" \" + (L || \"\")).add(u), a.labelGroup = c.g(\"axis-labels\").attr({\n          zIndex: m.zIndex || 7\n        }).addClass(\"highcharts-\" + a.coll.toLowerCase() + \"-labels \" + (L || \"\")).add(u));\n        v || a.isLinked ? (g(p, function (b, c) {\n          a.generateTick(b, c);\n        }), a.renderUnsquish(), !1 === m.reserveSpace || 0 !== k && 2 !== k && {\n          1: \"left\",\n          3: \"right\"\n        }[k] !== a.labelAlign && \"center\" !== a.labelAlign || g(p, function (a) {\n          G = Math.max(d[a].getLabelSize(), G);\n        }), a.staggerLines && (G *= a.staggerLines, a.labelOffset = G * (a.opposite ? -1 : 1))) : q(d, function (a, b) {\n          a.destroy();\n          delete d[b];\n        });\n        I && I.text && !1 !== I.enabled && (a.addTitle(z), z && !1 !== I.reserveSpace && (a.titleOffset = D = a.axisTitle.getBBox()[n ? \"height\" : \"width\"], y = I.offset, l = r(y) ? 0 : B(I.margin, n ? 5 : 10)));\n        a.renderLine();\n        a.offset = t * B(e.offset, J[k]);\n        a.tickRotCorr = a.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        c = 0 === k ? -a.labelMetrics().h : 2 === k ? a.tickRotCorr.y : 0;\n        l = Math.abs(G) + l;\n        G && (l = l - c + t * (n ? B(m.y, a.tickRotCorr.y + 8 * t) : m.x));\n        a.axisTitleMargin = B(y, l);\n        J[k] = Math.max(J[k], a.axisTitleMargin + D + t * a.offset, l, v && p.length && K ? K[0] + t * a.offset : 0);\n        p = 2 * Math.floor(a.axisLine.strokeWidth() / 2);\n        0 < e.offset && (p -= 2 * e.offset);\n        b[f] = Math.max(b[f] || p, p);\n      },\n      getLinePath: function getLinePath(a) {\n        var b = this.chart,\n            c = this.opposite,\n            h = this.offset,\n            e = this.horiz,\n            p = this.left + (c ? this.width : 0) + h,\n            h = b.chartHeight - this.bottom - (c ? this.height : 0) + h;\n        c && (a *= -1);\n        return b.renderer.crispLine([\"M\", e ? this.left : p, e ? h : this.top, \"L\", e ? b.chartWidth - this.right : p, e ? h : b.chartHeight - this.bottom], a);\n      },\n      renderLine: function renderLine() {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      },\n      getTitlePosition: function getTitlePosition() {\n        var a = this.horiz,\n            b = this.left,\n            c = this.top,\n            e = this.len,\n            p = this.options.title,\n            d = a ? b : c,\n            n = this.opposite,\n            q = this.offset,\n            k = p.x || 0,\n            g = p.y || 0,\n            f = this.axisTitle,\n            v = this.chart.renderer.fontMetrics(p.style && p.style.fontSize, f),\n            f = Math.max(f.getBBox(null, 0).height - v.h - 1, 0),\n            e = {\n          low: d + (a ? 0 : e),\n          middle: d + e / 2,\n          high: d + (a ? e : 0)\n        }[p.align],\n            b = (a ? c + this.height : b) + (a ? 1 : -1) * (n ? -1 : 1) * this.axisTitleMargin + [-f, f, v.f, -f][this.side];\n        return {\n          x: a ? e + k : b + (n ? this.width : 0) + q + k,\n          y: a ? b + g - (n ? this.height : 0) + q : e + g\n        };\n      },\n      renderMinorTick: function renderMinorTick(a) {\n        var b = this.chart.hasRendered && D(this.oldMin),\n            c = this.minorTicks;\n        c[a] || (c[a] = new I(this, a, \"minor\"));\n        b && c[a].isNew && c[a].render(null, !0);\n        c[a].render(null, !1, 1);\n      },\n      renderTick: function renderTick(a, b) {\n        var c = this.isLinked,\n            e = this.ticks,\n            h = this.chart.hasRendered && D(this.oldMin);\n        if (!c || a >= this.min && a <= this.max) e[a] || (e[a] = new I(this, a)), h && e[a].isNew && e[a].render(b, !0, .1), e[a].render(b);\n      },\n      render: function render() {\n        var b = this,\n            c = b.chart,\n            e = b.options,\n            p = b.isLog,\n            d = b.lin2log,\n            n = b.isLinked,\n            k = b.tickPositions,\n            f = b.axisTitle,\n            v = b.ticks,\n            y = b.minorTicks,\n            l = b.alternateBands,\n            m = e.stackLabels,\n            r = e.alternateGridColor,\n            B = b.tickmarkOffset,\n            G = b.axisLine,\n            J = b.showAxis,\n            t = A(c.renderer.globalAnimation),\n            L,\n            u;\n        b.labelEdge.length = 0;\n        b.overlap = !1;\n        g([v, y, l], function (a) {\n          q(a, function (a) {\n            a.isActive = !1;\n          });\n        });\n        if (b.hasData() || n) b.minorTickInterval && !b.categories && g(b.getMinorTickPositions(), function (a) {\n          b.renderMinorTick(a);\n        }), k.length && (g(k, function (a, c) {\n          b.renderTick(a, c);\n        }), B && (0 === b.min || b.single) && (v[-1] || (v[-1] = new I(b, -1, null, !0)), v[-1].render(-1))), r && g(k, function (e, h) {\n          u = void 0 !== k[h + 1] ? k[h + 1] + B : b.max - B;\n          0 === h % 2 && e < b.max && u <= b.max + (c.polar ? -B : B) && (l[e] || (l[e] = new a.PlotLineOrBand(b)), L = e + B, l[e].options = {\n            from: p ? d(L) : L,\n            to: p ? d(u) : u,\n            color: r\n          }, l[e].render(), l[e].isActive = !0);\n        }), b._addedPlotLB || (g((e.plotLines || []).concat(e.plotBands || []), function (a) {\n          b.addPlotBandOrLine(a);\n        }), b._addedPlotLB = !0);\n        g([v, y, l], function (a) {\n          var b,\n              e = [],\n              h = t.duration;\n          q(a, function (a, b) {\n            a.isActive || (a.render(b, !1, 0), a.isActive = !1, e.push(b));\n          });\n          z(function () {\n            for (b = e.length; b--;) {\n              a[e[b]] && !a[e[b]].isActive && (a[e[b]].destroy(), delete a[e[b]]);\n            }\n          }, a !== l && c.hasRendered && h ? h : 0);\n        });\n        G && (G[G.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(G.strokeWidth())\n        }), G.isPlaced = !0, G[J ? \"show\" : \"hide\"](!0));\n        f && J && (e = b.getTitlePosition(), D(e.y) ? (f[f.isNew ? \"attr\" : \"animate\"](e), f.isNew = !1) : (f.attr(\"y\", -9999), f.isNew = !0));\n        m && m.enabled && b.renderStackTotals();\n        b.isDirty = !1;\n      },\n      redraw: function redraw() {\n        this.visible && (this.render(), g(this.plotLinesAndBands, function (a) {\n          a.render();\n        }));\n        g(this.series, function (a) {\n          a.isDirty = !0;\n        });\n      },\n      keepProps: \"extKey hcEvents names series userMax userMin\".split(\" \"),\n      destroy: function destroy(a) {\n        var b = this,\n            c = b.stacks,\n            e = b.plotLinesAndBands,\n            h;\n        a || K(b);\n        q(c, function (a, b) {\n          t(a);\n          c[b] = null;\n        });\n        g([b.ticks, b.minorTicks, b.alternateBands], function (a) {\n          t(a);\n        });\n        if (e) for (a = e.length; a--;) {\n          e[a].destroy();\n        }\n        g(\"stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross\".split(\" \"), function (a) {\n          b[a] && (b[a] = b[a].destroy());\n        });\n\n        for (h in b.plotLinesAndBandsGroups) {\n          b.plotLinesAndBandsGroups[h] = b.plotLinesAndBandsGroups[h].destroy();\n        }\n\n        q(b, function (a, c) {\n          -1 === y(c, b.keepProps) && delete b[c];\n        });\n      },\n      drawCrosshair: function drawCrosshair(a, b) {\n        var c,\n            e = this.crosshair,\n            h = B(e.snap, !0),\n            p,\n            d = this.cross;\n        a || (a = this.cross && this.cross.e);\n        this.crosshair && !1 !== (r(b) || !h) ? (h ? r(b) && (p = this.isXAxis ? b.plotX : this.len - b.plotY) : p = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos), r(p) && (c = this.getPlotLinePath(b && (this.isXAxis ? b.x : B(b.stackY, b.y)), null, null, null, p) || null), r(c) ? (b = this.categories && !this.isRadial, d || (this.cross = d = this.chart.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (b ? \"category \" : \"thin \") + e.className).attr({\n          zIndex: B(e.zIndex, 2)\n        }).add(), d.attr({\n          stroke: e.color || (b ? m(\"#ccd6eb\").setOpacity(.25).get() : \"#cccccc\"),\n          \"stroke-width\": B(e.width, 1)\n        }), e.dashStyle && d.attr({\n          dashstyle: e.dashStyle\n        })), d.show().attr({\n          d: c\n        }), b && !e.width && d.attr({\n          \"stroke-width\": this.transA\n        }), this.cross.e = a) : this.hideCrosshair()) : this.hideCrosshair();\n      },\n      hideCrosshair: function hideCrosshair() {\n        this.cross && this.cross.hide();\n      }\n    });\n    return a.Axis = L;\n  }(M);\n\n  (function (a) {\n    var C = a.Axis,\n        A = a.Date,\n        F = a.dateFormat,\n        E = a.defaultOptions,\n        m = a.defined,\n        f = a.each,\n        l = a.extend,\n        r = a.getMagnitude,\n        u = a.getTZOffset,\n        t = a.normalizeTickInterval,\n        g = a.pick,\n        d = a.timeUnits;\n\n    C.prototype.getTimeTicks = function (a, b, e, v) {\n      var k = [],\n          n = {},\n          D = E.global.useUTC,\n          r,\n          c = new A(b - Math.max(u(b), u(e))),\n          G = A.hcMakeTime,\n          q = a.unitRange,\n          B = a.count,\n          t,\n          p;\n\n      if (m(b)) {\n        c[A.hcSetMilliseconds](q >= d.second ? 0 : B * Math.floor(c.getMilliseconds() / B));\n        if (q >= d.second) c[A.hcSetSeconds](q >= d.minute ? 0 : B * Math.floor(c.getSeconds() / B));\n        if (q >= d.minute) c[A.hcSetMinutes](q >= d.hour ? 0 : B * Math.floor(c[A.hcGetMinutes]() / B));\n        if (q >= d.hour) c[A.hcSetHours](q >= d.day ? 0 : B * Math.floor(c[A.hcGetHours]() / B));\n        if (q >= d.day) c[A.hcSetDate](q >= d.month ? 1 : B * Math.floor(c[A.hcGetDate]() / B));\n        q >= d.month && (c[A.hcSetMonth](q >= d.year ? 0 : B * Math.floor(c[A.hcGetMonth]() / B)), r = c[A.hcGetFullYear]());\n        if (q >= d.year) c[A.hcSetFullYear](r - r % B);\n        if (q === d.week) c[A.hcSetDate](c[A.hcGetDate]() - c[A.hcGetDay]() + g(v, 1));\n        r = c[A.hcGetFullYear]();\n        v = c[A.hcGetMonth]();\n        var z = c[A.hcGetDate](),\n            I = c[A.hcGetHours]();\n        if (A.hcTimezoneOffset || A.hcGetTimezoneOffset) p = (!D || !!A.hcGetTimezoneOffset) && (e - b > 4 * d.month || u(b) !== u(e)), c = c.getTime(), t = u(c), c = new A(c + t);\n        D = c.getTime();\n\n        for (b = 1; D < e;) {\n          k.push(D), D = q === d.year ? G(r + b * B, 0) : q === d.month ? G(r, v + b * B) : !p || q !== d.day && q !== d.week ? p && q === d.hour ? G(r, v, z, I + b * B, 0, 0, t) - t : D + q * B : G(r, v, z + b * B * (q === d.day ? 1 : 7)), b++;\n        }\n\n        k.push(D);\n        q <= d.hour && 1E4 > k.length && f(k, function (a) {\n          0 === a % 18E5 && \"000000000\" === F(\"%H%M%S%L\", a) && (n[a] = \"day\");\n        });\n      }\n\n      k.info = l(a, {\n        higherRanks: n,\n        totalRange: q * B\n      });\n      return k;\n    };\n\n    C.prototype.normalizeTimeTickInterval = function (a, b) {\n      var e = b || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n      b = e[e.length - 1];\n      var k = d[b[0]],\n          g = b[1],\n          n;\n\n      for (n = 0; n < e.length && !(b = e[n], k = d[b[0]], g = b[1], e[n + 1] && a <= (k * g[g.length - 1] + d[e[n + 1][0]]) / 2); n++) {\n        ;\n      }\n\n      k === d.year && a < 5 * k && (g = [1, 2, 5]);\n      a = t(a / k, g, \"year\" === b[0] ? Math.max(r(a / k), 1) : 1);\n      return {\n        unitRange: k,\n        count: a,\n        unitName: b[0]\n      };\n    };\n  })(M);\n\n  (function (a) {\n    var C = a.Axis,\n        A = a.getMagnitude,\n        F = a.map,\n        E = a.normalizeTickInterval,\n        m = a.pick;\n\n    C.prototype.getLogTickPositions = function (a, l, r, u) {\n      var f = this.options,\n          g = this.len,\n          d = this.lin2log,\n          k = this.log2lin,\n          b = [];\n      u || (this._minorAutoInterval = null);\n      if (.5 <= a) a = Math.round(a), b = this.getLinearTickPositions(a, l, r);else if (.08 <= a) for (var g = Math.floor(l), e, v, y, n, D, f = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; g < r + 1 && !D; g++) {\n        for (v = f.length, e = 0; e < v && !D; e++) {\n          y = k(d(g) * f[e]), y > l && (!u || n <= r) && void 0 !== n && b.push(n), n > r && (D = !0), n = y;\n        }\n      } else l = d(l), r = d(r), a = f[u ? \"minorTickInterval\" : \"tickInterval\"], a = m(\"auto\" === a ? null : a, this._minorAutoInterval, f.tickPixelInterval / (u ? 5 : 1) * (r - l) / ((u ? g / this.tickPositions.length : g) || 1)), a = E(a, null, A(a)), b = F(this.getLinearTickPositions(a, l, r), k), u || (this._minorAutoInterval = a / 5);\n      u || (this.tickInterval = a);\n      return b;\n    };\n\n    C.prototype.log2lin = function (a) {\n      return Math.log(a) / Math.LN10;\n    };\n\n    C.prototype.lin2log = function (a) {\n      return Math.pow(10, a);\n    };\n  })(M);\n\n  (function (a, C) {\n    var A = a.arrayMax,\n        F = a.arrayMin,\n        E = a.defined,\n        m = a.destroyObjectProperties,\n        f = a.each,\n        l = a.erase,\n        r = a.merge,\n        u = a.pick;\n\n    a.PlotLineOrBand = function (a, g) {\n      this.axis = a;\n      g && (this.options = g, this.id = g.id);\n    };\n\n    a.PlotLineOrBand.prototype = {\n      render: function render() {\n        var f = this,\n            g = f.axis,\n            d = g.horiz,\n            k = f.options,\n            b = k.label,\n            e = f.label,\n            v = k.to,\n            l = k.from,\n            n = k.value,\n            D = E(l) && E(v),\n            m = E(n),\n            c = f.svgElem,\n            G = !c,\n            q = [],\n            B = k.color,\n            K = u(k.zIndex, 0),\n            p = k.events,\n            q = {\n          \"class\": \"highcharts-plot-\" + (D ? \"band \" : \"line \") + (k.className || \"\")\n        },\n            z = {},\n            I = g.chart.renderer,\n            L = D ? \"bands\" : \"lines\",\n            h = g.log2lin;\n        g.isLog && (l = h(l), v = h(v), n = h(n));\n        m ? (q = {\n          stroke: B,\n          \"stroke-width\": k.width\n        }, k.dashStyle && (q.dashstyle = k.dashStyle)) : D && (B && (q.fill = B), k.borderWidth && (q.stroke = k.borderColor, q[\"stroke-width\"] = k.borderWidth));\n        z.zIndex = K;\n        L += \"-\" + K;\n        (B = g.plotLinesAndBandsGroups[L]) || (g.plotLinesAndBandsGroups[L] = B = I.g(\"plot-\" + L).attr(z).add());\n        G && (f.svgElem = c = I.path().attr(q).add(B));\n        if (m) q = g.getPlotLinePath(n, c.strokeWidth());else if (D) q = g.getPlotBandPath(l, v, k);else return;\n        G && q && q.length ? (c.attr({\n          d: q\n        }), p && a.objectEach(p, function (a, b) {\n          c.on(b, function (a) {\n            p[b].apply(f, [a]);\n          });\n        })) : c && (q ? (c.show(), c.animate({\n          d: q\n        })) : (c.hide(), e && (f.label = e = e.destroy())));\n        b && E(b.text) && q && q.length && 0 < g.width && 0 < g.height && !q.flat ? (b = r({\n          align: d && D && \"center\",\n          x: d ? !D && 4 : 10,\n          verticalAlign: !d && D && \"middle\",\n          y: d ? D ? 16 : 10 : D ? 6 : -4,\n          rotation: d && !D && 90\n        }, b), this.renderLabel(b, q, D, K)) : e && e.hide();\n        return f;\n      },\n      renderLabel: function renderLabel(a, g, d, k) {\n        var b = this.label,\n            e = this.axis.chart.renderer;\n        b || (b = {\n          align: a.textAlign || a.align,\n          rotation: a.rotation,\n          \"class\": \"highcharts-plot-\" + (d ? \"band\" : \"line\") + \"-label \" + (a.className || \"\")\n        }, b.zIndex = k, this.label = b = e.text(a.text, 0, 0, a.useHTML).attr(b).add(), b.css(a.style));\n        k = [g[1], g[4], d ? g[6] : g[1]];\n        g = [g[2], g[5], d ? g[7] : g[2]];\n        d = F(k);\n        e = F(g);\n        b.align(a, !1, {\n          x: d,\n          y: e,\n          width: A(k) - d,\n          height: A(g) - e\n        });\n        b.show();\n      },\n      destroy: function destroy() {\n        l(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        m(this);\n      }\n    };\n    a.extend(C.prototype, {\n      getPlotBandPath: function getPlotBandPath(a, g) {\n        var d = this.getPlotLinePath(g, null, null, !0),\n            k = this.getPlotLinePath(a, null, null, !0),\n            b = this.horiz,\n            e = 1;\n        a = a < this.min && g < this.min || a > this.max && g > this.max;\n        k && d ? (a && (k.flat = k.toString() === d.toString(), e = 0), k.push(b && d[4] === k[4] ? d[4] + e : d[4], b || d[5] !== k[5] ? d[5] : d[5] + e, b && d[1] === k[1] ? d[1] + e : d[1], b || d[2] !== k[2] ? d[2] : d[2] + e)) : k = null;\n        return k;\n      },\n      addPlotBand: function addPlotBand(a) {\n        return this.addPlotBandOrLine(a, \"plotBands\");\n      },\n      addPlotLine: function addPlotLine(a) {\n        return this.addPlotBandOrLine(a, \"plotLines\");\n      },\n      addPlotBandOrLine: function addPlotBandOrLine(f, g) {\n        var d = new a.PlotLineOrBand(this, f).render(),\n            k = this.userOptions;\n        d && (g && (k[g] = k[g] || [], k[g].push(f)), this.plotLinesAndBands.push(d));\n        return d;\n      },\n      removePlotBandOrLine: function removePlotBandOrLine(a) {\n        for (var g = this.plotLinesAndBands, d = this.options, k = this.userOptions, b = g.length; b--;) {\n          g[b].id === a && g[b].destroy();\n        }\n\n        f([d.plotLines || [], k.plotLines || [], d.plotBands || [], k.plotBands || []], function (e) {\n          for (b = e.length; b--;) {\n            e[b].id === a && l(e, e[b]);\n          }\n        });\n      },\n      removePlotBand: function removePlotBand(a) {\n        this.removePlotBandOrLine(a);\n      },\n      removePlotLine: function removePlotLine(a) {\n        this.removePlotBandOrLine(a);\n      }\n    });\n  })(M, S);\n\n  (function (a) {\n    var C = a.dateFormat,\n        A = a.each,\n        F = a.extend,\n        E = a.format,\n        m = a.isNumber,\n        f = a.map,\n        l = a.merge,\n        r = a.pick,\n        u = a.splat,\n        t = a.syncTimeout,\n        g = a.timeUnits;\n\n    a.Tooltip = function () {\n      this.init.apply(this, arguments);\n    };\n\n    a.Tooltip.prototype = {\n      init: function init(a, k) {\n        this.chart = a;\n        this.options = k;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = k.split && !a.inverted;\n        this.shared = k.shared || this.split;\n      },\n      cleanSplit: function cleanSplit(a) {\n        A(this.chart.series, function (d) {\n          var b = d && d.tt;\n          b && (!b.isActive || a ? d.tt = b.destroy() : b.isActive = !1);\n        });\n      },\n      getLabel: function getLabel() {\n        var a = this.chart.renderer,\n            k = this.options;\n        this.label || (this.split ? this.label = a.g(\"tooltip\") : (this.label = a.label(\"\", 0, 0, k.shape || \"callout\", null, null, k.useHTML, null, \"tooltip\").attr({\n          padding: k.padding,\n          r: k.borderRadius\n        }), this.label.attr({\n          fill: k.backgroundColor,\n          \"stroke-width\": k.borderWidth\n        }).css(k.style).shadow(k.shadow)), this.label.attr({\n          zIndex: 8\n        }).add());\n        return this.label;\n      },\n      update: function update(a) {\n        this.destroy();\n        l(!0, this.chart.options.tooltip.userOptions, a);\n        this.init(this.chart, l(!0, this.options, a));\n      },\n      destroy: function destroy() {\n        this.label && (this.label = this.label.destroy());\n        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());\n        clearTimeout(this.hideTimer);\n        clearTimeout(this.tooltipTimeout);\n      },\n      move: function move(a, k, b, e) {\n        var d = this,\n            g = d.now,\n            n = !1 !== d.options.animation && !d.isHidden && (1 < Math.abs(a - g.x) || 1 < Math.abs(k - g.y)),\n            f = d.followPointer || 1 < d.len;\n        F(g, {\n          x: n ? (2 * g.x + a) / 3 : a,\n          y: n ? (g.y + k) / 2 : k,\n          anchorX: f ? void 0 : n ? (2 * g.anchorX + b) / 3 : b,\n          anchorY: f ? void 0 : n ? (g.anchorY + e) / 2 : e\n        });\n        d.getLabel().attr(g);\n        n && (clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          d && d.move(a, k, b, e);\n        }, 32));\n      },\n      hide: function hide(a) {\n        var d = this;\n        clearTimeout(this.hideTimer);\n        a = r(a, this.options.hideDelay, 500);\n        this.isHidden || (this.hideTimer = t(function () {\n          d.getLabel()[a ? \"fadeOut\" : \"hide\"]();\n          d.isHidden = !0;\n        }, a));\n      },\n      getAnchor: function getAnchor(a, k) {\n        var b,\n            e = this.chart,\n            d = e.inverted,\n            g = e.plotTop,\n            n = e.plotLeft,\n            l = 0,\n            m = 0,\n            c,\n            r;\n        a = u(a);\n        b = a[0].tooltipPos;\n        this.followPointer && k && (void 0 === k.chartX && (k = e.pointer.normalize(k)), b = [k.chartX - e.plotLeft, k.chartY - g]);\n        b || (A(a, function (a) {\n          c = a.series.yAxis;\n          r = a.series.xAxis;\n          l += a.plotX + (!d && r ? r.left - n : 0);\n          m += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!d && c ? c.top - g : 0);\n        }), l /= a.length, m /= a.length, b = [d ? e.plotWidth - m : l, this.shared && !d && 1 < a.length && k ? k.chartY - g : d ? e.plotHeight - l : m]);\n        return f(b, Math.round);\n      },\n      getPosition: function getPosition(a, g, b) {\n        var e = this.chart,\n            d = this.distance,\n            k = {},\n            n = b.h || 0,\n            f,\n            l = [\"y\", e.chartHeight, g, b.plotY + e.plotTop, e.plotTop, e.plotTop + e.plotHeight],\n            c = [\"x\", e.chartWidth, a, b.plotX + e.plotLeft, e.plotLeft, e.plotLeft + e.plotWidth],\n            m = !this.followPointer && r(b.ttBelow, !e.inverted === !!b.negative),\n            q = function q(a, b, c, e, p, _q) {\n          var h = c < e - d,\n              g = e + d + c < b,\n              f = e - d - c;\n          e += d;\n          if (m && g) k[a] = e;else if (!m && h) k[a] = f;else if (h) k[a] = Math.min(_q - c, 0 > f - n ? f : f - n);else if (g) k[a] = Math.max(p, e + n + c > b ? e : e + n);else return !1;\n        },\n            B = function B(a, b, c, e) {\n          var h;\n          e < d || e > b - d ? h = !1 : k[a] = e < c / 2 ? 1 : e > b - c / 2 ? b - c - 2 : e - c / 2;\n          return h;\n        },\n            t = function t(a) {\n          var b = l;\n          l = c;\n          c = b;\n          f = a;\n        },\n            p = function p() {\n          !1 !== q.apply(0, l) ? !1 !== B.apply(0, c) || f || (t(!0), p()) : f ? k.x = k.y = 0 : (t(!0), p());\n        };\n\n        (e.inverted || 1 < this.len) && t();\n        p();\n        return k;\n      },\n      defaultFormatter: function defaultFormatter(a) {\n        var d = this.points || u(this),\n            b;\n        b = [a.tooltipFooterHeaderFormatter(d[0])];\n        b = b.concat(a.bodyFormatter(d));\n        b.push(a.tooltipFooterHeaderFormatter(d[0], !0));\n        return b;\n      },\n      refresh: function refresh(a, g) {\n        var b,\n            e = this.options,\n            d,\n            k = a,\n            n,\n            f = {},\n            l = [];\n        b = e.formatter || this.defaultFormatter;\n        var f = this.shared,\n            c;\n        e.enabled && (clearTimeout(this.hideTimer), this.followPointer = u(k)[0].series.tooltipOptions.followPointer, n = this.getAnchor(k, g), g = n[0], d = n[1], !f || k.series && k.series.noSharedTooltip ? f = k.getLabelConfig() : (A(k, function (a) {\n          a.setState(\"hover\");\n          l.push(a.getLabelConfig());\n        }), f = {\n          x: k[0].category,\n          y: k[0].y\n        }, f.points = l, k = k[0]), this.len = l.length, f = b.call(f, this), c = k.series, this.distance = r(c.tooltipOptions.distance, 16), !1 === f ? this.hide() : (b = this.getLabel(), this.isHidden && b.attr({\n          opacity: 1\n        }).show(), this.split ? this.renderSplit(f, a) : (e.style.width || b.css({\n          width: this.chart.spacingBox.width\n        }), b.attr({\n          text: f && f.join ? f.join(\"\") : f\n        }), b.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\" + r(k.colorIndex, c.colorIndex)), b.attr({\n          stroke: e.borderColor || k.color || c.color || \"#666666\"\n        }), this.updatePosition({\n          plotX: g,\n          plotY: d,\n          negative: k.negative,\n          ttBelow: k.ttBelow,\n          h: n[2] || 0\n        })), this.isHidden = !1));\n      },\n      renderSplit: function renderSplit(d, k) {\n        var b = this,\n            e = [],\n            g = this.chart,\n            f = g.renderer,\n            n = !0,\n            l = this.options,\n            m = 0,\n            c = this.getLabel();\n        A(d.slice(0, k.length + 1), function (a, d) {\n          if (!1 !== a) {\n            d = k[d - 1] || {\n              isHeader: !0,\n              plotX: k[0].plotX\n            };\n            var q = d.series || b,\n                v = q.tt,\n                p = d.series || {},\n                z = \"highcharts-color-\" + r(d.colorIndex, p.colorIndex, \"none\");\n            v || (q.tt = v = f.label(null, null, null, \"callout\").addClass(\"highcharts-tooltip-box \" + z).attr({\n              padding: l.padding,\n              r: l.borderRadius,\n              fill: l.backgroundColor,\n              stroke: l.borderColor || d.color || p.color || \"#333333\",\n              \"stroke-width\": l.borderWidth\n            }).add(c));\n            v.isActive = !0;\n            v.attr({\n              text: a\n            });\n            v.css(l.style).shadow(l.shadow);\n            a = v.getBBox();\n            p = a.width + v.strokeWidth();\n            d.isHeader ? (m = a.height, p = Math.max(0, Math.min(d.plotX + g.plotLeft - p / 2, g.chartWidth - p))) : p = d.plotX + g.plotLeft - r(l.distance, 16) - p;\n            0 > p && (n = !1);\n            a = (d.series && d.series.yAxis && d.series.yAxis.pos) + (d.plotY || 0);\n            a -= g.plotTop;\n            e.push({\n              target: d.isHeader ? g.plotHeight + m : a,\n              rank: d.isHeader ? 1 : 0,\n              size: q.tt.getBBox().height + 1,\n              point: d,\n              x: p,\n              tt: v\n            });\n          }\n        });\n        this.cleanSplit();\n        a.distribute(e, g.plotHeight + m);\n        A(e, function (a) {\n          var b = a.point,\n              c = b.series;\n          a.tt.attr({\n            visibility: void 0 === a.pos ? \"hidden\" : \"inherit\",\n            x: n || b.isHeader ? a.x : b.plotX + g.plotLeft + r(l.distance, 16),\n            y: a.pos + g.plotTop,\n            anchorX: b.isHeader ? b.plotX + g.plotLeft : b.plotX + c.xAxis.pos,\n            anchorY: b.isHeader ? a.pos + g.plotTop - 15 : b.plotY + c.yAxis.pos\n          });\n        });\n      },\n      updatePosition: function updatePosition(a) {\n        var d = this.chart,\n            b = this.getLabel(),\n            b = (this.options.positioner || this.getPosition).call(this, b.width, b.height, a);\n        this.move(Math.round(b.x), Math.round(b.y || 0), a.plotX + d.plotLeft, a.plotY + d.plotTop);\n      },\n      getDateFormat: function getDateFormat(a, k, b, e) {\n        var d = C(\"%m-%d %H:%M:%S.%L\", k),\n            f,\n            n,\n            l = {\n          millisecond: 15,\n          second: 12,\n          minute: 9,\n          hour: 6,\n          day: 3\n        },\n            m = \"millisecond\";\n\n        for (n in g) {\n          if (a === g.week && +C(\"%w\", k) === b && \"00:00:00.000\" === d.substr(6)) {\n            n = \"week\";\n            break;\n          }\n\n          if (g[n] > a) {\n            n = m;\n            break;\n          }\n\n          if (l[n] && d.substr(l[n]) !== \"01-01 00:00:00.000\".substr(l[n])) break;\n          \"week\" !== n && (m = n);\n        }\n\n        n && (f = e[n]);\n        return f;\n      },\n      getXDateFormat: function getXDateFormat(a, g, b) {\n        g = g.dateTimeLabelFormats;\n        var e = b && b.closestPointRange;\n        return (e ? this.getDateFormat(e, a.x, b.options.startOfWeek, g) : g.day) || g.year;\n      },\n      tooltipFooterHeaderFormatter: function tooltipFooterHeaderFormatter(a, g) {\n        var b = g ? \"footer\" : \"header\";\n        g = a.series;\n        var e = g.tooltipOptions,\n            d = e.xDateFormat,\n            k = g.xAxis,\n            n = k && \"datetime\" === k.options.type && m(a.key),\n            b = e[b + \"Format\"];\n        n && !d && (d = this.getXDateFormat(a, e, k));\n        n && d && (b = b.replace(\"{point.key}\", \"{point.key:\" + d + \"}\"));\n        return E(b, {\n          point: a,\n          series: g\n        });\n      },\n      bodyFormatter: function bodyFormatter(a) {\n        return f(a, function (a) {\n          var b = a.series.tooltipOptions;\n          return (b.pointFormatter || a.point.tooltipFormatter).call(a.point, b.pointFormat);\n        });\n      }\n    };\n  })(M);\n\n  (function (a) {\n    var C = a.addEvent,\n        A = a.attr,\n        F = a.charts,\n        E = a.color,\n        m = a.css,\n        f = a.defined,\n        l = a.each,\n        r = a.extend,\n        u = a.find,\n        t = a.fireEvent,\n        g = a.isObject,\n        d = a.offset,\n        k = a.pick,\n        b = a.removeEvent,\n        e = a.splat,\n        v = a.Tooltip,\n        y = a.win;\n\n    a.Pointer = function (a, b) {\n      this.init(a, b);\n    };\n\n    a.Pointer.prototype = {\n      init: function init(a, b) {\n        this.options = b;\n        this.chart = a;\n        this.runChartClick = b.chart.events && !!b.chart.events.click;\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        v && (a.tooltip = new v(a, b.tooltip), this.followTouchMove = k(b.tooltip.followTouchMove, !0));\n        this.setDOMEvents();\n      },\n      zoomOption: function zoomOption(a) {\n        var b = this.chart,\n            e = b.options.chart,\n            c = e.zoomType || \"\",\n            b = b.inverted;\n        /touch/.test(a.type) && (c = k(e.pinchType, c));\n        this.zoomX = a = /x/.test(c);\n        this.zoomY = c = /y/.test(c);\n        this.zoomHor = a && !b || c && b;\n        this.zoomVert = c && !b || a && b;\n        this.hasZoom = a || c;\n      },\n      normalize: function normalize(a, b) {\n        var e, c;\n        a = a || y.event;\n        a.target || (a.target = a.srcElement);\n        c = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a;\n        b || (this.chartPosition = b = d(this.chart.container));\n        void 0 === c.pageX ? (e = Math.max(a.x, a.clientX - b.left), b = a.y) : (e = c.pageX - b.left, b = c.pageY - b.top);\n        return r(a, {\n          chartX: Math.round(e),\n          chartY: Math.round(b)\n        });\n      },\n      getCoordinates: function getCoordinates(a) {\n        var b = {\n          xAxis: [],\n          yAxis: []\n        };\n        l(this.chart.axes, function (e) {\n          b[e.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: e,\n            value: e.toValue(a[e.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return b;\n      },\n      findNearestKDPoint: function findNearestKDPoint(a, b, e) {\n        var c;\n        l(a, function (a) {\n          var d = !(a.noSharedTooltip && b) && 0 > a.options.findNearestPointBy.indexOf(\"y\");\n          a = a.searchPoint(e, d);\n          if ((d = g(a, !0)) && !(d = !g(c, !0))) var d = c.distX - a.distX,\n              n = c.dist - a.dist,\n              k = (a.series.group && a.series.group.zIndex) - (c.series.group && c.series.group.zIndex),\n              d = 0 < (0 !== d && b ? d : 0 !== n ? n : 0 !== k ? k : c.series.index > a.series.index ? -1 : 1);\n          d && (c = a);\n        });\n        return c;\n      },\n      getPointFromEvent: function getPointFromEvent(a) {\n        a = a.target;\n\n        for (var b; a && !b;) {\n          b = a.point, a = a.parentNode;\n        }\n\n        return b;\n      },\n      getChartCoordinatesFromPoint: function getChartCoordinatesFromPoint(a, b) {\n        var e = a.series,\n            c = e.xAxis,\n            e = e.yAxis;\n        if (c && e) return b ? {\n          chartX: c.len + c.pos - a.clientX,\n          chartY: e.len + e.pos - a.plotY\n        } : {\n          chartX: a.clientX + c.pos,\n          chartY: a.plotY + e.pos\n        };\n      },\n      getHoverData: function getHoverData(b, e, d, c, f, q) {\n        var n,\n            v = [];\n        c = !(!c || !b);\n        var p = e && !e.stickyTracking ? [e] : a.grep(d, function (a) {\n          return a.visible && !(!f && a.directTouch) && k(a.options.enableMouseTracking, !0) && a.stickyTracking;\n        });\n        e = (n = c ? b : this.findNearestKDPoint(p, f, q)) && n.series;\n        n && (f && !e.noSharedTooltip ? (p = a.grep(d, function (a) {\n          return a.visible && !(!f && a.directTouch) && k(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;\n        }), l(p, function (a) {\n          a = u(a.points, function (a) {\n            return a.x === n.x;\n          });\n          g(a) && !a.isNull && v.push(a);\n        })) : v.push(n));\n        return {\n          hoverPoint: n,\n          hoverSeries: e,\n          hoverPoints: v\n        };\n      },\n      runPointActions: function runPointActions(b, e) {\n        var d = this.chart,\n            c = d.tooltip,\n            g = c ? c.shared : !1,\n            n = e || d.hoverPoint,\n            f = n && n.series || d.hoverSeries,\n            f = this.getHoverData(n, f, d.series, !!e || f && f.directTouch && this.isDirectTouch, g, b),\n            v,\n            n = f.hoverPoint;\n        v = f.hoverPoints;\n        e = (f = f.hoverSeries) && f.tooltipOptions.followPointer;\n        g = g && f && !f.noSharedTooltip;\n\n        if (n && (n !== d.hoverPoint || c && c.isHidden)) {\n          l(d.hoverPoints || [], function (b) {\n            -1 === a.inArray(b, v) && b.setState();\n          });\n          l(v || [], function (a) {\n            a.setState(\"hover\");\n          });\n          if (d.hoverSeries !== f) f.onMouseOver();\n          d.hoverPoint && d.hoverPoint.firePointEvent(\"mouseOut\");\n          n.firePointEvent(\"mouseOver\");\n          d.hoverPoints = v;\n          d.hoverPoint = n;\n          c && c.refresh(g ? v : n, b);\n        } else e && c && !c.isHidden && (n = c.getAnchor([{}], b), c.updatePosition({\n          plotX: n[0],\n          plotY: n[1]\n        }));\n\n        this.unDocMouseMove || (this.unDocMouseMove = C(d.container.ownerDocument, \"mousemove\", function (b) {\n          var c = F[a.hoverChartIndex];\n          if (c) c.pointer.onDocumentMouseMove(b);\n        }));\n        l(d.axes, function (c) {\n          var e = k(c.crosshair.snap, !0),\n              p = e ? a.find(v, function (a) {\n            return a.series[c.coll] === c;\n          }) : void 0;\n          p || !e ? c.drawCrosshair(b, p) : c.hideCrosshair();\n        });\n      },\n      reset: function reset(a, b) {\n        var d = this.chart,\n            c = d.hoverSeries,\n            g = d.hoverPoint,\n            n = d.hoverPoints,\n            f = d.tooltip,\n            k = f && f.shared ? n : g;\n        a && k && l(e(k), function (b) {\n          b.series.isCartesian && void 0 === b.plotX && (a = !1);\n        });\n        if (a) f && k && (f.refresh(k), g && (g.setState(g.state, !0), l(d.axes, function (a) {\n          a.crosshair && a.drawCrosshair(null, g);\n        })));else {\n          if (g) g.onMouseOut();\n          n && l(n, function (a) {\n            a.setState();\n          });\n          if (c) c.onMouseOut();\n          f && f.hide(b);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          l(d.axes, function (a) {\n            a.hideCrosshair();\n          });\n          this.hoverX = d.hoverPoints = d.hoverPoint = null;\n        }\n      },\n      scaleGroups: function scaleGroups(a, b) {\n        var e = this.chart,\n            c;\n        l(e.series, function (d) {\n          c = a || d.getPlotBox();\n          d.xAxis && d.xAxis.zoomEnabled && d.group && (d.group.attr(c), d.markerGroup && (d.markerGroup.attr(c), d.markerGroup.clip(b ? e.clipRect : null)), d.dataLabelsGroup && d.dataLabelsGroup.attr(c));\n        });\n        e.clipRect.attr(b || e.clipBox);\n      },\n      dragStart: function dragStart(a) {\n        var b = this.chart;\n        b.mouseIsDown = a.type;\n        b.cancelClick = !1;\n        b.mouseDownX = this.mouseDownX = a.chartX;\n        b.mouseDownY = this.mouseDownY = a.chartY;\n      },\n      drag: function drag(a) {\n        var b = this.chart,\n            e = b.options.chart,\n            c = a.chartX,\n            d = a.chartY,\n            g = this.zoomHor,\n            n = this.zoomVert,\n            f = b.plotLeft,\n            p = b.plotTop,\n            k = b.plotWidth,\n            v = b.plotHeight,\n            l,\n            h = this.selectionMarker,\n            w = this.mouseDownX,\n            m = this.mouseDownY,\n            r = e.panKey && a[e.panKey + \"Key\"];\n        h && h.touch || (c < f ? c = f : c > f + k && (c = f + k), d < p ? d = p : d > p + v && (d = p + v), this.hasDragged = Math.sqrt(Math.pow(w - c, 2) + Math.pow(m - d, 2)), 10 < this.hasDragged && (l = b.isInsidePlot(w - f, m - p), b.hasCartesianSeries && (this.zoomX || this.zoomY) && l && !r && !h && (this.selectionMarker = h = b.renderer.rect(f, p, g ? 1 : k, n ? 1 : v, 0).attr({\n          fill: e.selectionMarkerFill || E(\"#335cad\").setOpacity(.25).get(),\n          \"class\": \"highcharts-selection-marker\",\n          zIndex: 7\n        }).add()), h && g && (c -= w, h.attr({\n          width: Math.abs(c),\n          x: (0 < c ? 0 : c) + w\n        })), h && n && (c = d - m, h.attr({\n          height: Math.abs(c),\n          y: (0 < c ? 0 : c) + m\n        })), l && !h && e.panning && b.pan(a, e.panning)));\n      },\n      drop: function drop(a) {\n        var b = this,\n            e = this.chart,\n            c = this.hasPinched;\n\n        if (this.selectionMarker) {\n          var d = {\n            originalEvent: a,\n            xAxis: [],\n            yAxis: []\n          },\n              g = this.selectionMarker,\n              n = g.attr ? g.attr(\"x\") : g.x,\n              k = g.attr ? g.attr(\"y\") : g.y,\n              p = g.attr ? g.attr(\"width\") : g.width,\n              v = g.attr ? g.attr(\"height\") : g.height,\n              I;\n          if (this.hasDragged || c) l(e.axes, function (e) {\n            if (e.zoomEnabled && f(e.min) && (c || b[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[e.coll]])) {\n              var h = e.horiz,\n                  g = \"touchend\" === a.type ? e.minPixelPadding : 0,\n                  q = e.toValue((h ? n : k) + g),\n                  h = e.toValue((h ? n + p : k + v) - g);\n              d[e.coll].push({\n                axis: e,\n                min: Math.min(q, h),\n                max: Math.max(q, h)\n              });\n              I = !0;\n            }\n          }), I && t(e, \"selection\", d, function (a) {\n            e.zoom(r(a, c ? {\n              animation: !1\n            } : null));\n          });\n          this.selectionMarker = this.selectionMarker.destroy();\n          c && this.scaleGroups();\n        }\n\n        e && (m(e.container, {\n          cursor: e._cursor\n        }), e.cancelClick = 10 < this.hasDragged, e.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      },\n      onContainerMouseDown: function onContainerMouseDown(a) {\n        a = this.normalize(a);\n        this.zoomOption(a);\n        a.preventDefault && a.preventDefault();\n        this.dragStart(a);\n      },\n      onDocumentMouseUp: function onDocumentMouseUp(b) {\n        F[a.hoverChartIndex] && F[a.hoverChartIndex].pointer.drop(b);\n      },\n      onDocumentMouseMove: function onDocumentMouseMove(a) {\n        var b = this.chart,\n            e = this.chartPosition;\n        a = this.normalize(a, e);\n        !e || this.inClass(a.target, \"highcharts-tracker\") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || this.reset();\n      },\n      onContainerMouseLeave: function onContainerMouseLeave(b) {\n        var e = F[a.hoverChartIndex];\n        e && (b.relatedTarget || b.toElement) && (e.pointer.reset(), e.pointer.chartPosition = null);\n      },\n      onContainerMouseMove: function onContainerMouseMove(b) {\n        var e = this.chart;\n        f(a.hoverChartIndex) && F[a.hoverChartIndex] && F[a.hoverChartIndex].mouseIsDown || (a.hoverChartIndex = e.index);\n        b = this.normalize(b);\n        b.returnValue = !1;\n        \"mousedown\" === e.mouseIsDown && this.drag(b);\n        !this.inClass(b.target, \"highcharts-tracker\") && !e.isInsidePlot(b.chartX - e.plotLeft, b.chartY - e.plotTop) || e.openMenu || this.runPointActions(b);\n      },\n      inClass: function inClass(a, b) {\n        for (var e; a;) {\n          if (e = A(a, \"class\")) {\n            if (-1 !== e.indexOf(b)) return !0;\n            if (-1 !== e.indexOf(\"highcharts-container\")) return !1;\n          }\n\n          a = a.parentNode;\n        }\n      },\n      onTrackerMouseOut: function onTrackerMouseOut(a) {\n        var b = this.chart.hoverSeries;\n        a = a.relatedTarget || a.toElement;\n        this.isDirectTouch = !1;\n        if (!(!b || !a || b.stickyTracking || this.inClass(a, \"highcharts-tooltip\") || this.inClass(a, \"highcharts-series-\" + b.index) && this.inClass(a, \"highcharts-tracker\"))) b.onMouseOut();\n      },\n      onContainerClick: function onContainerClick(a) {\n        var b = this.chart,\n            e = b.hoverPoint,\n            c = b.plotLeft,\n            d = b.plotTop;\n        a = this.normalize(a);\n        b.cancelClick || (e && this.inClass(a.target, \"highcharts-tracker\") ? (t(e.series, \"click\", r(a, {\n          point: e\n        })), b.hoverPoint && e.firePointEvent(\"click\", a)) : (r(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - c, a.chartY - d) && t(b, \"click\", a)));\n      },\n      setDOMEvents: function setDOMEvents() {\n        var b = this,\n            e = b.chart.container,\n            d = e.ownerDocument;\n\n        e.onmousedown = function (a) {\n          b.onContainerMouseDown(a);\n        };\n\n        e.onmousemove = function (a) {\n          b.onContainerMouseMove(a);\n        };\n\n        e.onclick = function (a) {\n          b.onContainerClick(a);\n        };\n\n        C(e, \"mouseleave\", b.onContainerMouseLeave);\n        1 === a.chartCount && C(d, \"mouseup\", b.onDocumentMouseUp);\n        a.hasTouch && (e.ontouchstart = function (a) {\n          b.onContainerTouchStart(a);\n        }, e.ontouchmove = function (a) {\n          b.onContainerTouchMove(a);\n        }, 1 === a.chartCount && C(d, \"touchend\", b.onDocumentTouchEnd));\n      },\n      destroy: function destroy() {\n        var e = this,\n            d = this.chart.container.ownerDocument;\n        e.unDocMouseMove && e.unDocMouseMove();\n        b(e.chart.container, \"mouseleave\", e.onContainerMouseLeave);\n        a.chartCount || (b(d, \"mouseup\", e.onDocumentMouseUp), a.hasTouch && b(d, \"touchend\", e.onDocumentTouchEnd));\n        clearInterval(e.tooltipTimeout);\n        a.objectEach(e, function (a, b) {\n          e[b] = null;\n        });\n      }\n    };\n  })(M);\n\n  (function (a) {\n    var C = a.charts,\n        A = a.each,\n        F = a.extend,\n        E = a.map,\n        m = a.noop,\n        f = a.pick;\n    F(a.Pointer.prototype, {\n      pinchTranslate: function pinchTranslate(a, f, m, t, g, d) {\n        this.zoomHor && this.pinchTranslateDirection(!0, a, f, m, t, g, d);\n        this.zoomVert && this.pinchTranslateDirection(!1, a, f, m, t, g, d);\n      },\n      pinchTranslateDirection: function pinchTranslateDirection(a, f, m, t, g, d, k, b) {\n        var e = this.chart,\n            v = a ? \"x\" : \"y\",\n            l = a ? \"X\" : \"Y\",\n            n = \"chart\" + l,\n            r = a ? \"width\" : \"height\",\n            u = e[\"plot\" + (a ? \"Left\" : \"Top\")],\n            c,\n            G,\n            q = b || 1,\n            B = e.inverted,\n            K = e.bounds[a ? \"h\" : \"v\"],\n            p = 1 === f.length,\n            z = f[0][n],\n            I = m[0][n],\n            L = !p && f[1][n],\n            h = !p && m[1][n],\n            w;\n\n        m = function m() {\n          !p && 20 < Math.abs(z - L) && (q = b || Math.abs(I - h) / Math.abs(z - L));\n          G = (u - I) / q + z;\n          c = e[\"plot\" + (a ? \"Width\" : \"Height\")] / q;\n        };\n\n        m();\n        f = G;\n        f < K.min ? (f = K.min, w = !0) : f + c > K.max && (f = K.max - c, w = !0);\n        w ? (I -= .8 * (I - k[v][0]), p || (h -= .8 * (h - k[v][1])), m()) : k[v] = [I, h];\n        B || (d[v] = G - u, d[r] = c);\n        d = B ? 1 / q : q;\n        g[r] = c;\n        g[v] = f;\n        t[B ? a ? \"scaleY\" : \"scaleX\" : \"scale\" + l] = q;\n        t[\"translate\" + l] = d * u + (I - d * z);\n      },\n      pinch: function pinch(a) {\n        var l = this,\n            u = l.chart,\n            t = l.pinchDown,\n            g = a.touches,\n            d = g.length,\n            k = l.lastValidTouch,\n            b = l.hasZoom,\n            e = l.selectionMarker,\n            v = {},\n            y = 1 === d && (l.inClass(a.target, \"highcharts-tracker\") && u.runTrackerClick || l.runChartClick),\n            n = {};\n        1 < d && (l.initiated = !0);\n        b && l.initiated && !y && a.preventDefault();\n        E(g, function (a) {\n          return l.normalize(a);\n        });\n        \"touchstart\" === a.type ? (A(g, function (a, b) {\n          t[b] = {\n            chartX: a.chartX,\n            chartY: a.chartY\n          };\n        }), k.x = [t[0].chartX, t[1] && t[1].chartX], k.y = [t[0].chartY, t[1] && t[1].chartY], A(u.axes, function (a) {\n          if (a.zoomEnabled) {\n            var b = u.bounds[a.horiz ? \"h\" : \"v\"],\n                e = a.minPixelPadding,\n                d = a.toPixels(f(a.options.min, a.dataMin)),\n                g = a.toPixels(f(a.options.max, a.dataMax)),\n                k = Math.max(d, g);\n            b.min = Math.min(a.pos, Math.min(d, g) - e);\n            b.max = Math.max(a.pos + a.len, k + e);\n          }\n        }), l.res = !0) : l.followTouchMove && 1 === d ? this.runPointActions(l.normalize(a)) : t.length && (e || (l.selectionMarker = e = F({\n          destroy: m,\n          touch: !0\n        }, u.plotBox)), l.pinchTranslate(t, g, v, e, n, k), l.hasPinched = b, l.scaleGroups(v, n), l.res && (l.res = !1, this.reset(!1, 0)));\n      },\n      touch: function touch(l, m) {\n        var r = this.chart,\n            t,\n            g;\n        if (r.index !== a.hoverChartIndex) this.onContainerMouseLeave({\n          relatedTarget: !0\n        });\n        a.hoverChartIndex = r.index;\n        1 === l.touches.length ? (l = this.normalize(l), (g = r.isInsidePlot(l.chartX - r.plotLeft, l.chartY - r.plotTop)) && !r.openMenu ? (m && this.runPointActions(l), \"touchmove\" === l.type && (m = this.pinchDown, t = m[0] ? 4 <= Math.sqrt(Math.pow(m[0].chartX - l.chartX, 2) + Math.pow(m[0].chartY - l.chartY, 2)) : !1), f(t, !0) && this.pinch(l)) : m && this.reset()) : 2 === l.touches.length && this.pinch(l);\n      },\n      onContainerTouchStart: function onContainerTouchStart(a) {\n        this.zoomOption(a);\n        this.touch(a, !0);\n      },\n      onContainerTouchMove: function onContainerTouchMove(a) {\n        this.touch(a);\n      },\n      onDocumentTouchEnd: function onDocumentTouchEnd(f) {\n        C[a.hoverChartIndex] && C[a.hoverChartIndex].pointer.drop(f);\n      }\n    });\n  })(M);\n\n  (function (a) {\n    var C = a.addEvent,\n        A = a.charts,\n        F = a.css,\n        E = a.doc,\n        m = a.extend,\n        f = a.noop,\n        l = a.Pointer,\n        r = a.removeEvent,\n        u = a.win,\n        t = a.wrap;\n\n    if (!a.hasTouch && (u.PointerEvent || u.MSPointerEvent)) {\n      var g = {},\n          d = !!u.PointerEvent,\n          k = function k() {\n        var b = [];\n\n        b.item = function (a) {\n          return this[a];\n        };\n\n        a.objectEach(g, function (a) {\n          b.push({\n            pageX: a.pageX,\n            pageY: a.pageY,\n            target: a.target\n          });\n        });\n        return b;\n      },\n          b = function b(_b, d, g, n) {\n        \"touch\" !== _b.pointerType && _b.pointerType !== _b.MSPOINTER_TYPE_TOUCH || !A[a.hoverChartIndex] || (n(_b), n = A[a.hoverChartIndex].pointer, n[d]({\n          type: g,\n          target: _b.currentTarget,\n          preventDefault: f,\n          touches: k()\n        }));\n      };\n\n      m(l.prototype, {\n        onContainerPointerDown: function onContainerPointerDown(a) {\n          b(a, \"onContainerTouchStart\", \"touchstart\", function (a) {\n            g[a.pointerId] = {\n              pageX: a.pageX,\n              pageY: a.pageY,\n              target: a.currentTarget\n            };\n          });\n        },\n        onContainerPointerMove: function onContainerPointerMove(a) {\n          b(a, \"onContainerTouchMove\", \"touchmove\", function (a) {\n            g[a.pointerId] = {\n              pageX: a.pageX,\n              pageY: a.pageY\n            };\n            g[a.pointerId].target || (g[a.pointerId].target = a.currentTarget);\n          });\n        },\n        onDocumentPointerUp: function onDocumentPointerUp(a) {\n          b(a, \"onDocumentTouchEnd\", \"touchend\", function (a) {\n            delete g[a.pointerId];\n          });\n        },\n        batchMSEvents: function batchMSEvents(a) {\n          a(this.chart.container, d ? \"pointerdown\" : \"MSPointerDown\", this.onContainerPointerDown);\n          a(this.chart.container, d ? \"pointermove\" : \"MSPointerMove\", this.onContainerPointerMove);\n          a(E, d ? \"pointerup\" : \"MSPointerUp\", this.onDocumentPointerUp);\n        }\n      });\n      t(l.prototype, \"init\", function (a, b, d) {\n        a.call(this, b, d);\n        this.hasZoom && F(b.container, {\n          \"-ms-touch-action\": \"none\",\n          \"touch-action\": \"none\"\n        });\n      });\n      t(l.prototype, \"setDOMEvents\", function (a) {\n        a.apply(this);\n        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(C);\n      });\n      t(l.prototype, \"destroy\", function (a) {\n        this.batchMSEvents(r);\n        a.call(this);\n      });\n    }\n  })(M);\n\n  (function (a) {\n    var C = a.addEvent,\n        A = a.css,\n        F = a.discardElement,\n        E = a.defined,\n        m = a.each,\n        f = a.isFirefox,\n        l = a.marginNames,\n        r = a.merge,\n        u = a.pick,\n        t = a.setAnimation,\n        g = a.stableSort,\n        d = a.win,\n        k = a.wrap;\n\n    a.Legend = function (a, e) {\n      this.init(a, e);\n    };\n\n    a.Legend.prototype = {\n      init: function init(a, e) {\n        this.chart = a;\n        this.setOptions(e);\n        e.enabled && (this.render(), C(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }));\n      },\n      setOptions: function setOptions(a) {\n        var b = u(a.padding, 8);\n        this.options = a;\n        this.itemStyle = a.itemStyle;\n        this.itemHiddenStyle = r(this.itemStyle, a.itemHiddenStyle);\n        this.itemMarginTop = a.itemMarginTop || 0;\n        this.padding = b;\n        this.initialItemY = b - 5;\n        this.itemHeight = this.maxItemWidth = 0;\n        this.symbolWidth = u(a.symbolWidth, 16);\n        this.pages = [];\n      },\n      update: function update(a, e) {\n        var b = this.chart;\n        this.setOptions(r(!0, this.options, a));\n        this.destroy();\n        b.isDirtyLegend = b.isDirtyBox = !0;\n        u(e, !0) && b.redraw();\n      },\n      colorizeItem: function colorizeItem(a, e) {\n        a.legendGroup[e ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n        var b = this.options,\n            d = a.legendItem,\n            g = a.legendLine,\n            f = a.legendSymbol,\n            k = this.itemHiddenStyle.color,\n            b = e ? b.itemStyle.color : k,\n            c = e ? a.color || k : k,\n            l = a.options && a.options.marker,\n            q = {\n          fill: c\n        };\n        d && d.css({\n          fill: b,\n          color: b\n        });\n        g && g.attr({\n          stroke: c\n        });\n        f && (l && f.isMarker && (q = a.pointAttribs(), e || (q.stroke = q.fill = k)), f.attr(q));\n      },\n      positionItem: function positionItem(a) {\n        var b = this.options,\n            d = b.symbolPadding,\n            b = !b.rtl,\n            g = a._legendItemPos,\n            f = g[0],\n            g = g[1],\n            k = a.checkbox;\n        (a = a.legendGroup) && a.element && a.translate(b ? f : this.legendWidth - f - 2 * d - 4, g);\n        k && (k.x = f, k.y = g);\n      },\n      destroyItem: function destroyItem(a) {\n        var b = a.checkbox;\n        m([\"legendItem\", \"legendLine\", \"legendSymbol\", \"legendGroup\"], function (b) {\n          a[b] && (a[b] = a[b].destroy());\n        });\n        b && F(a.checkbox);\n      },\n      destroy: function destroy() {\n        function a(a) {\n          this[a] && (this[a] = this[a].destroy());\n        }\n\n        m(this.getAllItems(), function (b) {\n          m([\"legendItem\", \"legendGroup\"], a, b);\n        });\n        m(\"clipRect up down pager nav box title group\".split(\" \"), a, this);\n        this.display = null;\n      },\n      positionCheckboxes: function positionCheckboxes(a) {\n        var b = this.group && this.group.alignAttr,\n            d,\n            g = this.clipHeight || this.legendHeight,\n            f = this.titleHeight;\n        b && (d = b.translateY, m(this.allItems, function (e) {\n          var k = e.checkbox,\n              c;\n          k && (c = d + f + k.y + (a || 0) + 3, A(k, {\n            left: b.translateX + e.checkboxOffset + k.x - 20 + \"px\",\n            top: c + \"px\",\n            display: c > d - 6 && c < d + g - 6 ? \"\" : \"none\"\n          }));\n        }));\n      },\n      renderTitle: function renderTitle() {\n        var a = this.options,\n            e = this.padding,\n            d = a.title,\n            g = 0;\n        d.text && (this.title || (this.title = this.chart.renderer.label(d.text, e - 3, e - 4, null, null, null, a.useHTML, null, \"legend-title\").attr({\n          zIndex: 1\n        }).css(d.style).add(this.group)), a = this.title.getBBox(), g = a.height, this.offsetWidth = a.width, this.contentGroup.attr({\n          translateY: g\n        }));\n        this.titleHeight = g;\n      },\n      setText: function setText(b) {\n        var e = this.options;\n        b.legendItem.attr({\n          text: e.labelFormat ? a.format(e.labelFormat, b) : e.labelFormatter.call(b)\n        });\n      },\n      renderItem: function renderItem(a) {\n        var b = this.chart,\n            d = b.renderer,\n            g = this.options,\n            f = \"horizontal\" === g.layout,\n            k = this.symbolWidth,\n            l = g.symbolPadding,\n            c = this.itemStyle,\n            m = this.itemHiddenStyle,\n            q = this.padding,\n            B = f ? u(g.itemDistance, 20) : 0,\n            t = !g.rtl,\n            p = g.width,\n            z = g.itemMarginBottom || 0,\n            I = this.itemMarginTop,\n            L = a.legendItem,\n            h = !a.series,\n            w = !h && a.series.drawLegendSymbol ? a.series : a,\n            P = w.options,\n            H = this.createCheckboxForItem && P && P.showCheckbox,\n            P = k + l + B + (H ? 20 : 0),\n            O = g.useHTML,\n            A = a.options.className;\n        L || (a.legendGroup = d.g(\"legend-item\").addClass(\"highcharts-\" + w.type + \"-series highcharts-color-\" + a.colorIndex + (A ? \" \" + A : \"\") + (h ? \" highcharts-series-\" + a.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), a.legendItem = L = d.text(\"\", t ? k + l : -l, this.baseline || 0, O).css(r(a.visible ? c : m)).attr({\n          align: t ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(a.legendGroup), this.baseline || (k = c.fontSize, this.fontMetrics = d.fontMetrics(k, L), this.baseline = this.fontMetrics.f + 3 + I, L.attr(\"y\", this.baseline)), this.symbolHeight = g.symbolHeight || this.fontMetrics.f, w.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, L, O), H && this.createCheckboxForItem(a));\n        this.colorizeItem(a, a.visible);\n        c.width || L.css({\n          width: (g.itemWidth || g.width || b.spacingBox.width) - P\n        });\n        this.setText(a);\n        d = L.getBBox();\n        c = a.checkboxOffset = g.itemWidth || a.legendItemWidth || d.width + P;\n        this.itemHeight = d = Math.round(a.legendItemHeight || d.height || this.symbolHeight);\n        f && this.itemX - q + c > (p || b.spacingBox.width - 2 * q - g.x) && (this.itemX = q, this.itemY += I + this.lastLineHeight + z, this.lastLineHeight = 0);\n        this.maxItemWidth = Math.max(this.maxItemWidth, c);\n        this.lastItemY = I + this.itemY + z;\n        this.lastLineHeight = Math.max(d, this.lastLineHeight);\n        a._legendItemPos = [this.itemX, this.itemY];\n        f ? this.itemX += c : (this.itemY += I + d + z, this.lastLineHeight = d);\n        this.offsetWidth = p || Math.max((f ? this.itemX - q - (a.checkbox ? 0 : B) : c) + q, this.offsetWidth);\n      },\n      getAllItems: function getAllItems() {\n        var a = [];\n        m(this.chart.series, function (b) {\n          var e = b && b.options;\n          b && u(e.showInLegend, E(e.linkedTo) ? !1 : void 0, !0) && (a = a.concat(b.legendItems || (\"point\" === e.legendType ? b.data : b)));\n        });\n        return a;\n      },\n      adjustMargins: function adjustMargins(a, e) {\n        var b = this.chart,\n            d = this.options,\n            g = d.align.charAt(0) + d.verticalAlign.charAt(0) + d.layout.charAt(0);\n        d.floating || m([/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/], function (f, k) {\n          f.test(g) && !E(a[k]) && (b[l[k]] = Math.max(b[l[k]], b.legend[(k + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][k] * d[k % 2 ? \"x\" : \"y\"] + u(d.margin, 12) + e[k]));\n        });\n      },\n      render: function render() {\n        var a = this,\n            e = a.chart,\n            d = e.renderer,\n            f = a.group,\n            k,\n            l,\n            t,\n            c,\n            u = a.box,\n            q = a.options,\n            B = a.padding;\n        a.itemX = B;\n        a.itemY = a.initialItemY;\n        a.offsetWidth = 0;\n        a.lastItemY = 0;\n        f || (a.group = f = d.g(\"legend\").attr({\n          zIndex: 7\n        }).add(), a.contentGroup = d.g().attr({\n          zIndex: 1\n        }).add(f), a.scrollGroup = d.g().add(a.contentGroup));\n        a.renderTitle();\n        k = a.getAllItems();\n        g(k, function (a, b) {\n          return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);\n        });\n        q.reversed && k.reverse();\n        a.allItems = k;\n        a.display = l = !!k.length;\n        a.lastLineHeight = 0;\n        m(k, function (b) {\n          a.renderItem(b);\n        });\n        t = (q.width || a.offsetWidth) + B;\n        c = a.lastItemY + a.lastLineHeight + a.titleHeight;\n        c = a.handleOverflow(c);\n        c += B;\n        u || (a.box = u = d.rect().addClass(\"highcharts-legend-box\").attr({\n          r: q.borderRadius\n        }).add(f), u.isNew = !0);\n        u.attr({\n          stroke: q.borderColor,\n          \"stroke-width\": q.borderWidth || 0,\n          fill: q.backgroundColor || \"none\"\n        }).shadow(q.shadow);\n        0 < t && 0 < c && (u[u.isNew ? \"attr\" : \"animate\"](u.crisp({\n          x: 0,\n          y: 0,\n          width: t,\n          height: c\n        }, u.strokeWidth())), u.isNew = !1);\n        u[l ? \"show\" : \"hide\"]();\n        a.legendWidth = t;\n        a.legendHeight = c;\n        m(k, function (b) {\n          a.positionItem(b);\n        });\n        l && f.align(r(q, {\n          width: t,\n          height: c\n        }), !0, \"spacingBox\");\n        e.isResizing || this.positionCheckboxes();\n      },\n      handleOverflow: function handleOverflow(a) {\n        var b = this,\n            d = this.chart,\n            g = d.renderer,\n            f = this.options,\n            k = f.y,\n            l = this.padding,\n            d = d.spacingBox.height + (\"top\" === f.verticalAlign ? -k : k) - l,\n            k = f.maxHeight,\n            c,\n            r = this.clipRect,\n            q = f.navigation,\n            B = u(q.animation, !0),\n            t = q.arrowSize || 12,\n            p = this.nav,\n            z = this.pages,\n            I,\n            L = this.allItems,\n            h = function h(a) {\n          \"number\" === typeof a ? r.attr({\n            height: a\n          }) : r && (b.clipRect = r.destroy(), b.contentGroup.clip());\n          b.contentGroup.div && (b.contentGroup.div.style.clip = a ? \"rect(\" + l + \"px,9999px,\" + (l + a) + \"px,0)\" : \"auto\");\n        };\n\n        \"horizontal\" !== f.layout || \"middle\" === f.verticalAlign || f.floating || (d /= 2);\n        k && (d = Math.min(d, k));\n        z.length = 0;\n        a > d && !1 !== q.enabled ? (this.clipHeight = c = Math.max(d - 20 - this.titleHeight - l, 0), this.currentPage = u(this.currentPage, 1), this.fullHeight = a, m(L, function (a, b) {\n          var e = a._legendItemPos[1];\n          a = Math.round(a.legendItem.getBBox().height);\n          var d = z.length;\n          if (!d || e - z[d - 1] > c && (I || e) !== z[d - 1]) z.push(I || e), d++;\n          b === L.length - 1 && e + a - z[d - 1] > c && z.push(e);\n          e !== I && (I = e);\n        }), r || (r = b.clipRect = g.clipRect(0, l, 9999, 0), b.contentGroup.clip(r)), h(c), p || (this.nav = p = g.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = g.symbol(\"triangle\", 0, 0, t, t).on(\"click\", function () {\n          b.scroll(-1, B);\n        }).add(p), this.pager = g.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\").css(q.style).add(p), this.down = g.symbol(\"triangle-down\", 0, 0, t, t).on(\"click\", function () {\n          b.scroll(1, B);\n        }).add(p)), b.scroll(0), a = d) : p && (h(), this.nav = p.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return a;\n      },\n      scroll: function scroll(a, e) {\n        var b = this.pages,\n            d = b.length;\n        a = this.currentPage + a;\n        var g = this.clipHeight,\n            f = this.options.navigation,\n            k = this.pager,\n            c = this.padding;\n        a > d && (a = d);\n        0 < a && (void 0 !== e && t(e, this.chart), this.nav.attr({\n          translateX: c,\n          translateY: g + this.padding + 7 + this.titleHeight,\n          visibility: \"visible\"\n        }), this.up.attr({\n          \"class\": 1 === a ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n        }), k.attr({\n          text: a + \"/\" + d\n        }), this.down.attr({\n          x: 18 + this.pager.getBBox().width,\n          \"class\": a === d ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n        }), this.up.attr({\n          fill: 1 === a ? f.inactiveColor : f.activeColor\n        }).css({\n          cursor: 1 === a ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: a === d ? f.inactiveColor : f.activeColor\n        }).css({\n          cursor: a === d ? \"default\" : \"pointer\"\n        }), e = -b[a - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: e\n        }), this.currentPage = a, this.positionCheckboxes(e));\n      }\n    };\n    a.LegendSymbolMixin = {\n      drawRectangle: function drawRectangle(a, e) {\n        var b = a.symbolHeight,\n            d = a.options.squareSymbol;\n        e.legendSymbol = this.chart.renderer.rect(d ? (a.symbolWidth - b) / 2 : 0, a.baseline - b + 1, d ? b : a.symbolWidth, b, u(a.options.symbolRadius, b / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(e.legendGroup);\n      },\n      drawLineMarker: function drawLineMarker(a) {\n        var b = this.options,\n            d = b.marker,\n            g = a.symbolWidth,\n            f = a.symbolHeight,\n            k = f / 2,\n            l = this.chart.renderer,\n            c = this.legendGroup;\n        a = a.baseline - Math.round(.3 * a.fontMetrics.b);\n        var m;\n        m = {\n          \"stroke-width\": b.lineWidth || 0\n        };\n        b.dashStyle && (m.dashstyle = b.dashStyle);\n        this.legendLine = l.path([\"M\", 0, a, \"L\", g, a]).addClass(\"highcharts-graph\").attr(m).add(c);\n        d && !1 !== d.enabled && (b = Math.min(u(d.radius, k), k), 0 === this.symbol.indexOf(\"url\") && (d = r(d, {\n          width: f,\n          height: f\n        }), b = 0), this.legendSymbol = d = l.symbol(this.symbol, g / 2 - b, a - b, 2 * b, 2 * b, d).addClass(\"highcharts-point\").add(c), d.isMarker = !0);\n      }\n    };\n    (/Trident\\/7\\.0/.test(d.navigator.userAgent) || f) && k(a.Legend.prototype, \"positionItem\", function (a, e) {\n      var b = this,\n          d = function d() {\n        e._legendItemPos && a.call(b, e);\n      };\n\n      d();\n      setTimeout(d);\n    });\n  })(M);\n\n  (function (a) {\n    var C = a.addEvent,\n        A = a.animate,\n        F = a.animObject,\n        E = a.attr,\n        m = a.doc,\n        f = a.Axis,\n        l = a.createElement,\n        r = a.defaultOptions,\n        u = a.discardElement,\n        t = a.charts,\n        g = a.css,\n        d = a.defined,\n        k = a.each,\n        b = a.extend,\n        e = a.find,\n        v = a.fireEvent,\n        y = a.getStyle,\n        n = a.grep,\n        D = a.isNumber,\n        J = a.isObject,\n        c = a.isString,\n        G = a.Legend,\n        q = a.marginNames,\n        B = a.merge,\n        K = a.objectEach,\n        p = a.Pointer,\n        z = a.pick,\n        I = a.pInt,\n        L = a.removeEvent,\n        h = a.seriesTypes,\n        w = a.splat,\n        P = a.svg,\n        H = a.syncTimeout,\n        O = a.win,\n        Q = a.Renderer,\n        R = a.Chart = function () {\n      this.getArgs.apply(this, arguments);\n    };\n\n    a.chart = function (a, b, c) {\n      return new R(a, b, c);\n    };\n\n    b(R.prototype, {\n      callbacks: [],\n      getArgs: function getArgs() {\n        var a = [].slice.call(arguments);\n        if (c(a[0]) || a[0].nodeName) this.renderTo = a.shift();\n        this.init(a[0], a[1]);\n      },\n      init: function init(b, c) {\n        var e,\n            d,\n            h = b.series,\n            p = b.plotOptions || {};\n        b.series = null;\n        e = B(r, b);\n\n        for (d in e.plotOptions) {\n          e.plotOptions[d].tooltip = p[d] && B(p[d].tooltip) || void 0;\n        }\n\n        e.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;\n        e.series = b.series = h;\n        this.userOptions = b;\n        b = e.chart;\n        d = b.events;\n        this.margin = [];\n        this.spacing = [];\n        this.bounds = {\n          h: {},\n          v: {}\n        };\n        this.callback = c;\n        this.isResizing = 0;\n        this.options = e;\n        this.axes = [];\n        this.series = [];\n        this.hasCartesianSeries = b.showAxes;\n        var g = this;\n        g.index = t.length;\n        t.push(g);\n        a.chartCount++;\n        d && K(d, function (a, b) {\n          C(g, b, a);\n        });\n        g.xAxis = [];\n        g.yAxis = [];\n        g.pointCount = g.colorCounter = g.symbolCounter = 0;\n        g.firstRender();\n      },\n      initSeries: function initSeries(b) {\n        var c = this.options.chart;\n        (c = h[b.type || c.type || c.defaultSeriesType]) || a.error(17, !0);\n        c = new c();\n        c.init(this, b);\n        return c;\n      },\n      orderSeries: function orderSeries(a) {\n        var b = this.series;\n\n        for (a = a || 0; a < b.length; a++) {\n          b[a] && (b[a].index = a, b[a].name = b[a].name || \"Series \" + (b[a].index + 1));\n        }\n      },\n      isInsidePlot: function isInsidePlot(a, b, c) {\n        var e = c ? b : a;\n        a = c ? a : b;\n        return 0 <= e && e <= this.plotWidth && 0 <= a && a <= this.plotHeight;\n      },\n      redraw: function redraw(c) {\n        var e = this.axes,\n            d = this.series,\n            h = this.pointer,\n            p = this.legend,\n            g = this.isDirtyLegend,\n            f,\n            q,\n            l = this.hasCartesianSeries,\n            n = this.isDirtyBox,\n            z,\n            m = this.renderer,\n            x = m.isHidden(),\n            w = [];\n        this.setResponsive && this.setResponsive(!1);\n        a.setAnimation(c, this);\n        x && this.temporaryDisplay();\n        this.layOutTitles();\n\n        for (c = d.length; c--;) {\n          if (z = d[c], z.options.stacking && (f = !0, z.isDirty)) {\n            q = !0;\n            break;\n          }\n        }\n\n        if (q) for (c = d.length; c--;) {\n          z = d[c], z.options.stacking && (z.isDirty = !0);\n        }\n        k(d, function (a) {\n          a.isDirty && \"point\" === a.options.legendType && (a.updateTotals && a.updateTotals(), g = !0);\n          a.isDirtyData && v(a, \"updatedData\");\n        });\n        g && p.options.enabled && (p.render(), this.isDirtyLegend = !1);\n        f && this.getStacks();\n        l && k(e, function (a) {\n          a.updateNames();\n          a.setScale();\n        });\n        this.getMargins();\n        l && (k(e, function (a) {\n          a.isDirty && (n = !0);\n        }), k(e, function (a) {\n          var c = a.min + \",\" + a.max;\n          a.extKey !== c && (a.extKey = c, w.push(function () {\n            v(a, \"afterSetExtremes\", b(a.eventArgs, a.getExtremes()));\n            delete a.eventArgs;\n          }));\n          (n || f) && a.redraw();\n        }));\n        n && this.drawChartBox();\n        v(this, \"predraw\");\n        k(d, function (a) {\n          (n || a.isDirty) && a.visible && a.redraw();\n          a.isDirtyData = !1;\n        });\n        h && h.reset(!0);\n        m.draw();\n        v(this, \"redraw\");\n        v(this, \"render\");\n        x && this.temporaryDisplay(!0);\n        k(w, function (a) {\n          a.call();\n        });\n      },\n      get: function get(a) {\n        function b(b) {\n          return b.id === a || b.options && b.options.id === a;\n        }\n\n        var c,\n            d = this.series,\n            h;\n        c = e(this.axes, b) || e(this.series, b);\n\n        for (h = 0; !c && h < d.length; h++) {\n          c = e(d[h].points || [], b);\n        }\n\n        return c;\n      },\n      getAxes: function getAxes() {\n        var a = this,\n            b = this.options,\n            c = b.xAxis = w(b.xAxis || {}),\n            b = b.yAxis = w(b.yAxis || {});\n        k(c, function (a, b) {\n          a.index = b;\n          a.isX = !0;\n        });\n        k(b, function (a, b) {\n          a.index = b;\n        });\n        c = c.concat(b);\n        k(c, function (b) {\n          new f(a, b);\n        });\n      },\n      getSelectedPoints: function getSelectedPoints() {\n        var a = [];\n        k(this.series, function (b) {\n          a = a.concat(n(b.data || [], function (a) {\n            return a.selected;\n          }));\n        });\n        return a;\n      },\n      getSelectedSeries: function getSelectedSeries() {\n        return n(this.series, function (a) {\n          return a.selected;\n        });\n      },\n      setTitle: function setTitle(a, b, c) {\n        var e = this,\n            d = e.options,\n            h;\n        h = d.title = B({\n          style: {\n            color: \"#333333\",\n            fontSize: d.isStock ? \"16px\" : \"18px\"\n          }\n        }, d.title, a);\n        d = d.subtitle = B({\n          style: {\n            color: \"#666666\"\n          }\n        }, d.subtitle, b);\n        k([[\"title\", a, h], [\"subtitle\", b, d]], function (a, b) {\n          var c = a[0],\n              d = e[c],\n              h = a[1];\n          a = a[2];\n          d && h && (e[c] = d = d.destroy());\n          a && a.text && !d && (e[c] = e.renderer.text(a.text, 0, 0, a.useHTML).attr({\n            align: a.align,\n            \"class\": \"highcharts-\" + c,\n            zIndex: a.zIndex || 4\n          }).add(), e[c].update = function (a) {\n            e.setTitle(!b && a, b && a);\n          }, e[c].css(a.style));\n        });\n        e.layOutTitles(c);\n      },\n      layOutTitles: function layOutTitles(a) {\n        var c = 0,\n            e,\n            d = this.renderer,\n            h = this.spacingBox;\n        k([\"title\", \"subtitle\"], function (a) {\n          var e = this[a],\n              p = this.options[a];\n          a = \"title\" === a ? -3 : p.verticalAlign ? 0 : c + 2;\n          var g;\n          e && (g = p.style.fontSize, g = d.fontMetrics(g, e).b, e.css({\n            width: (p.width || h.width + p.widthAdjust) + \"px\"\n          }).align(b({\n            y: a + g\n          }, p), !1, \"spacingBox\"), p.floating || p.verticalAlign || (c = Math.ceil(c + e.getBBox(p.useHTML).height)));\n        }, this);\n        e = this.titleOffset !== c;\n        this.titleOffset = c;\n        !this.isDirtyBox && e && (this.isDirtyBox = e, this.hasRendered && z(a, !0) && this.isDirtyBox && this.redraw());\n      },\n      getChartSize: function getChartSize() {\n        var b = this.options.chart,\n            c = b.width,\n            b = b.height,\n            e = this.renderTo;\n        d(c) || (this.containerWidth = y(e, \"width\"));\n        d(b) || (this.containerHeight = y(e, \"height\"));\n        this.chartWidth = Math.max(0, c || this.containerWidth || 600);\n        this.chartHeight = Math.max(0, a.relativeLength(b, this.chartWidth) || this.containerHeight || 400);\n      },\n      temporaryDisplay: function temporaryDisplay(b) {\n        var c = this.renderTo;\n        if (b) for (; c && c.style;) {\n          c.hcOrigStyle && (a.css(c, c.hcOrigStyle), delete c.hcOrigStyle), c.hcOrigDetached && (m.body.removeChild(c), c.hcOrigDetached = !1), c = c.parentNode;\n        } else for (; c && c.style;) {\n          m.body.contains(c) || (c.hcOrigDetached = !0, m.body.appendChild(c));\n          if (\"none\" === y(c, \"display\", !1) || c.hcOricDetached) c.hcOrigStyle = {\n            display: c.style.display,\n            height: c.style.height,\n            overflow: c.style.overflow\n          }, b = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, c !== this.renderTo && (b.height = 0), a.css(c, b), c.offsetWidth || c.style.setProperty(\"display\", \"block\", \"important\");\n          c = c.parentNode;\n          if (c === m.body) break;\n        }\n      },\n      setClassName: function setClassName(a) {\n        this.container.className = \"highcharts-container \" + (a || \"\");\n      },\n      getContainer: function getContainer() {\n        var e,\n            d = this.options,\n            h = d.chart,\n            p,\n            g;\n        e = this.renderTo;\n        var f = a.uniqueKey(),\n            k;\n        e || (this.renderTo = e = h.renderTo);\n        c(e) && (this.renderTo = e = m.getElementById(e));\n        e || a.error(13, !0);\n        p = I(E(e, \"data-highcharts-chart\"));\n        D(p) && t[p] && t[p].hasRendered && t[p].destroy();\n        E(e, \"data-highcharts-chart\", this.index);\n        e.innerHTML = \"\";\n        h.skipClone || e.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        p = this.chartWidth;\n        g = this.chartHeight;\n        k = b({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: p + \"px\",\n          height: g + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\"\n        }, h.style);\n        this.container = e = l(\"div\", {\n          id: f\n        }, k, e);\n        this._cursor = e.style.cursor;\n        this.renderer = new (a[h.renderer] || Q)(e, p, g, null, h.forExport, d.exporting && d.exporting.allowHTML);\n        this.setClassName(h.className);\n        this.renderer.setStyle(h.style);\n        this.renderer.chartIndex = this.index;\n      },\n      getMargins: function getMargins(a) {\n        var b = this.spacing,\n            c = this.margin,\n            e = this.titleOffset;\n        this.resetMargins();\n        e && !d(c[0]) && (this.plotTop = Math.max(this.plotTop, e + this.options.title.margin + b[0]));\n        this.legend.display && this.legend.adjustMargins(c, b);\n        this.extraMargin && (this[this.extraMargin.type] = (this[this.extraMargin.type] || 0) + this.extraMargin.value);\n        this.extraTopMargin && (this.plotTop += this.extraTopMargin);\n        a || this.getAxisMargins();\n      },\n      getAxisMargins: function getAxisMargins() {\n        var a = this,\n            b = a.axisOffset = [0, 0, 0, 0],\n            c = a.margin;\n        a.hasCartesianSeries && k(a.axes, function (a) {\n          a.visible && a.getOffset();\n        });\n        k(q, function (e, h) {\n          d(c[h]) || (a[e] += b[h]);\n        });\n        a.setChartSize();\n      },\n      reflow: function reflow(a) {\n        var b = this,\n            c = b.options.chart,\n            e = b.renderTo,\n            h = d(c.width) && d(c.height),\n            p = c.width || y(e, \"width\"),\n            c = c.height || y(e, \"height\"),\n            e = a ? a.target : O;\n\n        if (!h && !b.isPrinting && p && c && (e === O || e === m)) {\n          if (p !== b.containerWidth || c !== b.containerHeight) clearTimeout(b.reflowTimeout), b.reflowTimeout = H(function () {\n            b.container && b.setSize(void 0, void 0, !1);\n          }, a ? 100 : 0);\n          b.containerWidth = p;\n          b.containerHeight = c;\n        }\n      },\n      initReflow: function initReflow() {\n        var a = this,\n            b;\n        b = C(O, \"resize\", function (b) {\n          a.reflow(b);\n        });\n        C(a, \"destroy\", b);\n      },\n      setSize: function setSize(b, c, e) {\n        var d = this,\n            h = d.renderer;\n        d.isResizing += 1;\n        a.setAnimation(e, d);\n        d.oldChartHeight = d.chartHeight;\n        d.oldChartWidth = d.chartWidth;\n        void 0 !== b && (d.options.chart.width = b);\n        void 0 !== c && (d.options.chart.height = c);\n        d.getChartSize();\n        b = h.globalAnimation;\n        (b ? A : g)(d.container, {\n          width: d.chartWidth + \"px\",\n          height: d.chartHeight + \"px\"\n        }, b);\n        d.setChartSize(!0);\n        h.setSize(d.chartWidth, d.chartHeight, e);\n        k(d.axes, function (a) {\n          a.isDirty = !0;\n          a.setScale();\n        });\n        d.isDirtyLegend = !0;\n        d.isDirtyBox = !0;\n        d.layOutTitles();\n        d.getMargins();\n        d.redraw(e);\n        d.oldChartHeight = null;\n        v(d, \"resize\");\n        H(function () {\n          d && v(d, \"endResize\", null, function () {\n            --d.isResizing;\n          });\n        }, F(b).duration);\n      },\n      setChartSize: function setChartSize(a) {\n        function b(a) {\n          a = f[a] || 0;\n          return Math.max(m || a, a) / 2;\n        }\n\n        var c = this.inverted,\n            e = this.renderer,\n            d = this.chartWidth,\n            h = this.chartHeight,\n            p = this.options.chart,\n            g = this.spacing,\n            f = this.clipOffset,\n            q,\n            n,\n            l,\n            z,\n            m;\n        this.plotLeft = q = Math.round(this.plotLeft);\n        this.plotTop = n = Math.round(this.plotTop);\n        this.plotWidth = l = Math.max(0, Math.round(d - q - this.marginRight));\n        this.plotHeight = z = Math.max(0, Math.round(h - n - this.marginBottom));\n        this.plotSizeX = c ? z : l;\n        this.plotSizeY = c ? l : z;\n        this.plotBorderWidth = p.plotBorderWidth || 0;\n        this.spacingBox = e.spacingBox = {\n          x: g[3],\n          y: g[0],\n          width: d - g[3] - g[1],\n          height: h - g[0] - g[2]\n        };\n        this.plotBox = e.plotBox = {\n          x: q,\n          y: n,\n          width: l,\n          height: z\n        };\n        m = 2 * Math.floor(this.plotBorderWidth / 2);\n        c = Math.ceil(b(3));\n        e = Math.ceil(b(0));\n        this.clipBox = {\n          x: c,\n          y: e,\n          width: Math.floor(this.plotSizeX - b(1) - c),\n          height: Math.max(0, Math.floor(this.plotSizeY - b(2) - e))\n        };\n        a || k(this.axes, function (a) {\n          a.setAxisSize();\n          a.setAxisTranslation();\n        });\n      },\n      resetMargins: function resetMargins() {\n        var a = this,\n            b = a.options.chart;\n        k([\"margin\", \"spacing\"], function (c) {\n          var e = b[c],\n              d = J(e) ? e : [e, e, e, e];\n          k([\"Top\", \"Right\", \"Bottom\", \"Left\"], function (e, h) {\n            a[c][h] = z(b[c + e], d[h]);\n          });\n        });\n        k(q, function (b, c) {\n          a[b] = z(a.margin[c], a.spacing[c]);\n        });\n        a.axisOffset = [0, 0, 0, 0];\n        a.clipOffset = [];\n      },\n      drawChartBox: function drawChartBox() {\n        var a = this.options.chart,\n            b = this.renderer,\n            c = this.chartWidth,\n            e = this.chartHeight,\n            d = this.chartBackground,\n            h = this.plotBackground,\n            p = this.plotBorder,\n            g,\n            f = this.plotBGImage,\n            k = a.backgroundColor,\n            q = a.plotBackgroundColor,\n            l = a.plotBackgroundImage,\n            n,\n            z = this.plotLeft,\n            m = this.plotTop,\n            w = this.plotWidth,\n            I = this.plotHeight,\n            v = this.plotBox,\n            r = this.clipRect,\n            B = this.clipBox,\n            y = \"animate\";\n        d || (this.chartBackground = d = b.rect().addClass(\"highcharts-background\").add(), y = \"attr\");\n        g = a.borderWidth || 0;\n        n = g + (a.shadow ? 8 : 0);\n        k = {\n          fill: k || \"none\"\n        };\n        if (g || d[\"stroke-width\"]) k.stroke = a.borderColor, k[\"stroke-width\"] = g;\n        d.attr(k).shadow(a.shadow);\n        d[y]({\n          x: n / 2,\n          y: n / 2,\n          width: c - n - g % 2,\n          height: e - n - g % 2,\n          r: a.borderRadius\n        });\n        y = \"animate\";\n        h || (y = \"attr\", this.plotBackground = h = b.rect().addClass(\"highcharts-plot-background\").add());\n        h[y](v);\n        h.attr({\n          fill: q || \"none\"\n        }).shadow(a.plotShadow);\n        l && (f ? f.animate(v) : this.plotBGImage = b.image(l, z, m, w, I).add());\n        r ? r.animate({\n          width: B.width,\n          height: B.height\n        }) : this.clipRect = b.clipRect(B);\n        y = \"animate\";\n        p || (y = \"attr\", this.plotBorder = p = b.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        p.attr({\n          stroke: a.plotBorderColor,\n          \"stroke-width\": a.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        p[y](p.crisp({\n          x: z,\n          y: m,\n          width: w,\n          height: I\n        }, -p.strokeWidth()));\n        this.isDirtyBox = !1;\n      },\n      propFromSeries: function propFromSeries() {\n        var a = this,\n            b = a.options.chart,\n            c,\n            e = a.options.series,\n            d,\n            p;\n        k([\"inverted\", \"angular\", \"polar\"], function (g) {\n          c = h[b.type || b.defaultSeriesType];\n          p = b[g] || c && c.prototype[g];\n\n          for (d = e && e.length; !p && d--;) {\n            (c = h[e[d].type]) && c.prototype[g] && (p = !0);\n          }\n\n          a[g] = p;\n        });\n      },\n      linkSeries: function linkSeries() {\n        var a = this,\n            b = a.series;\n        k(b, function (a) {\n          a.linkedSeries.length = 0;\n        });\n        k(b, function (b) {\n          var e = b.options.linkedTo;\n          c(e) && (e = \":previous\" === e ? a.series[b.index - 1] : a.get(e)) && e.linkedParent !== b && (e.linkedSeries.push(b), b.linkedParent = e, b.visible = z(b.options.visible, e.options.visible, b.visible));\n        });\n      },\n      renderSeries: function renderSeries() {\n        k(this.series, function (a) {\n          a.translate();\n          a.render();\n        });\n      },\n      renderLabels: function renderLabels() {\n        var a = this,\n            c = a.options.labels;\n        c.items && k(c.items, function (e) {\n          var d = b(c.style, e.style),\n              h = I(d.left) + a.plotLeft,\n              p = I(d.top) + a.plotTop + 12;\n          delete d.left;\n          delete d.top;\n          a.renderer.text(e.html, h, p).attr({\n            zIndex: 2\n          }).css(d).add();\n        });\n      },\n      render: function render() {\n        var a = this.axes,\n            b = this.renderer,\n            c = this.options,\n            e,\n            d,\n            h;\n        this.setTitle();\n        this.legend = new G(this, c.legend);\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        c = this.plotWidth;\n        e = this.plotHeight -= 21;\n        k(a, function (a) {\n          a.setScale();\n        });\n        this.getAxisMargins();\n        d = 1.1 < c / this.plotWidth;\n        h = 1.05 < e / this.plotHeight;\n        if (d || h) k(a, function (a) {\n          (a.horiz && d || !a.horiz && h) && a.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries && k(a, function (a) {\n          a.visible && a.render();\n        });\n        this.seriesGroup || (this.seriesGroup = b.g(\"series-group\").attr({\n          zIndex: 3\n        }).add());\n        this.renderSeries();\n        this.renderLabels();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.hasRendered = !0;\n      },\n      addCredits: function addCredits(a) {\n        var b = this;\n        a = B(!0, this.options.credits, a);\n        a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          a.href && (O.location.href = a.href);\n        }).attr({\n          align: a.position.align,\n          zIndex: 8\n        }).css(a.style).add().align(a.position), this.credits.update = function (a) {\n          b.credits = b.credits.destroy();\n          b.addCredits(a);\n        });\n      },\n      destroy: function destroy() {\n        var b = this,\n            c = b.axes,\n            e = b.series,\n            d = b.container,\n            h,\n            p = d && d.parentNode;\n        v(b, \"destroy\");\n        b.renderer.forExport ? a.erase(t, b) : t[b.index] = void 0;\n        a.chartCount--;\n        b.renderTo.removeAttribute(\"data-highcharts-chart\");\n        L(b);\n\n        for (h = c.length; h--;) {\n          c[h] = c[h].destroy();\n        }\n\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n\n        for (h = e.length; h--;) {\n          e[h] = e[h].destroy();\n        }\n\n        k(\"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \"), function (a) {\n          var c = b[a];\n          c && c.destroy && (b[a] = c.destroy());\n        });\n        d && (d.innerHTML = \"\", L(d), p && u(d));\n        K(b, function (a, c) {\n          delete b[c];\n        });\n      },\n      isReadyToRender: function isReadyToRender() {\n        var a = this;\n        return P || O != O.top || \"complete\" === m.readyState ? !0 : (m.attachEvent(\"onreadystatechange\", function () {\n          m.detachEvent(\"onreadystatechange\", a.firstRender);\n          \"complete\" === m.readyState && a.firstRender();\n        }), !1);\n      },\n      firstRender: function firstRender() {\n        var a = this,\n            b = a.options;\n\n        if (a.isReadyToRender()) {\n          a.getContainer();\n          v(a, \"init\");\n          a.resetMargins();\n          a.setChartSize();\n          a.propFromSeries();\n          a.getAxes();\n          k(b.series || [], function (b) {\n            a.initSeries(b);\n          });\n          a.linkSeries();\n          v(a, \"beforeRender\");\n          p && (a.pointer = new p(a, b));\n          a.render();\n          if (!a.renderer.imgCount && a.onload) a.onload();\n          a.temporaryDisplay(!0);\n        }\n      },\n      onload: function onload() {\n        k([this.callback].concat(this.callbacks), function (a) {\n          a && void 0 !== this.index && a.apply(this, [this]);\n        }, this);\n        v(this, \"load\");\n        v(this, \"render\");\n        d(this.index) && !1 !== this.options.chart.reflow && this.initReflow();\n        this.onload = null;\n      }\n    });\n  })(M);\n\n  (function (a) {\n    var C,\n        A = a.each,\n        F = a.extend,\n        E = a.erase,\n        m = a.fireEvent,\n        f = a.format,\n        l = a.isArray,\n        r = a.isNumber,\n        u = a.pick,\n        t = a.removeEvent;\n\n    a.Point = C = function C() {};\n\n    a.Point.prototype = {\n      init: function init(a, d, f) {\n        this.series = a;\n        this.color = a.color;\n        this.applyOptions(d, f);\n        a.options.colorByPoint ? (d = a.options.colors || a.chart.options.colors, this.color = this.color || d[a.colorCounter], d = d.length, f = a.colorCounter, a.colorCounter++, a.colorCounter === d && (a.colorCounter = 0)) : f = a.colorIndex;\n        this.colorIndex = u(this.colorIndex, f);\n        a.chart.pointCount++;\n        return this;\n      },\n      applyOptions: function applyOptions(a, d) {\n        var g = this.series,\n            b = g.options.pointValKey || g.pointValKey;\n        a = C.prototype.optionsToObject.call(this, a);\n        F(this, a);\n        this.options = this.options ? F(this.options, a) : a;\n        a.group && delete this.group;\n        b && (this.y = this[b]);\n        this.isNull = u(this.isValid && !this.isValid(), null === this.x || !r(this.y, !0));\n        this.selected && (this.state = \"select\");\n        \"name\" in this && void 0 === d && g.xAxis && g.xAxis.hasNames && (this.x = g.xAxis.nameToX(this));\n        void 0 === this.x && g && (this.x = void 0 === d ? g.autoIncrement(this) : d);\n        return this;\n      },\n      optionsToObject: function optionsToObject(a) {\n        var d = {},\n            g = this.series,\n            b = g.options.keys,\n            e = b || g.pointArrayMap || [\"y\"],\n            f = e.length,\n            m = 0,\n            n = 0;\n        if (r(a) || null === a) d[e[0]] = a;else if (l(a)) for (!b && a.length > f && (g = typeof a[0], \"string\" === g ? d.name = a[0] : \"number\" === g && (d.x = a[0]), m++); n < f;) {\n          b && void 0 === a[m] || (d[e[n]] = a[m]), m++, n++;\n        } else \"object\" === typeof a && (d = a, a.dataLabels && (g._hasPointLabels = !0), a.marker && (g._hasPointMarkers = !0));\n        return d;\n      },\n      getClassName: function getClassName() {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (void 0 !== this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      },\n      getZone: function getZone() {\n        var a = this.series,\n            d = a.zones,\n            a = a.zoneAxis || \"y\",\n            f = 0,\n            b;\n\n        for (b = d[f]; this[a] >= b.value;) {\n          b = d[++f];\n        }\n\n        b && b.color && !this.options.color && (this.color = b.color);\n        return b;\n      },\n      destroy: function destroy() {\n        var a = this.series.chart,\n            d = a.hoverPoints,\n            f;\n        a.pointCount--;\n        d && (this.setState(), E(d, this), d.length || (a.hoverPoints = null));\n        if (this === a.hoverPoint) this.onMouseOut();\n        if (this.graphic || this.dataLabel) t(this), this.destroyElements();\n        this.legendItem && a.legend.destroyItem(this);\n\n        for (f in this) {\n          this[f] = null;\n        }\n      },\n      destroyElements: function destroyElements() {\n        for (var a = [\"graphic\", \"dataLabel\", \"dataLabelUpper\", \"connector\", \"shadowGroup\"], d, f = 6; f--;) {\n          d = a[f], this[d] && (this[d] = this[d].destroy());\n        }\n      },\n      getLabelConfig: function getLabelConfig() {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      },\n      tooltipFormatter: function tooltipFormatter(a) {\n        var d = this.series,\n            g = d.tooltipOptions,\n            b = u(g.valueDecimals, \"\"),\n            e = g.valuePrefix || \"\",\n            l = g.valueSuffix || \"\";\n        A(d.pointArrayMap || [\"y\"], function (d) {\n          d = \"{point.\" + d;\n          if (e || l) a = a.replace(d + \"}\", e + d + \"}\" + l);\n          a = a.replace(d + \"}\", d + \":,.\" + b + \"f}\");\n        });\n        return f(a, {\n          point: this,\n          series: this.series\n        });\n      },\n      firePointEvent: function firePointEvent(a, d, f) {\n        var b = this,\n            e = this.series.options;\n        (e.point.events[a] || b.options && b.options.events && b.options.events[a]) && this.importEvents();\n        \"click\" === a && e.allowPointSelect && (f = function f(a) {\n          b.select && b.select(null, a.ctrlKey || a.metaKey || a.shiftKey);\n        });\n        m(this, a, d, f);\n      },\n      visible: !0\n    };\n  })(M);\n\n  (function (a) {\n    var C = a.addEvent,\n        A = a.animObject,\n        F = a.arrayMax,\n        E = a.arrayMin,\n        m = a.correctFloat,\n        f = a.Date,\n        l = a.defaultOptions,\n        r = a.defaultPlotOptions,\n        u = a.defined,\n        t = a.each,\n        g = a.erase,\n        d = a.extend,\n        k = a.fireEvent,\n        b = a.grep,\n        e = a.isArray,\n        v = a.isNumber,\n        y = a.isString,\n        n = a.merge,\n        D = a.objectEach,\n        J = a.pick,\n        c = a.removeEvent,\n        G = a.splat,\n        q = a.SVGElement,\n        B = a.syncTimeout,\n        K = a.win;\n    a.Series = a.seriesType(\"line\", null, {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      events: {},\n      marker: {\n        lineWidth: 0,\n        lineColor: \"#ffffff\",\n        radius: 4,\n        states: {\n          hover: {\n            animation: {\n              duration: 50\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        align: \"center\",\n        formatter: function formatter() {\n          return null === this.y ? \"\" : a.numberFormat(this.y, -1);\n        },\n        style: {\n          fontSize: \"11px\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        padding: 5\n      },\n      cropThreshold: 300,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        hover: {\n          animation: {\n            duration: 50\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          marker: {}\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    }, {\n      isCartesian: !0,\n      pointClass: a.Point,\n      sorted: !0,\n      requireSorting: !0,\n      directTouch: !1,\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      colorCounter: 0,\n      parallelArrays: [\"x\", \"y\"],\n      coll: \"series\",\n      init: function init(a, b) {\n        var c = this,\n            e,\n            h = a.series,\n            p;\n        c.chart = a;\n        c.options = b = c.setOptions(b);\n        c.linkedSeries = [];\n        c.bindAxes();\n        d(c, {\n          name: b.name,\n          state: \"\",\n          visible: !1 !== b.visible,\n          selected: !0 === b.selected\n        });\n        e = b.events;\n        D(e, function (a, b) {\n          C(c, b, a);\n        });\n        if (e && e.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0;\n        c.getColor();\n        c.getSymbol();\n        t(c.parallelArrays, function (a) {\n          c[a + \"Data\"] = [];\n        });\n        c.setData(b.data, !1);\n        c.isCartesian && (a.hasCartesianSeries = !0);\n        h.length && (p = h[h.length - 1]);\n        c._i = J(p && p._i, -1) + 1;\n        a.orderSeries(this.insert(h));\n      },\n      insert: function insert(a) {\n        var b = this.options.index,\n            c;\n\n        if (v(b)) {\n          for (c = a.length; c--;) {\n            if (b >= J(a[c].options.index, a[c]._i)) {\n              a.splice(c + 1, 0, this);\n              break;\n            }\n          }\n\n          -1 === c && a.unshift(this);\n          c += 1;\n        } else a.push(this);\n\n        return J(c, a.length - 1);\n      },\n      bindAxes: function bindAxes() {\n        var b = this,\n            c = b.options,\n            e = b.chart,\n            d;\n        t(b.axisTypes || [], function (h) {\n          t(e[h], function (a) {\n            d = a.options;\n            if (c[h] === d.index || void 0 !== c[h] && c[h] === d.id || void 0 === c[h] && 0 === d.index) b.insert(a.series), b[h] = a, a.isDirty = !0;\n          });\n          b[h] || b.optionalAxis === h || a.error(18, !0);\n        });\n      },\n      updateParallelArrays: function updateParallelArrays(a, b) {\n        var c = a.series,\n            e = arguments,\n            d = v(b) ? function (e) {\n          var d = \"y\" === e && c.toYData ? c.toYData(a) : a[e];\n          c[e + \"Data\"][b] = d;\n        } : function (a) {\n          Array.prototype[b].apply(c[a + \"Data\"], Array.prototype.slice.call(e, 2));\n        };\n        t(c.parallelArrays, d);\n      },\n      autoIncrement: function autoIncrement() {\n        var a = this.options,\n            b = this.xIncrement,\n            c,\n            e = a.pointIntervalUnit,\n            b = J(b, a.pointStart, 0);\n        this.pointInterval = c = J(this.pointInterval, a.pointInterval, 1);\n        e && (a = new f(b), \"day\" === e ? a = +a[f.hcSetDate](a[f.hcGetDate]() + c) : \"month\" === e ? a = +a[f.hcSetMonth](a[f.hcGetMonth]() + c) : \"year\" === e && (a = +a[f.hcSetFullYear](a[f.hcGetFullYear]() + c)), c = a - b);\n        this.xIncrement = b + c;\n        return b;\n      },\n      setOptions: function setOptions(a) {\n        var b = this.chart,\n            c = b.options,\n            e = c.plotOptions,\n            d = (b.userOptions || {}).plotOptions || {},\n            p = e[this.type];\n        this.userOptions = a;\n        b = n(p, e.series, a);\n        this.tooltipOptions = n(l.tooltip, l.plotOptions.series && l.plotOptions.series.tooltip, l.plotOptions[this.type].tooltip, c.tooltip.userOptions, e.series && e.series.tooltip, e[this.type].tooltip, a.tooltip);\n        this.stickyTracking = J(a.stickyTracking, d[this.type] && d[this.type].stickyTracking, d.series && d.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : b.stickyTracking);\n        null === p.marker && delete b.marker;\n        this.zoneAxis = b.zoneAxis;\n        a = this.zones = (b.zones || []).slice();\n        !b.negativeColor && !b.negativeFillColor || b.zones || a.push({\n          value: b[this.zoneAxis + \"Threshold\"] || b.threshold || 0,\n          className: \"highcharts-negative\",\n          color: b.negativeColor,\n          fillColor: b.negativeFillColor\n        });\n        a.length && u(a[a.length - 1].value) && a.push({\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        return b;\n      },\n      getCyclic: function getCyclic(a, b, c) {\n        var e,\n            d = this.chart,\n            p = this.userOptions,\n            f = a + \"Index\",\n            g = a + \"Counter\",\n            k = c ? c.length : J(d.options.chart[a + \"Count\"], d[a + \"Count\"]);\n        b || (e = J(p[f], p[\"_\" + f]), u(e) || (d.series.length || (d[g] = 0), p[\"_\" + f] = e = d[g] % k, d[g] += 1), c && (b = c[e]));\n        void 0 !== e && (this[f] = e);\n        this[a] = b;\n      },\n      getColor: function getColor() {\n        this.options.colorByPoint ? this.options.color = null : this.getCyclic(\"color\", this.options.color || r[this.type].color, this.chart.options.colors);\n      },\n      getSymbol: function getSymbol() {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawLineMarker,\n      setData: function setData(b, c, d, f) {\n        var h = this,\n            p = h.points,\n            g = p && p.length || 0,\n            k,\n            q = h.options,\n            l = h.chart,\n            n = null,\n            m = h.xAxis,\n            z = q.turboThreshold,\n            r = this.xData,\n            B = this.yData,\n            I = (k = h.pointArrayMap) && k.length;\n        b = b || [];\n        k = b.length;\n        c = J(c, !0);\n        if (!1 !== f && k && g === k && !h.cropped && !h.hasGroupedData && h.visible) t(b, function (a, b) {\n          p[b].update && a !== q.data[b] && p[b].update(a, !1, null, !1);\n        });else {\n          h.xIncrement = null;\n          h.colorCounter = 0;\n          t(this.parallelArrays, function (a) {\n            h[a + \"Data\"].length = 0;\n          });\n\n          if (z && k > z) {\n            for (d = 0; null === n && d < k;) {\n              n = b[d], d++;\n            }\n\n            if (v(n)) for (d = 0; d < k; d++) {\n              r[d] = this.autoIncrement(), B[d] = b[d];\n            } else if (e(n)) {\n              if (I) for (d = 0; d < k; d++) {\n                n = b[d], r[d] = n[0], B[d] = n.slice(1, I + 1);\n              } else for (d = 0; d < k; d++) {\n                n = b[d], r[d] = n[0], B[d] = n[1];\n              }\n            } else a.error(12);\n          } else for (d = 0; d < k; d++) {\n            void 0 !== b[d] && (n = {\n              series: h\n            }, h.pointClass.prototype.applyOptions.apply(n, [b[d]]), h.updateParallelArrays(n, d));\n          }\n\n          y(B[0]) && a.error(14, !0);\n          h.data = [];\n          h.options.data = h.userOptions.data = b;\n\n          for (d = g; d--;) {\n            p[d] && p[d].destroy && p[d].destroy();\n          }\n\n          m && (m.minRange = m.userMinRange);\n          h.isDirty = l.isDirtyBox = !0;\n          h.isDirtyData = !!p;\n          d = !1;\n        }\n        \"point\" === q.legendType && (this.processData(), this.generatePoints());\n        c && l.redraw(d);\n      },\n      processData: function processData(b) {\n        var c = this.xData,\n            e = this.yData,\n            d = c.length,\n            h;\n        h = 0;\n        var p,\n            f,\n            g = this.xAxis,\n            k,\n            q = this.options;\n        k = q.cropThreshold;\n        var n = this.getExtremesFromAll || q.getExtremesFromAll,\n            l = this.isCartesian,\n            q = g && g.val2lin,\n            m = g && g.isLog,\n            v,\n            r;\n        if (l && !this.isDirty && !g.isDirty && !this.yAxis.isDirty && !b) return !1;\n        g && (b = g.getExtremes(), v = b.min, r = b.max);\n        if (l && this.sorted && !n && (!k || d > k || this.forceCrop)) if (c[d - 1] < v || c[0] > r) c = [], e = [];else if (c[0] < v || c[d - 1] > r) h = this.cropData(this.xData, this.yData, v, r), c = h.xData, e = h.yData, h = h.start, p = !0;\n\n        for (k = c.length || 1; --k;) {\n          d = m ? q(c[k]) - q(c[k - 1]) : c[k] - c[k - 1], 0 < d && (void 0 === f || d < f) ? f = d : 0 > d && this.requireSorting && a.error(15);\n        }\n\n        this.cropped = p;\n        this.cropStart = h;\n        this.processedXData = c;\n        this.processedYData = e;\n        this.closestPointRange = f;\n      },\n      cropData: function cropData(a, b, c, e) {\n        var d = a.length,\n            p = 0,\n            g = d,\n            f = J(this.cropShoulder, 1),\n            k;\n\n        for (k = 0; k < d; k++) {\n          if (a[k] >= c) {\n            p = Math.max(0, k - f);\n            break;\n          }\n        }\n\n        for (c = k; c < d; c++) {\n          if (a[c] > e) {\n            g = c + f;\n            break;\n          }\n        }\n\n        return {\n          xData: a.slice(p, g),\n          yData: b.slice(p, g),\n          start: p,\n          end: g\n        };\n      },\n      generatePoints: function generatePoints() {\n        var a = this.options,\n            b = a.data,\n            c = this.data,\n            e,\n            d = this.processedXData,\n            g = this.processedYData,\n            f = this.pointClass,\n            k = d.length,\n            q = this.cropStart || 0,\n            n,\n            l = this.hasGroupedData,\n            a = a.keys,\n            m,\n            v = [],\n            r;\n        c || l || (c = [], c.length = b.length, c = this.data = c);\n        a && l && (this.options.keys = !1);\n\n        for (r = 0; r < k; r++) {\n          n = q + r, l ? (m = new f().init(this, [d[r]].concat(G(g[r]))), m.dataGroup = this.groupMap[r]) : (m = c[n]) || void 0 === b[n] || (c[n] = m = new f().init(this, b[n], d[r])), m && (m.index = n, v[r] = m);\n        }\n\n        this.options.keys = a;\n        if (c && (k !== (e = c.length) || l)) for (r = 0; r < e; r++) {\n          r !== q || l || (r += k), c[r] && (c[r].destroyElements(), c[r].plotX = void 0);\n        }\n        this.data = c;\n        this.points = v;\n      },\n      getExtremes: function getExtremes(a) {\n        var b = this.yAxis,\n            c = this.processedXData,\n            d,\n            h = [],\n            p = 0;\n        d = this.xAxis.getExtremes();\n        var g = d.min,\n            f = d.max,\n            k,\n            q,\n            n,\n            l;\n        a = a || this.stackedYData || this.processedYData || [];\n        d = a.length;\n\n        for (l = 0; l < d; l++) {\n          if (q = c[l], n = a[l], k = (v(n, !0) || e(n)) && (!b.positiveValuesOnly || n.length || 0 < n), q = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (c[l] || q) >= g && (c[l] || q) <= f, k && q) if (k = n.length) for (; k--;) {\n            null !== n[k] && (h[p++] = n[k]);\n          } else h[p++] = n;\n        }\n\n        this.dataMin = E(h);\n        this.dataMax = F(h);\n      },\n      translate: function translate() {\n        this.processedXData || this.processData();\n        this.generatePoints();\n        var a = this.options,\n            b = a.stacking,\n            c = this.xAxis,\n            e = c.categories,\n            d = this.yAxis,\n            g = this.points,\n            f = g.length,\n            k = !!this.modifyValue,\n            q = a.pointPlacement,\n            n = \"between\" === q || v(q),\n            l = a.threshold,\n            r = a.startFromThreshold ? l : 0,\n            B,\n            y,\n            t,\n            G,\n            D = Number.MAX_VALUE;\n        \"between\" === q && (q = .5);\n        v(q) && (q *= J(a.pointRange || c.pointRange));\n\n        for (a = 0; a < f; a++) {\n          var K = g[a],\n              A = K.x,\n              C = K.y;\n          y = K.low;\n          var E = b && d.stacks[(this.negStacks && C < (r ? 0 : l) ? \"-\" : \"\") + this.stackKey],\n              F;\n          d.positiveValuesOnly && null !== C && 0 >= C && (K.isNull = !0);\n          K.plotX = B = m(Math.min(Math.max(-1E5, c.translate(A, 0, 0, 0, 1, q, \"flags\" === this.type)), 1E5));\n          b && this.visible && !K.isNull && E && E[A] && (G = this.getStackIndicator(G, A, this.index), F = E[A], C = F.points[G.key], y = C[0], C = C[1], y === r && G.key === E[A].base && (y = J(l, d.min)), d.positiveValuesOnly && 0 >= y && (y = null), K.total = K.stackTotal = F.total, K.percentage = F.total && K.y / F.total * 100, K.stackY = C, F.setOffset(this.pointXOffset || 0, this.barW || 0));\n          K.yBottom = u(y) ? d.translate(y, 0, 1, 0, 1) : null;\n          k && (C = this.modifyValue(C, K));\n          K.plotY = y = \"number\" === typeof C && Infinity !== C ? Math.min(Math.max(-1E5, d.translate(C, 0, 1, 0, 1)), 1E5) : void 0;\n          K.isInside = void 0 !== y && 0 <= y && y <= d.len && 0 <= B && B <= c.len;\n          K.clientX = n ? m(c.translate(A, 0, 0, 0, 1, q)) : B;\n          K.negative = K.y < (l || 0);\n          K.category = e && void 0 !== e[K.x] ? e[K.x] : K.x;\n          K.isNull || (void 0 !== t && (D = Math.min(D, Math.abs(B - t))), t = B);\n          K.zone = this.zones.length && K.getZone();\n        }\n\n        this.closestPointRangePx = D;\n      },\n      getValidPoints: function getValidPoints(a, c) {\n        var e = this.chart;\n        return b(a || this.points || [], function (a) {\n          return c && !e.isInsidePlot(a.plotX, a.plotY, e.inverted) ? !1 : !a.isNull;\n        });\n      },\n      setClip: function setClip(a) {\n        var b = this.chart,\n            c = this.options,\n            e = b.renderer,\n            d = b.inverted,\n            p = this.clipBox,\n            g = p || b.clipBox,\n            f = this.sharedClipKey || [\"_sharedClip\", a && a.duration, a && a.easing, g.height, c.xAxis, c.yAxis].join(),\n            k = b[f],\n            q = b[f + \"m\"];\n        k || (a && (g.width = 0, b[f + \"m\"] = q = e.clipRect(-99, d ? -b.plotLeft : -b.plotTop, 99, d ? b.chartWidth : b.chartHeight)), b[f] = k = e.clipRect(g), k.count = {\n          length: 0\n        });\n        a && !k.count[this.index] && (k.count[this.index] = !0, k.count.length += 1);\n        !1 !== c.clip && (this.group.clip(a || p ? k : b.clipRect), this.markerGroup.clip(q), this.sharedClipKey = f);\n        a || (k.count[this.index] && (delete k.count[this.index], --k.count.length), 0 === k.count.length && f && b[f] && (p || (b[f] = b[f].destroy()), b[f + \"m\"] && (b[f + \"m\"] = b[f + \"m\"].destroy())));\n      },\n      animate: function animate(a) {\n        var b = this.chart,\n            c = A(this.options.animation),\n            e;\n        a ? this.setClip(c) : (e = this.sharedClipKey, (a = b[e]) && a.animate({\n          width: b.plotSizeX\n        }, c), b[e + \"m\"] && b[e + \"m\"].animate({\n          width: b.plotSizeX + 99\n        }, c), this.animate = null);\n      },\n      afterAnimate: function afterAnimate() {\n        this.setClip();\n        k(this, \"afterAnimate\");\n        this.finishedAnimating = !0;\n      },\n      drawPoints: function drawPoints() {\n        var a = this.points,\n            b = this.chart,\n            c,\n            e,\n            d,\n            f,\n            g = this.options.marker,\n            k,\n            q,\n            n,\n            l,\n            m = this[this.specialGroup] || this.markerGroup,\n            r = J(g.enabled, this.xAxis.isRadial ? !0 : null, this.closestPointRangePx >= 2 * g.radius);\n        if (!1 !== g.enabled || this._hasPointMarkers) for (e = 0; e < a.length; e++) {\n          d = a[e], c = d.plotY, f = d.graphic, k = d.marker || {}, q = !!d.marker, n = r && void 0 === k.enabled || k.enabled, l = d.isInside, n && v(c) && null !== d.y ? (c = J(k.symbol, this.symbol), d.hasImage = 0 === c.indexOf(\"url\"), n = this.markerAttribs(d, d.selected && \"select\"), f ? f[l ? \"show\" : \"hide\"](!0).animate(n) : l && (0 < n.width || d.hasImage) && (d.graphic = f = b.renderer.symbol(c, n.x, n.y, n.width, n.height, q ? k : g).add(m)), f && f.attr(this.pointAttribs(d, d.selected && \"select\")), f && f.addClass(d.getClassName(), !0)) : f && (d.graphic = f.destroy());\n        }\n      },\n      markerAttribs: function markerAttribs(a, b) {\n        var c = this.options.marker,\n            e = a.marker || {},\n            d = J(e.radius, c.radius);\n        b && (c = c.states[b], b = e.states && e.states[b], d = J(b && b.radius, c && c.radius, d + (c && c.radiusPlus || 0)));\n        a.hasImage && (d = 0);\n        a = {\n          x: Math.floor(a.plotX) - d,\n          y: a.plotY - d\n        };\n        d && (a.width = a.height = 2 * d);\n        return a;\n      },\n      pointAttribs: function pointAttribs(a, b) {\n        var c = this.options.marker,\n            e = a && a.options,\n            d = e && e.marker || {},\n            f = this.color,\n            g = e && e.color,\n            p = a && a.color,\n            e = J(d.lineWidth, c.lineWidth);\n        a = a && a.zone && a.zone.color;\n        f = g || a || p || f;\n        a = d.fillColor || c.fillColor || f;\n        f = d.lineColor || c.lineColor || f;\n        b && (c = c.states[b], b = d.states && d.states[b] || {}, e = J(b.lineWidth, c.lineWidth, e + J(b.lineWidthPlus, c.lineWidthPlus, 0)), a = b.fillColor || c.fillColor || a, f = b.lineColor || c.lineColor || f);\n        return {\n          stroke: f,\n          \"stroke-width\": e,\n          fill: a\n        };\n      },\n      destroy: function destroy() {\n        var a = this,\n            b = a.chart,\n            e = /AppleWebKit\\/533/.test(K.navigator.userAgent),\n            d,\n            h,\n            f = a.data || [],\n            n,\n            l;\n        k(a, \"destroy\");\n        c(a);\n        t(a.axisTypes || [], function (b) {\n          (l = a[b]) && l.series && (g(l.series, a), l.isDirty = l.forceRedraw = !0);\n        });\n        a.legendItem && a.chart.legend.destroyItem(a);\n\n        for (h = f.length; h--;) {\n          (n = f[h]) && n.destroy && n.destroy();\n        }\n\n        a.points = null;\n        clearTimeout(a.animationTimeout);\n        D(a, function (a, b) {\n          a instanceof q && !a.survive && (d = e && \"group\" === b ? \"hide\" : \"destroy\", a[d]());\n        });\n        b.hoverSeries === a && (b.hoverSeries = null);\n        g(b.series, a);\n        b.orderSeries();\n        D(a, function (b, c) {\n          delete a[c];\n        });\n      },\n      getGraphPath: function getGraphPath(a, b, c) {\n        var e = this,\n            d = e.options,\n            f = d.step,\n            g,\n            p = [],\n            k = [],\n            q;\n        a = a || e.points;\n        (g = a.reversed) && a.reverse();\n        (f = {\n          right: 1,\n          center: 2\n        }[f] || f && 3) && g && (f = 4 - f);\n        !d.connectNulls || b || c || (a = this.getValidPoints(a));\n        t(a, function (h, g) {\n          var n = h.plotX,\n              l = h.plotY,\n              m = a[g - 1];\n          (h.leftCliff || m && m.rightCliff) && !c && (q = !0);\n          h.isNull && !u(b) && 0 < g ? q = !d.connectNulls : h.isNull && !b ? q = !0 : (0 === g || q ? g = [\"M\", h.plotX, h.plotY] : e.getPointSpline ? g = e.getPointSpline(a, h, g) : f ? (g = 1 === f ? [\"L\", m.plotX, l] : 2 === f ? [\"L\", (m.plotX + n) / 2, m.plotY, \"L\", (m.plotX + n) / 2, l] : [\"L\", n, m.plotY], g.push(\"L\", n, l)) : g = [\"L\", n, l], k.push(h.x), f && k.push(h.x), p.push.apply(p, g), q = !1);\n        });\n        p.xMap = k;\n        return e.graphPath = p;\n      },\n      drawGraph: function drawGraph() {\n        var a = this,\n            b = this.options,\n            c = (this.gappedPath || this.getGraphPath).call(this),\n            e = [[\"graph\", \"highcharts-graph\", b.lineColor || this.color, b.dashStyle]];\n        t(this.zones, function (c, d) {\n          e.push([\"zone-graph-\" + d, \"highcharts-graph highcharts-zone-graph-\" + d + \" \" + (c.className || \"\"), c.color || a.color, c.dashStyle || b.dashStyle]);\n        });\n        t(e, function (e, d) {\n          var h = e[0],\n              f = a[h];\n          f ? (f.endX = c.xMap, f.animate({\n            d: c\n          })) : c.length && (a[h] = a.chart.renderer.path(c).addClass(e[1]).attr({\n            zIndex: 1\n          }).add(a.group), f = {\n            stroke: e[2],\n            \"stroke-width\": b.lineWidth,\n            fill: a.fillGraph && a.color || \"none\"\n          }, e[3] ? f.dashstyle = e[3] : \"square\" !== b.linecap && (f[\"stroke-linecap\"] = f[\"stroke-linejoin\"] = \"round\"), f = a[h].attr(f).shadow(2 > d && b.shadow));\n          f && (f.startX = c.xMap, f.isArea = c.isArea);\n        });\n      },\n      applyZones: function applyZones() {\n        var a = this,\n            b = this.chart,\n            c = b.renderer,\n            e = this.zones,\n            d,\n            f,\n            g = this.clips || [],\n            k,\n            q = this.graph,\n            n = this.area,\n            l = Math.max(b.chartWidth, b.chartHeight),\n            m = this[(this.zoneAxis || \"y\") + \"Axis\"],\n            r,\n            v,\n            B = b.inverted,\n            y,\n            u,\n            G,\n            D,\n            K = !1;\n        e.length && (q || n) && m && void 0 !== m.min && (v = m.reversed, y = m.horiz, q && q.hide(), n && n.hide(), r = m.getExtremes(), t(e, function (e, h) {\n          d = v ? y ? b.plotWidth : 0 : y ? 0 : m.toPixels(r.min);\n          d = Math.min(Math.max(J(f, d), 0), l);\n          f = Math.min(Math.max(Math.round(m.toPixels(J(e.value, r.max), !0)), 0), l);\n          K && (d = f = m.toPixels(r.max));\n          u = Math.abs(d - f);\n          G = Math.min(d, f);\n          D = Math.max(d, f);\n          m.isXAxis ? (k = {\n            x: B ? D : G,\n            y: 0,\n            width: u,\n            height: l\n          }, y || (k.x = b.plotHeight - k.x)) : (k = {\n            x: 0,\n            y: B ? D : G,\n            width: l,\n            height: u\n          }, y && (k.y = b.plotWidth - k.y));\n          B && c.isVML && (k = m.isXAxis ? {\n            x: 0,\n            y: v ? G : D,\n            height: k.width,\n            width: b.chartWidth\n          } : {\n            x: k.y - b.plotLeft - b.spacingBox.x,\n            y: 0,\n            width: k.height,\n            height: b.chartHeight\n          });\n          g[h] ? g[h].animate(k) : (g[h] = c.clipRect(k), q && a[\"zone-graph-\" + h].clip(g[h]), n && a[\"zone-area-\" + h].clip(g[h]));\n          K = e.value > r.max;\n        }), this.clips = g);\n      },\n      invertGroups: function invertGroups(a) {\n        function b() {\n          t([\"group\", \"markerGroup\"], function (b) {\n            c[b] && (e.renderer.isVML && c[b].attr({\n              width: c.yAxis.len,\n              height: c.xAxis.len\n            }), c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(a));\n          });\n        }\n\n        var c = this,\n            e = c.chart,\n            d;\n        c.xAxis && (d = C(e, \"resize\", b), C(c, \"destroy\", d), b(a), c.invertGroups = b);\n      },\n      plotGroup: function plotGroup(a, b, c, e, d) {\n        var h = this[a],\n            f = !h;\n        f && (this[a] = h = this.chart.renderer.g().attr({\n          zIndex: e || .1\n        }).add(d));\n        h.addClass(\"highcharts-\" + b + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series highcharts-color-\" + this.colorIndex + \" \" + (this.options.className || \"\"), !0);\n        h.attr({\n          visibility: c\n        })[f ? \"attr\" : \"animate\"](this.getPlotBox());\n        return h;\n      },\n      getPlotBox: function getPlotBox() {\n        var a = this.chart,\n            b = this.xAxis,\n            c = this.yAxis;\n        a.inverted && (b = c, c = this.xAxis);\n        return {\n          translateX: b ? b.left : a.plotLeft,\n          translateY: c ? c.top : a.plotTop,\n          scaleX: 1,\n          scaleY: 1\n        };\n      },\n      render: function render() {\n        var a = this,\n            b = a.chart,\n            c,\n            e = a.options,\n            d = !!a.animate && b.renderer.isSVG && A(e.animation).duration,\n            f = a.visible ? \"inherit\" : \"hidden\",\n            g = e.zIndex,\n            k = a.hasRendered,\n            q = b.seriesGroup,\n            n = b.inverted;\n        c = a.plotGroup(\"group\", \"series\", f, g, q);\n        a.markerGroup = a.plotGroup(\"markerGroup\", \"markers\", f, g, q);\n        d && a.animate(!0);\n        c.inverted = a.isCartesian ? n : !1;\n        a.drawGraph && (a.drawGraph(), a.applyZones());\n        a.drawDataLabels && a.drawDataLabels();\n        a.visible && a.drawPoints();\n        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();\n        a.invertGroups(n);\n        !1 === e.clip || a.sharedClipKey || k || c.clip(b.clipRect);\n        d && a.animate();\n        k || (a.animationTimeout = B(function () {\n          a.afterAnimate();\n        }, d));\n        a.isDirty = !1;\n        a.hasRendered = !0;\n      },\n      redraw: function redraw() {\n        var a = this.chart,\n            b = this.isDirty || this.isDirtyData,\n            c = this.group,\n            e = this.xAxis,\n            d = this.yAxis;\n        c && (a.inverted && c.attr({\n          width: a.plotWidth,\n          height: a.plotHeight\n        }), c.animate({\n          translateX: J(e && e.left, a.plotLeft),\n          translateY: J(d && d.top, a.plotTop)\n        }));\n        this.translate();\n        this.render();\n        b && delete this.kdTree;\n      },\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      searchPoint: function searchPoint(a, b) {\n        var c = this.xAxis,\n            e = this.yAxis,\n            d = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: d ? c.len - a.chartY + c.pos : a.chartX - c.pos,\n          plotY: d ? e.len - a.chartX + e.pos : a.chartY - e.pos\n        }, b);\n      },\n      buildKDTree: function buildKDTree() {\n        function a(c, e, d) {\n          var h, f;\n          if (f = c && c.length) return h = b.kdAxisArray[e % d], c.sort(function (a, b) {\n            return a[h] - b[h];\n          }), f = Math.floor(f / 2), {\n            point: c[f],\n            left: a(c.slice(0, f), e + 1, d),\n            right: a(c.slice(f + 1), e + 1, d)\n          };\n        }\n\n        this.buildingKdTree = !0;\n        var b = this,\n            c = -1 < b.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete b.kdTree;\n        B(function () {\n          b.kdTree = a(b.getValidPoints(null, !b.directTouch), c, c);\n          b.buildingKdTree = !1;\n        }, b.options.kdNow ? 0 : 1);\n      },\n      searchKDTree: function searchKDTree(a, b) {\n        function c(a, b, h, k) {\n          var p = b.point,\n              q = e.kdAxisArray[h % k],\n              n,\n              l,\n              m = p;\n          l = u(a[d]) && u(p[d]) ? Math.pow(a[d] - p[d], 2) : null;\n          n = u(a[f]) && u(p[f]) ? Math.pow(a[f] - p[f], 2) : null;\n          n = (l || 0) + (n || 0);\n          p.dist = u(n) ? Math.sqrt(n) : Number.MAX_VALUE;\n          p.distX = u(l) ? Math.sqrt(l) : Number.MAX_VALUE;\n          q = a[q] - p[q];\n          n = 0 > q ? \"left\" : \"right\";\n          l = 0 > q ? \"right\" : \"left\";\n          b[n] && (n = c(a, b[n], h + 1, k), m = n[g] < m[g] ? n : p);\n          b[l] && Math.sqrt(q * q) < m[g] && (a = c(a, b[l], h + 1, k), m = a[g] < m[g] ? a : m);\n          return m;\n        }\n\n        var e = this,\n            d = this.kdAxisArray[0],\n            f = this.kdAxisArray[1],\n            g = b ? \"distX\" : \"dist\";\n        b = -1 < e.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree();\n        if (this.kdTree) return c(a, this.kdTree, b, b);\n      }\n    });\n  })(M);\n\n  (function (a) {\n    var C = a.Axis,\n        A = a.Chart,\n        F = a.correctFloat,\n        E = a.defined,\n        m = a.destroyObjectProperties,\n        f = a.each,\n        l = a.format,\n        r = a.objectEach,\n        u = a.pick,\n        t = a.Series;\n\n    a.StackItem = function (a, d, f, b, e) {\n      var g = a.chart.inverted;\n      this.axis = a;\n      this.isNegative = f;\n      this.options = d;\n      this.x = b;\n      this.total = null;\n      this.points = {};\n      this.stack = e;\n      this.rightCliff = this.leftCliff = 0;\n      this.alignOptions = {\n        align: d.align || (g ? f ? \"left\" : \"right\" : \"center\"),\n        verticalAlign: d.verticalAlign || (g ? \"middle\" : f ? \"bottom\" : \"top\"),\n        y: u(d.y, g ? 4 : f ? 14 : -6),\n        x: u(d.x, g ? f ? -6 : 6 : 0)\n      };\n      this.textAlign = d.textAlign || (g ? f ? \"right\" : \"left\" : \"center\");\n    };\n\n    a.StackItem.prototype = {\n      destroy: function destroy() {\n        m(this, this.axis);\n      },\n      render: function render(a) {\n        var d = this.options,\n            f = d.format,\n            f = f ? l(f, this) : d.formatter.call(this);\n        this.label ? this.label.attr({\n          text: f,\n          visibility: \"hidden\"\n        }) : this.label = this.axis.chart.renderer.text(f, null, null, d.useHTML).css(d.style).attr({\n          align: this.textAlign,\n          rotation: d.rotation,\n          visibility: \"hidden\"\n        }).add(a);\n      },\n      setOffset: function setOffset(a, d) {\n        var f = this.axis,\n            b = f.chart,\n            e = f.translate(f.usePercentage ? 100 : this.total, 0, 0, 0, 1),\n            f = f.translate(0),\n            f = Math.abs(e - f);\n        a = b.xAxis[0].translate(this.x) + a;\n        e = this.getStackBox(b, this, a, e, d, f);\n        if (d = this.label) d.align(this.alignOptions, null, e), e = d.alignAttr, d[!1 === this.options.crop || b.isInsidePlot(e.x, e.y) ? \"show\" : \"hide\"](!0);\n      },\n      getStackBox: function getStackBox(a, d, f, b, e, l) {\n        var g = d.axis.reversed,\n            k = a.inverted;\n        a = a.plotHeight;\n        d = d.isNegative && !g || !d.isNegative && g;\n        return {\n          x: k ? d ? b : b - l : f,\n          y: k ? a - f - e : d ? a - b - l : a - b,\n          width: k ? l : e,\n          height: k ? e : l\n        };\n      }\n    };\n\n    A.prototype.getStacks = function () {\n      var a = this;\n      f(a.yAxis, function (a) {\n        a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks);\n      });\n      f(a.series, function (d) {\n        !d.options.stacking || !0 !== d.visible && !1 !== a.options.chart.ignoreHiddenSeries || (d.stackKey = d.type + u(d.options.stack, \"\"));\n      });\n    };\n\n    C.prototype.buildStacks = function () {\n      var a = this.series,\n          d = u(this.options.reversedStacks, !0),\n          f = a.length,\n          b;\n\n      if (!this.isXAxis) {\n        this.usePercentage = !1;\n\n        for (b = f; b--;) {\n          a[d ? b : f - b - 1].setStackedPoints();\n        }\n\n        if (this.usePercentage) for (b = 0; b < f; b++) {\n          a[b].setPercentStacks();\n        }\n      }\n    };\n\n    C.prototype.renderStackTotals = function () {\n      var a = this.chart,\n          d = a.renderer,\n          f = this.stacks,\n          b = this.stackTotalGroup;\n      b || (this.stackTotalGroup = b = d.g(\"stack-labels\").attr({\n        visibility: \"visible\",\n        zIndex: 6\n      }).add());\n      b.translate(a.plotLeft, a.plotTop);\n      r(f, function (a) {\n        r(a, function (a) {\n          a.render(b);\n        });\n      });\n    };\n\n    C.prototype.resetStacks = function () {\n      var a = this,\n          d = a.stacks;\n      a.isXAxis || r(d, function (d) {\n        r(d, function (b, e) {\n          b.touched < a.stacksTouched ? (b.destroy(), delete d[e]) : (b.total = null, b.cum = null);\n        });\n      });\n    };\n\n    C.prototype.cleanStacks = function () {\n      var a;\n      this.isXAxis || (this.oldStacks && (a = this.stacks = this.oldStacks), r(a, function (a) {\n        r(a, function (a) {\n          a.cum = a.total;\n        });\n      }));\n    };\n\n    t.prototype.setStackedPoints = function () {\n      if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {\n        var f = this.processedXData,\n            d = this.processedYData,\n            k = [],\n            b = d.length,\n            e = this.options,\n            l = e.threshold,\n            m = e.startFromThreshold ? l : 0,\n            n = e.stack,\n            e = e.stacking,\n            r = this.stackKey,\n            t = \"-\" + r,\n            c = this.negStacks,\n            G = this.yAxis,\n            q = G.stacks,\n            B = G.oldStacks,\n            K,\n            p,\n            z,\n            I,\n            A,\n            h,\n            w;\n        G.stacksTouched += 1;\n\n        for (A = 0; A < b; A++) {\n          h = f[A], w = d[A], K = this.getStackIndicator(K, h, this.index), I = K.key, z = (p = c && w < (m ? 0 : l)) ? t : r, q[z] || (q[z] = {}), q[z][h] || (B[z] && B[z][h] ? (q[z][h] = B[z][h], q[z][h].total = null) : q[z][h] = new a.StackItem(G, G.options.stackLabels, p, h, n)), z = q[z][h], null !== w && (z.points[I] = z.points[this.index] = [u(z.cum, m)], E(z.cum) || (z.base = I), z.touched = G.stacksTouched, 0 < K.index && !1 === this.singleStacks && (z.points[I][0] = z.points[this.index + \",\" + h + \",0\"][0])), \"percent\" === e ? (p = p ? r : t, c && q[p] && q[p][h] ? (p = q[p][h], z.total = p.total = Math.max(p.total, z.total) + Math.abs(w) || 0) : z.total = F(z.total + (Math.abs(w) || 0))) : z.total = F(z.total + (w || 0)), z.cum = u(z.cum, m) + (w || 0), null !== w && (z.points[I].push(z.cum), k[A] = z.cum);\n        }\n\n        \"percent\" === e && (G.usePercentage = !0);\n        this.stackedYData = k;\n        G.oldStacks = {};\n      }\n    };\n\n    t.prototype.setPercentStacks = function () {\n      var a = this,\n          d = a.stackKey,\n          k = a.yAxis.stacks,\n          b = a.processedXData,\n          e;\n      f([d, \"-\" + d], function (d) {\n        for (var f = b.length, g, l; f--;) {\n          if (g = b[f], e = a.getStackIndicator(e, g, a.index, d), g = (l = k[d] && k[d][g]) && l.points[e.key]) l = l.total ? 100 / l.total : 0, g[0] = F(g[0] * l), g[1] = F(g[1] * l), a.stackedYData[f] = g[1];\n        }\n      });\n    };\n\n    t.prototype.getStackIndicator = function (a, d, f, b) {\n      !E(a) || a.x !== d || b && a.key !== b ? a = {\n        x: d,\n        index: 0,\n        key: b\n      } : a.index++;\n      a.key = [f, d, a.index].join();\n      return a;\n    };\n  })(M);\n\n  (function (a) {\n    var C = a.addEvent,\n        A = a.animate,\n        F = a.Axis,\n        E = a.createElement,\n        m = a.css,\n        f = a.defined,\n        l = a.each,\n        r = a.erase,\n        u = a.extend,\n        t = a.fireEvent,\n        g = a.inArray,\n        d = a.isNumber,\n        k = a.isObject,\n        b = a.isArray,\n        e = a.merge,\n        v = a.objectEach,\n        y = a.pick,\n        n = a.Point,\n        D = a.Series,\n        J = a.seriesTypes,\n        c = a.setAnimation,\n        G = a.splat;\n    u(a.Chart.prototype, {\n      addSeries: function addSeries(a, b, c) {\n        var e,\n            d = this;\n        a && (b = y(b, !0), t(d, \"addSeries\", {\n          options: a\n        }, function () {\n          e = d.initSeries(a);\n          d.isDirtyLegend = !0;\n          d.linkSeries();\n          b && d.redraw(c);\n        }));\n        return e;\n      },\n      addAxis: function addAxis(a, b, c, d) {\n        var f = b ? \"xAxis\" : \"yAxis\",\n            g = this.options;\n        a = e(a, {\n          index: this[f].length,\n          isX: b\n        });\n        b = new F(this, a);\n        g[f] = G(g[f] || {});\n        g[f].push(a);\n        y(c, !0) && this.redraw(d);\n        return b;\n      },\n      showLoading: function showLoading(a) {\n        var b = this,\n            c = b.options,\n            e = b.loadingDiv,\n            d = c.loading,\n            f = function f() {\n          e && m(e, {\n            left: b.plotLeft + \"px\",\n            top: b.plotTop + \"px\",\n            width: b.plotWidth + \"px\",\n            height: b.plotHeight + \"px\"\n          });\n        };\n\n        e || (b.loadingDiv = e = E(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, b.container), b.loadingSpan = E(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, e), C(b, \"redraw\", f));\n        e.className = \"highcharts-loading\";\n        b.loadingSpan.innerHTML = a || c.lang.loading;\n        m(e, u(d.style, {\n          zIndex: 10\n        }));\n        m(b.loadingSpan, d.labelStyle);\n        b.loadingShown || (m(e, {\n          opacity: 0,\n          display: \"\"\n        }), A(e, {\n          opacity: d.style.opacity || .5\n        }, {\n          duration: d.showDuration || 0\n        }));\n        b.loadingShown = !0;\n        f();\n      },\n      hideLoading: function hideLoading() {\n        var a = this.options,\n            b = this.loadingDiv;\n        b && (b.className = \"highcharts-loading highcharts-loading-hidden\", A(b, {\n          opacity: 0\n        }, {\n          duration: a.loading.hideDuration || 100,\n          complete: function complete() {\n            m(b, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      },\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions tooltip\".split(\" \"),\n      update: function update(a, b, c) {\n        var k = this,\n            n = {\n          credits: \"addCredits\",\n          title: \"setTitle\",\n          subtitle: \"setSubtitle\"\n        },\n            q = a.chart,\n            m,\n            h,\n            r = [];\n\n        if (q) {\n          e(!0, k.options.chart, q);\n          \"className\" in q && k.setClassName(q.className);\n          if (\"inverted\" in q || \"polar\" in q) k.propFromSeries(), m = !0;\n          \"alignTicks\" in q && (m = !0);\n          v(q, function (a, b) {\n            -1 !== g(\"chart.\" + b, k.propsRequireUpdateSeries) && (h = !0);\n            -1 !== g(b, k.propsRequireDirtyBox) && (k.isDirtyBox = !0);\n          });\n          \"style\" in q && k.renderer.setStyle(q.style);\n        }\n\n        a.colors && (this.options.colors = a.colors);\n        a.plotOptions && e(!0, this.options.plotOptions, a.plotOptions);\n        v(a, function (a, b) {\n          if (k[b] && \"function\" === typeof k[b].update) k[b].update(a, !1);else if (\"function\" === typeof k[n[b]]) k[n[b]](a);\n          \"chart\" !== b && -1 !== g(b, k.propsRequireUpdateSeries) && (h = !0);\n        });\n        l(\"xAxis yAxis zAxis series colorAxis pane\".split(\" \"), function (b) {\n          a[b] && (l(G(a[b]), function (a, e) {\n            (e = f(a.id) && k.get(a.id) || k[b][e]) && e.coll === b && (e.update(a, !1), c && (e.touched = !0));\n            if (!e && c) if (\"series\" === b) k.addSeries(a, !1).touched = !0;else if (\"xAxis\" === b || \"yAxis\" === b) k.addAxis(a, \"xAxis\" === b, !1).touched = !0;\n          }), c && l(k[b], function (a) {\n            a.touched ? delete a.touched : r.push(a);\n          }));\n        });\n        l(r, function (a) {\n          a.remove(!1);\n        });\n        m && l(k.axes, function (a) {\n          a.update({}, !1);\n        });\n        h && l(k.series, function (a) {\n          a.update({}, !1);\n        });\n        a.loading && e(!0, k.options.loading, a.loading);\n        m = q && q.width;\n        q = q && q.height;\n        d(m) && m !== k.chartWidth || d(q) && q !== k.chartHeight ? k.setSize(m, q) : y(b, !0) && k.redraw();\n      },\n      setSubtitle: function setSubtitle(a) {\n        this.setTitle(void 0, a);\n      }\n    });\n    u(n.prototype, {\n      update: function update(a, b, c, e) {\n        function d() {\n          f.applyOptions(a);\n          null === f.y && h && (f.graphic = h.destroy());\n          k(a, !0) && (h && h.element && a && a.marker && void 0 !== a.marker.symbol && (f.graphic = h.destroy()), a && a.dataLabels && f.dataLabel && (f.dataLabel = f.dataLabel.destroy()));\n          p = f.index;\n          g.updateParallelArrays(f, p);\n          q.data[p] = k(q.data[p], !0) || k(a, !0) ? f.options : a;\n          g.isDirty = g.isDirtyData = !0;\n          !g.fixedBox && g.hasCartesianSeries && (l.isDirtyBox = !0);\n          \"point\" === q.legendType && (l.isDirtyLegend = !0);\n          b && l.redraw(c);\n        }\n\n        var f = this,\n            g = f.series,\n            h = f.graphic,\n            p,\n            l = g.chart,\n            q = g.options;\n        b = y(b, !0);\n        !1 === e ? d() : f.firePointEvent(\"update\", {\n          options: a\n        }, d);\n      },\n      remove: function remove(a, b) {\n        this.series.removePoint(g(this, this.series.data), a, b);\n      }\n    });\n    u(D.prototype, {\n      addPoint: function addPoint(a, b, c, e) {\n        var d = this.options,\n            f = this.data,\n            g = this.chart,\n            h = this.xAxis,\n            h = h && h.hasNames && h.names,\n            k = d.data,\n            p,\n            l,\n            q = this.xData,\n            n,\n            m;\n        b = y(b, !0);\n        p = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(p, [a]);\n        m = p.x;\n        n = q.length;\n        if (this.requireSorting && m < q[n - 1]) for (l = !0; n && q[n - 1] > m;) {\n          n--;\n        }\n        this.updateParallelArrays(p, \"splice\", n, 0, 0);\n        this.updateParallelArrays(p, n);\n        h && p.name && (h[m] = p.name);\n        k.splice(n, 0, a);\n        l && (this.data.splice(n, 0, null), this.processData());\n        \"point\" === d.legendType && this.generatePoints();\n        c && (f[0] && f[0].remove ? f[0].remove(!1) : (f.shift(), this.updateParallelArrays(p, \"shift\"), k.shift()));\n        this.isDirtyData = this.isDirty = !0;\n        b && g.redraw(e);\n      },\n      removePoint: function removePoint(a, b, e) {\n        var d = this,\n            f = d.data,\n            g = f[a],\n            k = d.points,\n            h = d.chart,\n            l = function l() {\n          k && k.length === f.length && k.splice(a, 1);\n          f.splice(a, 1);\n          d.options.data.splice(a, 1);\n          d.updateParallelArrays(g || {\n            series: d\n          }, \"splice\", a, 1);\n          g && g.destroy();\n          d.isDirty = !0;\n          d.isDirtyData = !0;\n          b && h.redraw();\n        };\n\n        c(e, h);\n        b = y(b, !0);\n        g ? g.firePointEvent(\"remove\", null, l) : l();\n      },\n      remove: function remove(a, b, c) {\n        function e() {\n          d.destroy();\n          f.isDirtyLegend = f.isDirtyBox = !0;\n          f.linkSeries();\n          y(a, !0) && f.redraw(b);\n        }\n\n        var d = this,\n            f = d.chart;\n        !1 !== c ? t(d, \"remove\", null, e) : e();\n      },\n      update: function update(a, b) {\n        var c = this,\n            d = c.chart,\n            f = c.userOptions,\n            g = c.oldType || c.type,\n            k = a.type || f.type || d.options.chart.type,\n            h = J[g].prototype,\n            n,\n            q = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"navigatorSeries\", \"baseSeries\"],\n            m = c.finishedAnimating && {\n          animation: !1\n        };\n        if (Object.keys && \"data\" === Object.keys(a).toString()) return this.setData(a.data, b);\n        if (k && k !== g || void 0 !== a.zIndex) q.length = 0;\n        l(q, function (a) {\n          q[a] = c[a];\n          delete c[a];\n        });\n        a = e(f, m, {\n          index: c.index,\n          pointStart: c.xData[0]\n        }, {\n          data: c.options.data\n        }, a);\n        c.remove(!1, null, !1);\n\n        for (n in h) {\n          c[n] = void 0;\n        }\n\n        u(c, J[k || g].prototype);\n        l(q, function (a) {\n          c[a] = q[a];\n        });\n        c.init(d, a);\n        c.oldType = g;\n        d.linkSeries();\n        y(b, !0) && d.redraw(!1);\n      }\n    });\n    u(F.prototype, {\n      update: function update(a, b) {\n        var c = this.chart;\n        a = c.options[this.coll][this.options.index] = e(this.userOptions, a);\n        this.destroy(!0);\n        this.init(c, u(a, {\n          events: void 0\n        }));\n        c.isDirtyBox = !0;\n        y(b, !0) && c.redraw();\n      },\n      remove: function remove(a) {\n        for (var c = this.chart, e = this.coll, d = this.series, f = d.length; f--;) {\n          d[f] && d[f].remove(!1);\n        }\n\n        r(c.axes, this);\n        r(c[e], this);\n        b(c.options[e]) ? c.options[e].splice(this.options.index, 1) : delete c.options[e];\n        l(c[e], function (a, b) {\n          a.options.index = b;\n        });\n        this.destroy();\n        c.isDirtyBox = !0;\n        y(a, !0) && c.redraw();\n      },\n      setTitle: function setTitle(a, b) {\n        this.update({\n          title: a\n        }, b);\n      },\n      setCategories: function setCategories(a, b) {\n        this.update({\n          categories: a\n        }, b);\n      }\n    });\n  })(M);\n\n  (function (a) {\n    var C = a.color,\n        A = a.each,\n        F = a.map,\n        E = a.pick,\n        m = a.Series,\n        f = a.seriesType;\n    f(\"area\", \"line\", {\n      softThreshold: !1,\n      threshold: 0\n    }, {\n      singleStacks: !1,\n      getStackPoints: function getStackPoints(f) {\n        var l = [],\n            m = [],\n            t = this.xAxis,\n            g = this.yAxis,\n            d = g.stacks[this.stackKey],\n            k = {},\n            b = this.index,\n            e = g.series,\n            v = e.length,\n            y,\n            n = E(g.options.reversedStacks, !0) ? 1 : -1,\n            D;\n        f = f || this.points;\n\n        if (this.options.stacking) {\n          for (D = 0; D < f.length; D++) {\n            k[f[D].x] = f[D];\n          }\n\n          a.objectEach(d, function (a, b) {\n            null !== a.total && m.push(b);\n          });\n          m.sort(function (a, b) {\n            return a - b;\n          });\n          y = F(e, function () {\n            return this.visible;\n          });\n          A(m, function (a, c) {\n            var e = 0,\n                f,\n                r;\n            if (k[a] && !k[a].isNull) l.push(k[a]), A([-1, 1], function (e) {\n              var g = 1 === e ? \"rightNull\" : \"leftNull\",\n                  l = 0,\n                  q = d[m[c + e]];\n              if (q) for (D = b; 0 <= D && D < v;) {\n                f = q.points[D], f || (D === b ? k[a][g] = !0 : y[D] && (r = d[a].points[D]) && (l -= r[1] - r[0])), D += n;\n              }\n              k[a][1 === e ? \"rightCliff\" : \"leftCliff\"] = l;\n            });else {\n              for (D = b; 0 <= D && D < v;) {\n                if (f = d[a].points[D]) {\n                  e = f[1];\n                  break;\n                }\n\n                D += n;\n              }\n\n              e = g.translate(e, 0, 1, 0, 1);\n              l.push({\n                isNull: !0,\n                plotX: t.translate(a, 0, 0, 0, 1),\n                x: a,\n                plotY: e,\n                yBottom: e\n              });\n            }\n          });\n        }\n\n        return l;\n      },\n      getGraphPath: function getGraphPath(a) {\n        var f = m.prototype.getGraphPath,\n            l = this.options,\n            t = l.stacking,\n            g = this.yAxis,\n            d,\n            k,\n            b = [],\n            e = [],\n            v = this.index,\n            y,\n            n = g.stacks[this.stackKey],\n            D = l.threshold,\n            A = g.getThreshold(l.threshold),\n            c,\n            l = l.connectNulls || \"percent\" === t,\n            G = function G(c, d, f) {\n          var k = a[c];\n          c = t && n[k.x].points[v];\n          var l = k[f + \"Null\"] || 0;\n          f = k[f + \"Cliff\"] || 0;\n          var q,\n              m,\n              k = !0;\n          f || l ? (q = (l ? c[0] : c[1]) + f, m = c[0] + f, k = !!l) : !t && a[d] && a[d].isNull && (q = m = D);\n          void 0 !== q && (e.push({\n            plotX: y,\n            plotY: null === q ? A : g.getThreshold(q),\n            isNull: k,\n            isCliff: !0\n          }), b.push({\n            plotX: y,\n            plotY: null === m ? A : g.getThreshold(m),\n            doCurve: !1\n          }));\n        };\n\n        a = a || this.points;\n        t && (a = this.getStackPoints(a));\n\n        for (d = 0; d < a.length; d++) {\n          if (k = a[d].isNull, y = E(a[d].rectPlotX, a[d].plotX), c = E(a[d].yBottom, A), !k || l) l || G(d, d - 1, \"left\"), k && !t && l || (e.push(a[d]), b.push({\n            x: d,\n            plotX: y,\n            plotY: c\n          })), l || G(d, d + 1, \"right\");\n        }\n\n        d = f.call(this, e, !0, !0);\n        b.reversed = !0;\n        k = f.call(this, b, !0, !0);\n        k.length && (k[0] = \"L\");\n        k = d.concat(k);\n        f = f.call(this, e, !1, l);\n        k.xMap = d.xMap;\n        this.areaPath = k;\n        return f;\n      },\n      drawGraph: function drawGraph() {\n        this.areaPath = [];\n        m.prototype.drawGraph.apply(this);\n        var a = this,\n            f = this.areaPath,\n            u = this.options,\n            t = [[\"area\", \"highcharts-area\", this.color, u.fillColor]];\n        A(this.zones, function (f, d) {\n          t.push([\"zone-area-\" + d, \"highcharts-area highcharts-zone-area-\" + d + \" \" + f.className, f.color || a.color, f.fillColor || u.fillColor]);\n        });\n        A(t, function (g) {\n          var d = g[0],\n              k = a[d];\n          k ? (k.endX = f.xMap, k.animate({\n            d: f\n          })) : (k = a[d] = a.chart.renderer.path(f).addClass(g[1]).attr({\n            fill: E(g[3], C(g[2]).setOpacity(E(u.fillOpacity, .75)).get()),\n            zIndex: 0\n          }).add(a.group), k.isArea = !0);\n          k.startX = f.xMap;\n          k.shiftUnit = u.step ? 2 : 1;\n        });\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle\n    });\n  })(M);\n\n  (function (a) {\n    var C = a.pick;\n    a = a.seriesType;\n    a(\"spline\", \"line\", {}, {\n      getPointSpline: function getPointSpline(a, F, E) {\n        var m = F.plotX,\n            f = F.plotY,\n            l = a[E - 1];\n        E = a[E + 1];\n        var r, u, t, g;\n\n        if (l && !l.isNull && !1 !== l.doCurve && !F.isCliff && E && !E.isNull && !1 !== E.doCurve && !F.isCliff) {\n          a = l.plotY;\n          t = E.plotX;\n          E = E.plotY;\n          var d = 0;\n          r = (1.5 * m + l.plotX) / 2.5;\n          u = (1.5 * f + a) / 2.5;\n          t = (1.5 * m + t) / 2.5;\n          g = (1.5 * f + E) / 2.5;\n          t !== r && (d = (g - u) * (t - m) / (t - r) + f - g);\n          u += d;\n          g += d;\n          u > a && u > f ? (u = Math.max(a, f), g = 2 * f - u) : u < a && u < f && (u = Math.min(a, f), g = 2 * f - u);\n          g > E && g > f ? (g = Math.max(E, f), u = 2 * f - g) : g < E && g < f && (g = Math.min(E, f), u = 2 * f - g);\n          F.rightContX = t;\n          F.rightContY = g;\n        }\n\n        F = [\"C\", C(l.rightContX, l.plotX), C(l.rightContY, l.plotY), C(r, m), C(u, f), m, f];\n        l.rightContX = l.rightContY = null;\n        return F;\n      }\n    });\n  })(M);\n\n  (function (a) {\n    var C = a.seriesTypes.area.prototype,\n        A = a.seriesType;\n    A(\"areaspline\", \"spline\", a.defaultPlotOptions.area, {\n      getStackPoints: C.getStackPoints,\n      getGraphPath: C.getGraphPath,\n      drawGraph: C.drawGraph,\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle\n    });\n  })(M);\n\n  (function (a) {\n    var C = a.animObject,\n        A = a.color,\n        F = a.each,\n        E = a.extend,\n        m = a.isNumber,\n        f = a.merge,\n        l = a.pick,\n        r = a.Series,\n        u = a.seriesType,\n        t = a.svg;\n    u(\"column\", \"line\", {\n      borderRadius: 0,\n      crisp: !0,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1,\n          shadow: !1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\",\n          shadow: !1\n        }\n      },\n      dataLabels: {\n        align: null,\n        verticalAlign: null,\n        y: null\n      },\n      softThreshold: !1,\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    }, {\n      cropShoulder: 0,\n      directTouch: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      negStacks: !0,\n      init: function init() {\n        r.prototype.init.apply(this, arguments);\n        var a = this,\n            d = a.chart;\n        d.hasRendered && F(d.series, function (d) {\n          d.type === a.type && (d.isDirty = !0);\n        });\n      },\n      getColumnMetrics: function getColumnMetrics() {\n        var a = this,\n            d = a.options,\n            f = a.xAxis,\n            b = a.yAxis,\n            e = f.reversed,\n            m,\n            r = {},\n            n = 0;\n        !1 === d.grouping ? n = 1 : F(a.chart.series, function (c) {\n          var e = c.options,\n              d = c.yAxis,\n              f;\n          c.type !== a.type || !c.visible && a.chart.options.chart.ignoreHiddenSeries || b.len !== d.len || b.pos !== d.pos || (e.stacking ? (m = c.stackKey, void 0 === r[m] && (r[m] = n++), f = r[m]) : !1 !== e.grouping && (f = n++), c.columnIndex = f);\n        });\n        var t = Math.min(Math.abs(f.transA) * (f.ordinalSlope || d.pointRange || f.closestPointRange || f.tickInterval || 1), f.len),\n            u = t * d.groupPadding,\n            c = (t - 2 * u) / (n || 1),\n            d = Math.min(d.maxPointWidth || f.len, l(d.pointWidth, c * (1 - 2 * d.pointPadding)));\n        a.columnMetrics = {\n          width: d,\n          offset: (c - d) / 2 + (u + ((a.columnIndex || 0) + (e ? 1 : 0)) * c - t / 2) * (e ? -1 : 1)\n        };\n        return a.columnMetrics;\n      },\n      crispCol: function crispCol(a, d, f, b) {\n        var e = this.chart,\n            g = this.borderWidth,\n            k = -(g % 2 ? .5 : 0),\n            g = g % 2 ? .5 : 1;\n        e.inverted && e.renderer.isVML && (g += 1);\n        this.options.crisp && (f = Math.round(a + f) + k, a = Math.round(a) + k, f -= a);\n        b = Math.round(d + b) + g;\n        k = .5 >= Math.abs(d) && .5 < b;\n        d = Math.round(d) + g;\n        b -= d;\n        k && b && (--d, b += 1);\n        return {\n          x: a,\n          y: d,\n          width: f,\n          height: b\n        };\n      },\n      translate: function translate() {\n        var a = this,\n            d = a.chart,\n            f = a.options,\n            b = a.dense = 2 > a.closestPointRange * a.xAxis.transA,\n            b = a.borderWidth = l(f.borderWidth, b ? 0 : 1),\n            e = a.yAxis,\n            m = a.translatedThreshold = e.getThreshold(f.threshold),\n            t = l(f.minPointLength, 5),\n            n = a.getColumnMetrics(),\n            u = n.width,\n            A = a.barW = Math.max(u, 1 + 2 * b),\n            c = a.pointXOffset = n.offset;\n        d.inverted && (m -= .5);\n        f.pointPadding && (A = Math.ceil(A));\n        r.prototype.translate.apply(a);\n        F(a.points, function (b) {\n          var f = l(b.yBottom, m),\n              g = 999 + Math.abs(f),\n              g = Math.min(Math.max(-g, b.plotY), e.len + g),\n              k = b.plotX + c,\n              n = A,\n              r = Math.min(g, f),\n              v,\n              y = Math.max(g, f) - r;\n          Math.abs(y) < t && t && (y = t, v = !e.reversed && !b.negative || e.reversed && b.negative, r = Math.abs(r - m) > t ? f - t : m - (v ? t : 0));\n          b.barX = k;\n          b.pointWidth = u;\n          b.tooltipPos = d.inverted ? [e.len + e.pos - d.plotLeft - g, a.xAxis.len - k - n / 2, y] : [k + n / 2, g + e.pos - d.plotTop, y];\n          b.shapeType = \"rect\";\n          b.shapeArgs = a.crispCol.apply(a, b.isNull ? [k, m, n, 0] : [k, r, n, y]);\n        });\n      },\n      getSymbol: a.noop,\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,\n      drawGraph: function drawGraph() {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      },\n      pointAttribs: function pointAttribs(a, d) {\n        var g = this.options,\n            b,\n            e = this.pointAttrToOptions || {};\n        b = e.stroke || \"borderColor\";\n        var l = e[\"stroke-width\"] || \"borderWidth\",\n            m = a && a.color || this.color,\n            n = a[b] || g[b] || this.color || m,\n            r = a[l] || g[l] || this[l] || 0,\n            e = g.dashStyle;\n        a && this.zones.length && (m = a.getZone(), m = a.options.color || m && m.color || this.color);\n        d && (a = f(g.states[d], a.options.states && a.options.states[d] || {}), d = a.brightness, m = a.color || void 0 !== d && A(m).brighten(a.brightness).get() || m, n = a[b] || n, r = a[l] || r, e = a.dashStyle || e);\n        b = {\n          fill: m,\n          stroke: n,\n          \"stroke-width\": r\n        };\n        e && (b.dashstyle = e);\n        return b;\n      },\n      drawPoints: function drawPoints() {\n        var a = this,\n            d = this.chart,\n            k = a.options,\n            b = d.renderer,\n            e = k.animationLimit || 250,\n            l;\n        F(a.points, function (g) {\n          var n = g.graphic;\n\n          if (m(g.plotY) && null !== g.y) {\n            l = g.shapeArgs;\n            if (n) n[d.pointCount < e ? \"animate\" : \"attr\"](f(l));else g.graphic = n = b[g.shapeType](l).add(g.group || a.group);\n            k.borderRadius && n.attr({\n              r: k.borderRadius\n            });\n            n.attr(a.pointAttribs(g, g.selected && \"select\")).shadow(k.shadow, null, k.stacking && !k.borderRadius);\n            n.addClass(g.getClassName(), !0);\n          } else n && (g.graphic = n.destroy());\n        });\n      },\n      animate: function animate(a) {\n        var d = this,\n            f = this.yAxis,\n            b = d.options,\n            e = this.chart.inverted,\n            g = {};\n        t && (a ? (g.scaleY = .001, a = Math.min(f.pos + f.len, Math.max(f.pos, f.toPixels(b.threshold))), e ? g.translateX = a - f.len : g.translateY = a, d.group.attr(g)) : (g[e ? \"translateX\" : \"translateY\"] = f.pos, d.group.animate(g, E(C(d.options.animation), {\n          step: function step(a, b) {\n            d.group.attr({\n              scaleY: Math.max(.001, b.pos)\n            });\n          }\n        })), d.animate = null));\n      },\n      remove: function remove() {\n        var a = this,\n            d = a.chart;\n        d.hasRendered && F(d.series, function (d) {\n          d.type === a.type && (d.isDirty = !0);\n        });\n        r.prototype.remove.apply(a, arguments);\n      }\n    });\n  })(M);\n\n  (function (a) {\n    a = a.seriesType;\n    a(\"bar\", \"column\", null, {\n      inverted: !0\n    });\n  })(M);\n\n  (function (a) {\n    var C = a.Series;\n    a = a.seriesType;\n    a(\"scatter\", \"line\", {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> <span style=\\\"font-size: 0.85em\\\"> {series.name}</span><br/>\",\n        pointFormat: \"x: \\x3cb\\x3e{point.x}\\x3c/b\\x3e\\x3cbr/\\x3ey: \\x3cb\\x3e{point.y}\\x3c/b\\x3e\\x3cbr/\\x3e\"\n      }\n    }, {\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1,\n      drawGraph: function drawGraph() {\n        this.options.lineWidth && C.prototype.drawGraph.call(this);\n      }\n    });\n  })(M);\n\n  (function (a) {\n    var C = a.pick,\n        A = a.relativeLength;\n    a.CenteredSeriesMixin = {\n      getCenter: function getCenter() {\n        var a = this.options,\n            E = this.chart,\n            m = 2 * (a.slicedOffset || 0),\n            f = E.plotWidth - 2 * m,\n            E = E.plotHeight - 2 * m,\n            l = a.center,\n            l = [C(l[0], \"50%\"), C(l[1], \"50%\"), a.size || \"100%\", a.innerSize || 0],\n            r = Math.min(f, E),\n            u,\n            t;\n\n        for (u = 0; 4 > u; ++u) {\n          t = l[u], a = 2 > u || 2 === u && /%$/.test(t), l[u] = A(t, [f, E, r, l[2]][u]) + (a ? m : 0);\n        }\n\n        l[3] > l[2] && (l[3] = l[2]);\n        return l;\n      }\n    };\n  })(M);\n\n  (function (a) {\n    var C = a.addEvent,\n        A = a.defined,\n        F = a.each,\n        E = a.extend,\n        m = a.inArray,\n        f = a.noop,\n        l = a.pick,\n        r = a.Point,\n        u = a.Series,\n        t = a.seriesType,\n        g = a.setAnimation;\n    t(\"pie\", \"line\", {\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        distance: 30,\n        enabled: !0,\n        formatter: function formatter() {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        x: 0\n      },\n      ignoreHiddenPoint: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      states: {\n        hover: {\n          brightness: .1,\n          shadow: !1\n        }\n      }\n    }, {\n      isCartesian: !1,\n      requireSorting: !1,\n      directTouch: !0,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      axisTypes: [],\n      pointAttribs: a.seriesTypes.column.prototype.pointAttribs,\n      animate: function animate(a) {\n        var d = this,\n            b = d.points,\n            e = d.startAngleRad;\n        a || (F(b, function (a) {\n          var b = a.graphic,\n              f = a.shapeArgs;\n          b && (b.attr({\n            r: a.startR || d.center[3] / 2,\n            start: e,\n            end: e\n          }), b.animate({\n            r: f.r,\n            start: f.start,\n            end: f.end\n          }, d.options.animation));\n        }), d.animate = null);\n      },\n      updateTotals: function updateTotals() {\n        var a,\n            f = 0,\n            b = this.points,\n            e = b.length,\n            g,\n            l = this.options.ignoreHiddenPoint;\n\n        for (a = 0; a < e; a++) {\n          g = b[a], f += l && !g.visible ? 0 : g.isNull ? 0 : g.y;\n        }\n\n        this.total = f;\n\n        for (a = 0; a < e; a++) {\n          g = b[a], g.percentage = 0 < f && (g.visible || !l) ? g.y / f * 100 : 0, g.total = f;\n        }\n      },\n      generatePoints: function generatePoints() {\n        u.prototype.generatePoints.call(this);\n        this.updateTotals();\n      },\n      translate: function translate(a) {\n        this.generatePoints();\n        var d = 0,\n            b = this.options,\n            e = b.slicedOffset,\n            f = e + (b.borderWidth || 0),\n            g,\n            n,\n            m,\n            r = b.startAngle || 0,\n            c = this.startAngleRad = Math.PI / 180 * (r - 90),\n            r = (this.endAngleRad = Math.PI / 180 * (l(b.endAngle, r + 360) - 90)) - c,\n            t = this.points,\n            q,\n            B = b.dataLabels.distance,\n            b = b.ignoreHiddenPoint,\n            u,\n            p = t.length,\n            z;\n        a || (this.center = a = this.getCenter());\n\n        this.getX = function (b, c, e) {\n          m = Math.asin(Math.min((b - a[1]) / (a[2] / 2 + e.labelDistance), 1));\n          return a[0] + (c ? -1 : 1) * Math.cos(m) * (a[2] / 2 + e.labelDistance);\n        };\n\n        for (u = 0; u < p; u++) {\n          z = t[u];\n          z.labelDistance = l(z.options.dataLabels && z.options.dataLabels.distance, B);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, z.labelDistance);\n          g = c + d * r;\n          if (!b || z.visible) d += z.percentage / 100;\n          n = c + d * r;\n          z.shapeType = \"arc\";\n          z.shapeArgs = {\n            x: a[0],\n            y: a[1],\n            r: a[2] / 2,\n            innerR: a[3] / 2,\n            start: Math.round(1E3 * g) / 1E3,\n            end: Math.round(1E3 * n) / 1E3\n          };\n          m = (n + g) / 2;\n          m > 1.5 * Math.PI ? m -= 2 * Math.PI : m < -Math.PI / 2 && (m += 2 * Math.PI);\n          z.slicedTranslation = {\n            translateX: Math.round(Math.cos(m) * e),\n            translateY: Math.round(Math.sin(m) * e)\n          };\n          n = Math.cos(m) * a[2] / 2;\n          q = Math.sin(m) * a[2] / 2;\n          z.tooltipPos = [a[0] + .7 * n, a[1] + .7 * q];\n          z.half = m < -Math.PI / 2 || m > Math.PI / 2 ? 1 : 0;\n          z.angle = m;\n          g = Math.min(f, z.labelDistance / 5);\n          z.labelPos = [a[0] + n + Math.cos(m) * z.labelDistance, a[1] + q + Math.sin(m) * z.labelDistance, a[0] + n + Math.cos(m) * g, a[1] + q + Math.sin(m) * g, a[0] + n, a[1] + q, 0 > z.labelDistance ? \"center\" : z.half ? \"right\" : \"left\", m];\n        }\n      },\n      drawGraph: null,\n      drawPoints: function drawPoints() {\n        var a = this,\n            f = a.chart.renderer,\n            b,\n            e,\n            g,\n            l,\n            n = a.options.shadow;\n        n && !a.shadowGroup && (a.shadowGroup = f.g(\"shadow\").add(a.group));\n        F(a.points, function (d) {\n          if (!d.isNull) {\n            e = d.graphic;\n            l = d.shapeArgs;\n            b = d.getTranslate();\n            var k = d.shadowGroup;\n            n && !k && (k = d.shadowGroup = f.g(\"shadow\").add(a.shadowGroup));\n            k && k.attr(b);\n            g = a.pointAttribs(d, d.selected && \"select\");\n            e ? e.setRadialReference(a.center).attr(g).animate(E(l, b)) : (d.graphic = e = f[d.shapeType](l).setRadialReference(a.center).attr(b).add(a.group), d.visible || e.attr({\n              visibility: \"hidden\"\n            }), e.attr(g).attr({\n              \"stroke-linejoin\": \"round\"\n            }).shadow(n, k));\n            e.addClass(d.getClassName());\n          }\n        });\n      },\n      searchPoint: f,\n      sortByAngle: function sortByAngle(a, f) {\n        a.sort(function (a, e) {\n          return void 0 !== a.angle && (e.angle - a.angle) * f;\n        });\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,\n      getCenter: a.CenteredSeriesMixin.getCenter,\n      getSymbol: f\n    }, {\n      init: function init() {\n        r.prototype.init.apply(this, arguments);\n        var a = this,\n            f;\n        a.name = l(a.name, \"Slice\");\n\n        f = function f(b) {\n          a.slice(\"select\" === b.type);\n        };\n\n        C(a, \"select\", f);\n        C(a, \"unselect\", f);\n        return a;\n      },\n      isValid: function isValid() {\n        return a.isNumber(this.y, !0) && 0 <= this.y;\n      },\n      setVisible: function setVisible(a, f) {\n        var b = this,\n            e = b.series,\n            d = e.chart,\n            g = e.options.ignoreHiddenPoint;\n        f = l(f, g);\n        a !== b.visible && (b.visible = b.options.visible = a = void 0 === a ? !b.visible : a, e.options.data[m(b, e.data)] = b.options, F([\"graphic\", \"dataLabel\", \"connector\", \"shadowGroup\"], function (e) {\n          if (b[e]) b[e][a ? \"show\" : \"hide\"](!0);\n        }), b.legendItem && d.legend.colorizeItem(b, a), a || \"hover\" !== b.state || b.setState(\"\"), g && (e.isDirty = !0), f && d.redraw());\n      },\n      slice: function slice(a, f, b) {\n        var e = this.series;\n        g(b, e.chart);\n        l(f, !0);\n        this.sliced = this.options.sliced = A(a) ? a : !this.sliced;\n        e.options.data[m(this, e.data)] = this.options;\n        this.graphic.animate(this.getTranslate());\n        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());\n      },\n      getTranslate: function getTranslate() {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      },\n      haloPath: function haloPath(a) {\n        var d = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(d.x, d.y, d.r + a, d.r + a, {\n          innerR: this.shapeArgs.r,\n          start: d.start,\n          end: d.end\n        });\n      }\n    });\n  })(M);\n\n  (function (a) {\n    var C = a.addEvent,\n        A = a.arrayMax,\n        F = a.defined,\n        E = a.each,\n        m = a.extend,\n        f = a.format,\n        l = a.map,\n        r = a.merge,\n        u = a.noop,\n        t = a.pick,\n        g = a.relativeLength,\n        d = a.Series,\n        k = a.seriesTypes,\n        b = a.stableSort;\n\n    a.distribute = function (a, d) {\n      function e(a, b) {\n        return a.target - b.target;\n      }\n\n      var f,\n          g = !0,\n          k = a,\n          c = [],\n          m;\n      m = 0;\n\n      for (f = a.length; f--;) {\n        m += a[f].size;\n      }\n\n      if (m > d) {\n        b(a, function (a, b) {\n          return (b.rank || 0) - (a.rank || 0);\n        });\n\n        for (m = f = 0; m <= d;) {\n          m += a[f].size, f++;\n        }\n\n        c = a.splice(f - 1, a.length);\n      }\n\n      b(a, e);\n\n      for (a = l(a, function (a) {\n        return {\n          size: a.size,\n          targets: [a.target]\n        };\n      }); g;) {\n        for (f = a.length; f--;) {\n          g = a[f], m = (Math.min.apply(0, g.targets) + Math.max.apply(0, g.targets)) / 2, g.pos = Math.min(Math.max(0, m - g.size / 2), d - g.size);\n        }\n\n        f = a.length;\n\n        for (g = !1; f--;) {\n          0 < f && a[f - 1].pos + a[f - 1].size > a[f].pos && (a[f - 1].size += a[f].size, a[f - 1].targets = a[f - 1].targets.concat(a[f].targets), a[f - 1].pos + a[f - 1].size > d && (a[f - 1].pos = d - a[f - 1].size), a.splice(f, 1), g = !0);\n        }\n      }\n\n      f = 0;\n      E(a, function (a) {\n        var b = 0;\n        E(a.targets, function () {\n          k[f].pos = a.pos + b;\n          b += k[f].size;\n          f++;\n        });\n      });\n      k.push.apply(k, c);\n      b(k, e);\n    };\n\n    d.prototype.drawDataLabels = function () {\n      var b = this,\n          d = b.options,\n          g = d.dataLabels,\n          k = b.points,\n          l,\n          m,\n          c = b.hasRendered || 0,\n          u,\n          q,\n          B = t(g.defer, !!d.animation),\n          A = b.chart.renderer;\n      if (g.enabled || b._hasPointLabels) b.dlProcessOptions && b.dlProcessOptions(g), q = b.plotGroup(\"dataLabelsGroup\", \"data-labels\", B && !c ? \"hidden\" : \"visible\", g.zIndex || 6), B && (q.attr({\n        opacity: +c\n      }), c || C(b, \"afterAnimate\", function () {\n        b.visible && q.show(!0);\n        q[d.animation ? \"animate\" : \"attr\"]({\n          opacity: 1\n        }, {\n          duration: 200\n        });\n      })), m = g, E(k, function (c) {\n        var e,\n            k = c.dataLabel,\n            n,\n            h,\n            p = c.connector,\n            v = !k,\n            B;\n        l = c.dlOptions || c.options && c.options.dataLabels;\n        if (e = t(l && l.enabled, m.enabled) && null !== c.y) g = r(m, l), n = c.getLabelConfig(), u = g.format ? f(g.format, n) : g.formatter.call(n, g), B = g.style, n = g.rotation, B.color = t(g.color, B.color, b.color, \"#000000\"), \"contrast\" === B.color && (c.contrastColor = A.getContrast(c.color || b.color), B.color = g.inside || 0 > t(c.labelDistance, g.distance) || d.stacking ? c.contrastColor : \"#000000\"), d.cursor && (B.cursor = d.cursor), h = {\n          fill: g.backgroundColor,\n          stroke: g.borderColor,\n          \"stroke-width\": g.borderWidth,\n          r: g.borderRadius || 0,\n          rotation: n,\n          padding: g.padding,\n          zIndex: 1\n        }, a.objectEach(h, function (a, b) {\n          void 0 === a && delete h[b];\n        });\n        !k || e && F(u) ? e && F(u) && (k ? h.text = u : (k = c.dataLabel = A[n ? \"text\" : \"label\"](u, 0, -9999, g.shape, null, null, g.useHTML, null, \"data-label\"), k.addClass(\"highcharts-data-label-color-\" + c.colorIndex + \" \" + (g.className || \"\") + (g.useHTML ? \"highcharts-tracker\" : \"\"))), k.attr(h), k.css(B).shadow(g.shadow), k.added || k.add(q), b.alignDataLabel(c, k, g, null, v)) : (c.dataLabel = k = k.destroy(), p && (c.connector = p.destroy()));\n      });\n    };\n\n    d.prototype.alignDataLabel = function (a, b, d, f, g) {\n      var e = this.chart,\n          c = e.inverted,\n          k = t(a.plotX, -9999),\n          l = t(a.plotY, -9999),\n          n = b.getBBox(),\n          r,\n          p = d.rotation,\n          v = d.align,\n          u = this.visible && (a.series.forceDL || e.isInsidePlot(k, Math.round(l), c) || f && e.isInsidePlot(k, c ? f.x + 1 : f.y + f.height - 1, c)),\n          y = \"justify\" === t(d.overflow, \"justify\");\n      if (u && (r = d.style.fontSize, r = e.renderer.fontMetrics(r, b).b, f = m({\n        x: c ? this.yAxis.len - l : k,\n        y: Math.round(c ? this.xAxis.len - k : l),\n        width: 0,\n        height: 0\n      }, f), m(d, {\n        width: n.width,\n        height: n.height\n      }), p ? (y = !1, k = e.renderer.rotCorr(r, p), k = {\n        x: f.x + d.x + f.width / 2 + k.x,\n        y: f.y + d.y + {\n          top: 0,\n          middle: .5,\n          bottom: 1\n        }[d.verticalAlign] * f.height\n      }, b[g ? \"attr\" : \"animate\"](k).attr({\n        align: v\n      }), l = (p + 720) % 360, l = 180 < l && 360 > l, \"left\" === v ? k.y -= l ? n.height : 0 : \"center\" === v ? (k.x -= n.width / 2, k.y -= n.height / 2) : \"right\" === v && (k.x -= n.width, k.y -= l ? 0 : n.height)) : (b.align(d, null, f), k = b.alignAttr), y ? a.isLabelJustified = this.justifyDataLabel(b, d, k, n, f, g) : t(d.crop, !0) && (u = e.isInsidePlot(k.x, k.y) && e.isInsidePlot(k.x + n.width, k.y + n.height)), d.shape && !p)) b[g ? \"attr\" : \"animate\"]({\n        anchorX: c ? e.plotWidth - a.plotY : a.plotX,\n        anchorY: c ? e.plotHeight - a.plotX : a.plotY\n      });\n      u || (b.attr({\n        y: -9999\n      }), b.placed = !1);\n    };\n\n    d.prototype.justifyDataLabel = function (a, b, d, f, g, k) {\n      var c = this.chart,\n          e = b.align,\n          l = b.verticalAlign,\n          m,\n          n,\n          p = a.box ? 0 : a.padding || 0;\n      m = d.x + p;\n      0 > m && (\"right\" === e ? b.align = \"left\" : b.x = -m, n = !0);\n      m = d.x + f.width - p;\n      m > c.plotWidth && (\"left\" === e ? b.align = \"right\" : b.x = c.plotWidth - m, n = !0);\n      m = d.y + p;\n      0 > m && (\"bottom\" === l ? b.verticalAlign = \"top\" : b.y = -m, n = !0);\n      m = d.y + f.height - p;\n      m > c.plotHeight && (\"top\" === l ? b.verticalAlign = \"bottom\" : b.y = c.plotHeight - m, n = !0);\n      n && (a.placed = !k, a.align(b, null, g));\n      return n;\n    };\n\n    k.pie && (k.pie.prototype.drawDataLabels = function () {\n      var b = this,\n          f = b.data,\n          g,\n          k = b.chart,\n          l = b.options.dataLabels,\n          m = t(l.connectorPadding, 10),\n          c = t(l.connectorWidth, 1),\n          r = k.plotWidth,\n          q = k.plotHeight,\n          u,\n          C = b.center,\n          p = C[2] / 2,\n          z = C[1],\n          I,\n          L,\n          h,\n          w,\n          M = [[], []],\n          H,\n          O,\n          Q,\n          R,\n          x = [0, 0, 0, 0];\n      b.visible && (l.enabled || b._hasPointLabels) && (E(f, function (a) {\n        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n          width: \"auto\"\n        }).css({\n          width: \"auto\",\n          textOverflow: \"clip\"\n        }), a.dataLabel.shortened = !1);\n      }), d.prototype.drawDataLabels.apply(b), E(f, function (a) {\n        a.dataLabel && a.visible && (M[a.half].push(a), a.dataLabel._pos = null);\n      }), E(M, function (c, d) {\n        var e,\n            f,\n            n = c.length,\n            v = [],\n            u;\n        if (n) for (b.sortByAngle(c, d - .5), 0 < b.maxLabelDistance && (e = Math.max(0, z - p - b.maxLabelDistance), f = Math.min(z + p + b.maxLabelDistance, k.plotHeight), E(c, function (a) {\n          0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, z - p - a.labelDistance), a.bottom = Math.min(z + p + a.labelDistance, k.plotHeight), u = a.dataLabel.getBBox().height || 21, a.positionsIndex = v.push({\n            target: a.labelPos[1] - a.top + u / 2,\n            size: u,\n            rank: a.y\n          }) - 1);\n        }), a.distribute(v, f + u - e)), R = 0; R < n; R++) {\n          g = c[R], f = g.positionsIndex, h = g.labelPos, I = g.dataLabel, Q = !1 === g.visible ? \"hidden\" : \"inherit\", e = h[1], v && F(v[f]) ? void 0 === v[f].pos ? Q = \"hidden\" : (w = v[f].size, O = g.top + v[f].pos) : O = e, delete g.positionIndex, H = l.justify ? C[0] + (d ? -1 : 1) * (p + g.labelDistance) : b.getX(O < g.top + 2 || O > g.bottom - 2 ? e : O, d, g), I._attr = {\n            visibility: Q,\n            align: h[6]\n          }, I._pos = {\n            x: H + l.x + ({\n              left: m,\n              right: -m\n            }[h[6]] || 0),\n            y: O + l.y - 10\n          }, h.x = H, h.y = O, t(l.crop, !0) && (L = I.getBBox().width, e = null, H - L < m ? (e = Math.round(L - H + m), x[3] = Math.max(e, x[3])) : H + L > r - m && (e = Math.round(H + L - r + m), x[1] = Math.max(e, x[1])), 0 > O - w / 2 ? x[0] = Math.max(Math.round(-O + w / 2), x[0]) : O + w / 2 > q && (x[2] = Math.max(Math.round(O + w / 2 - q), x[2])), I.sideOverflow = e);\n        }\n      }), 0 === A(x) || this.verifyDataLabelOverflow(x)) && (this.placeDataLabels(), c && E(this.points, function (a) {\n        var e;\n        u = a.connector;\n\n        if ((I = a.dataLabel) && I._pos && a.visible && 0 < a.labelDistance) {\n          Q = I._attr.visibility;\n          if (e = !u) a.connector = u = k.renderer.path().addClass(\"highcharts-data-label-connector highcharts-color-\" + a.colorIndex).add(b.dataLabelsGroup), u.attr({\n            \"stroke-width\": c,\n            stroke: l.connectorColor || a.color || \"#666666\"\n          });\n          u[e ? \"attr\" : \"animate\"]({\n            d: b.connectorPath(a.labelPos)\n          });\n          u.attr(\"visibility\", Q);\n        } else u && (a.connector = u.destroy());\n      }));\n    }, k.pie.prototype.connectorPath = function (a) {\n      var b = a.x,\n          d = a.y;\n      return t(this.options.dataLabels.softConnector, !0) ? [\"M\", b + (\"left\" === a[6] ? 5 : -5), d, \"C\", b, d, 2 * a[2] - a[4], 2 * a[3] - a[5], a[2], a[3], \"L\", a[4], a[5]] : [\"M\", b + (\"left\" === a[6] ? 5 : -5), d, \"L\", a[2], a[3], \"L\", a[4], a[5]];\n    }, k.pie.prototype.placeDataLabels = function () {\n      E(this.points, function (a) {\n        var b = a.dataLabel;\n        b && a.visible && ((a = b._pos) ? (b.sideOverflow && (b._attr.width = b.getBBox().width - b.sideOverflow, b.css({\n          width: b._attr.width + \"px\",\n          textOverflow: \"ellipsis\"\n        }), b.shortened = !0), b.attr(b._attr), b[b.moved ? \"animate\" : \"attr\"](a), b.moved = !0) : b && b.attr({\n          y: -9999\n        }));\n      }, this);\n    }, k.pie.prototype.alignDataLabel = u, k.pie.prototype.verifyDataLabelOverflow = function (a) {\n      var b = this.center,\n          d = this.options,\n          e = d.center,\n          f = d.minSize || 80,\n          k,\n          c = null !== d.size;\n      c || (null !== e[0] ? k = Math.max(b[2] - Math.max(a[1], a[3]), f) : (k = Math.max(b[2] - a[1] - a[3], f), b[0] += (a[3] - a[1]) / 2), null !== e[1] ? k = Math.max(Math.min(k, b[2] - Math.max(a[0], a[2])), f) : (k = Math.max(Math.min(k, b[2] - a[0] - a[2]), f), b[1] += (a[0] - a[2]) / 2), k < b[2] ? (b[2] = k, b[3] = Math.min(g(d.innerSize || 0, k), k), this.translate(b), this.drawDataLabels && this.drawDataLabels()) : c = !0);\n      return c;\n    });\n    k.column && (k.column.prototype.alignDataLabel = function (a, b, f, g, k) {\n      var e = this.chart.inverted,\n          c = a.series,\n          l = a.dlBox || a.shapeArgs,\n          m = t(a.below, a.plotY > t(this.translatedThreshold, c.yAxis.len)),\n          n = t(f.inside, !!this.options.stacking);\n      l && (g = r(l), 0 > g.y && (g.height += g.y, g.y = 0), l = g.y + g.height - c.yAxis.len, 0 < l && (g.height -= l), e && (g = {\n        x: c.yAxis.len - g.y - g.height,\n        y: c.xAxis.len - g.x - g.width,\n        width: g.height,\n        height: g.width\n      }), n || (e ? (g.x += m ? 0 : g.width, g.width = 0) : (g.y += m ? g.height : 0, g.height = 0)));\n      f.align = t(f.align, !e || n ? \"center\" : m ? \"right\" : \"left\");\n      f.verticalAlign = t(f.verticalAlign, e || n ? \"middle\" : m ? \"top\" : \"bottom\");\n      d.prototype.alignDataLabel.call(this, a, b, f, g, k);\n      a.isLabelJustified && a.contrastColor && a.dataLabel.css({\n        color: a.contrastColor\n      });\n    });\n  })(M);\n\n  (function (a) {\n    var C = a.Chart,\n        A = a.each,\n        F = a.objectEach,\n        E = a.pick,\n        m = a.addEvent;\n    C.prototype.callbacks.push(function (a) {\n      function f() {\n        var f = [];\n        A(a.yAxis || [], function (a) {\n          a.options.stackLabels && !a.options.stackLabels.allowOverlap && F(a.stacks, function (a) {\n            F(a, function (a) {\n              f.push(a.label);\n            });\n          });\n        });\n        A(a.series || [], function (a) {\n          var l = a.options.dataLabels,\n              g = a.dataLabelCollections || [\"dataLabel\"];\n          (l.enabled || a._hasPointLabels) && !l.allowOverlap && a.visible && A(g, function (d) {\n            A(a.points, function (a) {\n              a[d] && (a[d].labelrank = E(a.labelrank, a.shapeArgs && a.shapeArgs.height), f.push(a[d]));\n            });\n          });\n        });\n        a.hideOverlappingLabels(f);\n      }\n\n      f();\n      m(a, \"redraw\", f);\n    });\n\n    C.prototype.hideOverlappingLabels = function (a) {\n      var f = a.length,\n          m,\n          u,\n          t,\n          g,\n          d,\n          k,\n          b,\n          e,\n          v,\n          y = function y(a, b, d, c, e, f, g, k) {\n        return !(e > a + d || e + g < a || f > b + c || f + k < b);\n      };\n\n      for (u = 0; u < f; u++) {\n        if (m = a[u]) m.oldOpacity = m.opacity, m.newOpacity = 1, m.width || (t = m.getBBox(), m.width = t.width, m.height = t.height);\n      }\n\n      a.sort(function (a, b) {\n        return (b.labelrank || 0) - (a.labelrank || 0);\n      });\n\n      for (u = 0; u < f; u++) {\n        for (t = a[u], m = u + 1; m < f; ++m) {\n          if (g = a[m], t && g && t !== g && t.placed && g.placed && 0 !== t.newOpacity && 0 !== g.newOpacity && (d = t.alignAttr, k = g.alignAttr, b = t.parentGroup, e = g.parentGroup, v = 2 * (t.box ? 0 : t.padding || 0), d = y(d.x + b.translateX, d.y + b.translateY, t.width - v, t.height - v, k.x + e.translateX, k.y + e.translateY, g.width - v, g.height - v))) (t.labelrank < g.labelrank ? t : g).newOpacity = 0;\n        }\n      }\n\n      A(a, function (a) {\n        var b, d;\n        a && (d = a.newOpacity, a.oldOpacity !== d && a.placed && (d ? a.show(!0) : b = function b() {\n          a.hide();\n        }, a.alignAttr.opacity = d, a[a.isOld ? \"animate\" : \"attr\"](a.alignAttr, null, b)), a.isOld = !0);\n      });\n    };\n  })(M);\n\n  (function (a) {\n    var C = a.addEvent,\n        A = a.Chart,\n        F = a.createElement,\n        E = a.css,\n        m = a.defaultOptions,\n        f = a.defaultPlotOptions,\n        l = a.each,\n        r = a.extend,\n        u = a.fireEvent,\n        t = a.hasTouch,\n        g = a.inArray,\n        d = a.isObject,\n        k = a.Legend,\n        b = a.merge,\n        e = a.pick,\n        v = a.Point,\n        y = a.Series,\n        n = a.seriesTypes,\n        D = a.svg,\n        J;\n    J = a.TrackerMixin = {\n      drawTrackerPoint: function drawTrackerPoint() {\n        var a = this,\n            b = a.chart.pointer,\n            d = function d(a) {\n          var c = b.getPointFromEvent(a);\n          void 0 !== c && (b.isDirectTouch = !0, c.onMouseOver(a));\n        };\n\n        l(a.points, function (a) {\n          a.graphic && (a.graphic.element.point = a);\n          a.dataLabel && (a.dataLabel.div ? a.dataLabel.div.point = a : a.dataLabel.element.point = a);\n        });\n        a._hasTracking || (l(a.trackerGroups, function (c) {\n          if (a[c]) {\n            a[c].addClass(\"highcharts-tracker\").on(\"mouseover\", d).on(\"mouseout\", function (a) {\n              b.onTrackerMouseOut(a);\n            });\n            if (t) a[c].on(\"touchstart\", d);\n            a.options.cursor && a[c].css(E).css({\n              cursor: a.options.cursor\n            });\n          }\n        }), a._hasTracking = !0);\n      },\n      drawTrackerGraph: function drawTrackerGraph() {\n        var a = this,\n            b = a.options,\n            d = b.trackByArea,\n            e = [].concat(d ? a.areaPath : a.graphPath),\n            f = e.length,\n            g = a.chart,\n            k = g.pointer,\n            m = g.renderer,\n            n = g.options.tooltip.snap,\n            h = a.tracker,\n            r,\n            u = function u() {\n          if (g.hoverSeries !== a) a.onMouseOver();\n        },\n            v = \"rgba(192,192,192,\" + (D ? .0001 : .002) + \")\";\n\n        if (f && !d) for (r = f + 1; r--;) {\n          \"M\" === e[r] && e.splice(r + 1, 0, e[r + 1] - n, e[r + 2], \"L\"), (r && \"M\" === e[r] || r === f) && e.splice(r, 0, \"L\", e[r - 2] + n, e[r - 1]);\n        }\n        h ? h.attr({\n          d: e\n        }) : a.graph && (a.tracker = m.path(e).attr({\n          \"stroke-linejoin\": \"round\",\n          visibility: a.visible ? \"visible\" : \"hidden\",\n          stroke: v,\n          fill: d ? v : \"none\",\n          \"stroke-width\": a.graph.strokeWidth() + (d ? 0 : 2 * n),\n          zIndex: 2\n        }).add(a.group), l([a.tracker, a.markerGroup], function (a) {\n          a.addClass(\"highcharts-tracker\").on(\"mouseover\", u).on(\"mouseout\", function (a) {\n            k.onTrackerMouseOut(a);\n          });\n          b.cursor && a.css({\n            cursor: b.cursor\n          });\n          if (t) a.on(\"touchstart\", u);\n        }));\n      }\n    };\n    n.column && (n.column.prototype.drawTracker = J.drawTrackerPoint);\n    n.pie && (n.pie.prototype.drawTracker = J.drawTrackerPoint);\n    n.scatter && (n.scatter.prototype.drawTracker = J.drawTrackerPoint);\n    r(k.prototype, {\n      setItemEvents: function setItemEvents(a, d, e) {\n        var c = this,\n            f = c.chart.renderer.boxWrapper,\n            g = \"highcharts-legend-\" + (a.series ? \"point\" : \"series\") + \"-active\";\n        (e ? d : a.legendGroup).on(\"mouseover\", function () {\n          a.setState(\"hover\");\n          f.addClass(g);\n          d.css(c.options.itemHoverStyle);\n        }).on(\"mouseout\", function () {\n          d.css(b(a.visible ? c.itemStyle : c.itemHiddenStyle));\n          f.removeClass(g);\n          a.setState();\n        }).on(\"click\", function (b) {\n          var c = function c() {\n            a.setVisible && a.setVisible();\n          };\n\n          b = {\n            browserEvent: b\n          };\n          a.firePointEvent ? a.firePointEvent(\"legendItemClick\", b, c) : u(a, \"legendItemClick\", b, c);\n        });\n      },\n      createCheckboxForItem: function createCheckboxForItem(a) {\n        a.checkbox = F(\"input\", {\n          type: \"checkbox\",\n          checked: a.selected,\n          defaultChecked: a.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        C(a.checkbox, \"click\", function (b) {\n          u(a.series || a, \"checkboxClick\", {\n            checked: b.target.checked,\n            item: a\n          }, function () {\n            a.select();\n          });\n        });\n      }\n    });\n    m.legend.itemStyle.cursor = \"pointer\";\n    r(A.prototype, {\n      showResetZoom: function showResetZoom() {\n        var a = this,\n            b = m.lang,\n            d = a.options.chart.resetZoomButton,\n            e = d.theme,\n            f = e.states,\n            g = \"chart\" === d.relativeTo ? null : \"plotBox\";\n        this.resetZoomButton = a.renderer.button(b.resetZoom, null, null, function () {\n          a.zoomOut();\n        }, e, f && f.hover).attr({\n          align: d.position.align,\n          title: b.resetZoomTitle\n        }).addClass(\"highcharts-reset-zoom\").add().align(d.position, !1, g);\n      },\n      zoomOut: function zoomOut() {\n        var a = this;\n        u(a, \"selection\", {\n          resetSelection: !0\n        }, function () {\n          a.zoom();\n        });\n      },\n      zoom: function zoom(a) {\n        var b,\n            c = this.pointer,\n            f = !1,\n            g;\n        !a || a.resetSelection ? (l(this.axes, function (a) {\n          b = a.zoom();\n        }), c.initiated = !1) : l(a.xAxis.concat(a.yAxis), function (a) {\n          var d = a.axis;\n          c[d.isXAxis ? \"zoomX\" : \"zoomY\"] && (b = d.zoom(a.min, a.max), d.displayBtn && (f = !0));\n        });\n        g = this.resetZoomButton;\n        f && !g ? this.showResetZoom() : !f && d(g) && (this.resetZoomButton = g.destroy());\n        b && this.redraw(e(this.options.chart.animation, a && a.animation, 100 > this.pointCount));\n      },\n      pan: function pan(a, b) {\n        var c = this,\n            d = c.hoverPoints,\n            e;\n        d && l(d, function (a) {\n          a.setState();\n        });\n        l(\"xy\" === b ? [1, 0] : [1], function (b) {\n          b = c[b ? \"xAxis\" : \"yAxis\"][0];\n          var d = b.horiz,\n              f = a[d ? \"chartX\" : \"chartY\"],\n              d = d ? \"mouseDownX\" : \"mouseDownY\",\n              g = c[d],\n              h = (b.pointRange || 0) / 2,\n              k = b.getExtremes(),\n              l = b.toValue(g - f, !0) + h,\n              h = b.toValue(g + b.len - f, !0) - h,\n              m = h < l,\n              g = m ? h : l,\n              l = m ? l : h,\n              h = Math.min(k.dataMin, b.toValue(b.toPixels(k.min) - b.minPixelPadding)),\n              m = Math.max(k.dataMax, b.toValue(b.toPixels(k.max) + b.minPixelPadding)),\n              n;\n          n = h - g;\n          0 < n && (l += n, g = h);\n          n = l - m;\n          0 < n && (l = m, g -= n);\n          b.series.length && g !== k.min && l !== k.max && (b.setExtremes(g, l, !1, !1, {\n            trigger: \"pan\"\n          }), e = !0);\n          c[d] = f;\n        });\n        e && c.redraw(!1);\n        E(c.container, {\n          cursor: \"move\"\n        });\n      }\n    });\n    r(v.prototype, {\n      select: function select(a, b) {\n        var c = this,\n            d = c.series,\n            f = d.chart;\n        a = e(a, !c.selected);\n        c.firePointEvent(a ? \"select\" : \"unselect\", {\n          accumulate: b\n        }, function () {\n          c.selected = c.options.selected = a;\n          d.options.data[g(c, d.data)] = c.options;\n          c.setState(a && \"select\");\n          b || l(f.getSelectedPoints(), function (a) {\n            a.selected && a !== c && (a.selected = a.options.selected = !1, d.options.data[g(a, d.data)] = a.options, a.setState(\"\"), a.firePointEvent(\"unselect\"));\n          });\n        });\n      },\n      onMouseOver: function onMouseOver(a) {\n        var b = this.series.chart,\n            c = b.pointer;\n        a = a ? c.normalize(a) : c.getChartCoordinatesFromPoint(this, b.inverted);\n        c.runPointActions(a, this);\n      },\n      onMouseOut: function onMouseOut() {\n        var a = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        l(a.hoverPoints || [], function (a) {\n          a.setState();\n        });\n        a.hoverPoints = a.hoverPoint = null;\n      },\n      importEvents: function importEvents() {\n        if (!this.hasImportedEvents) {\n          var c = this,\n              d = b(c.series.options.point, c.options).events;\n          c.events = d;\n          a.objectEach(d, function (a, b) {\n            C(c, b, a);\n          });\n          this.hasImportedEvents = !0;\n        }\n      },\n      setState: function setState(a, b) {\n        var c = Math.floor(this.plotX),\n            d = this.plotY,\n            g = this.series,\n            k = g.options.states[a] || {},\n            l = f[g.type].marker && g.options.marker,\n            m = l && !1 === l.enabled,\n            n = l && l.states && l.states[a] || {},\n            h = !1 === n.enabled,\n            t = g.stateMarkerGraphic,\n            u = this.marker || {},\n            v = g.chart,\n            y = g.halo,\n            A,\n            C = l && g.markerAttribs;\n        a = a || \"\";\n\n        if (!(a === this.state && !b || this.selected && \"select\" !== a || !1 === k.enabled || a && (h || m && !1 === n.enabled) || a && u.states && u.states[a] && !1 === u.states[a].enabled)) {\n          C && (A = g.markerAttribs(this, a));\n          if (this.graphic) this.state && this.graphic.removeClass(\"highcharts-point-\" + this.state), a && this.graphic.addClass(\"highcharts-point-\" + a), this.graphic.animate(g.pointAttribs(this, a), e(v.options.chart.animation, k.animation)), A && this.graphic.animate(A, e(v.options.chart.animation, n.animation, l.animation)), t && t.hide();else {\n            if (a && n) {\n              l = u.symbol || g.symbol;\n              t && t.currentSymbol !== l && (t = t.destroy());\n              if (t) t[b ? \"animate\" : \"attr\"]({\n                x: A.x,\n                y: A.y\n              });else l && (g.stateMarkerGraphic = t = v.renderer.symbol(l, A.x, A.y, A.width, A.height).add(g.markerGroup), t.currentSymbol = l);\n              t && t.attr(g.pointAttribs(this, a));\n            }\n\n            t && (t[a && v.isInsidePlot(c, d, v.inverted) ? \"show\" : \"hide\"](), t.element.point = this);\n          }\n          (c = k.halo) && c.size ? (y || (g.halo = y = v.renderer.path().add((this.graphic || t).parentGroup)), y[b ? \"animate\" : \"attr\"]({\n            d: this.haloPath(c.size)\n          }), y.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + e(this.colorIndex, g.colorIndex)\n          }), y.point = this, y.attr(r({\n            fill: this.color || g.color,\n            \"fill-opacity\": c.opacity,\n            zIndex: -1\n          }, c.attributes))) : y && y.point && y.point.haloPath && y.animate({\n            d: y.point.haloPath(0)\n          });\n          this.state = a;\n        }\n      },\n      haloPath: function haloPath(a) {\n        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);\n      }\n    });\n    r(y.prototype, {\n      onMouseOver: function onMouseOver() {\n        var a = this.chart,\n            b = a.hoverSeries;\n        if (b && b !== this) b.onMouseOut();\n        this.options.events.mouseOver && u(this, \"mouseOver\");\n        this.setState(\"hover\");\n        a.hoverSeries = this;\n      },\n      onMouseOut: function onMouseOut() {\n        var a = this.options,\n            b = this.chart,\n            d = b.tooltip,\n            e = b.hoverPoint;\n        b.hoverSeries = null;\n        if (e) e.onMouseOut();\n        this && a.events.mouseOut && u(this, \"mouseOut\");\n        !d || this.stickyTracking || d.shared && !this.noSharedTooltip || d.hide();\n        this.setState();\n      },\n      setState: function setState(a) {\n        var b = this,\n            c = b.options,\n            d = b.graph,\n            f = c.states,\n            g = c.lineWidth,\n            c = 0;\n        a = a || \"\";\n        if (b.state !== a && (l([b.group, b.markerGroup, b.dataLabelsGroup], function (c) {\n          c && (b.state && c.removeClass(\"highcharts-series-\" + b.state), a && c.addClass(\"highcharts-series-\" + a));\n        }), b.state = a, !f[a] || !1 !== f[a].enabled) && (a && (g = f[a].lineWidth || g + (f[a].lineWidthPlus || 0)), d && !d.dashstyle)) for (g = {\n          \"stroke-width\": g\n        }, d.animate(g, e(b.chart.options.chart.animation, f[a] && f[a].animation)); b[\"zone-graph-\" + c];) {\n          b[\"zone-graph-\" + c].attr(g), c += 1;\n        }\n      },\n      setVisible: function setVisible(a, b) {\n        var c = this,\n            d = c.chart,\n            e = c.legendItem,\n            f,\n            g = d.options.chart.ignoreHiddenSeries,\n            k = c.visible;\n        f = (c.visible = a = c.options.visible = c.userOptions.visible = void 0 === a ? !k : a) ? \"show\" : \"hide\";\n        l([\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"], function (a) {\n          if (c[a]) c[a][f]();\n        });\n        if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();\n        e && d.legend.colorizeItem(c, a);\n        c.isDirty = !0;\n        c.options.stacking && l(d.series, function (a) {\n          a.options.stacking && a.visible && (a.isDirty = !0);\n        });\n        l(c.linkedSeries, function (b) {\n          b.setVisible(a, !1);\n        });\n        g && (d.isDirtyBox = !0);\n        !1 !== b && d.redraw();\n        u(c, f);\n      },\n      show: function show() {\n        this.setVisible(!0);\n      },\n      hide: function hide() {\n        this.setVisible(!1);\n      },\n      select: function select(a) {\n        this.selected = a = void 0 === a ? !this.selected : a;\n        this.checkbox && (this.checkbox.checked = a);\n        u(this, a ? \"select\" : \"unselect\");\n      },\n      drawTracker: J.drawTrackerGraph\n    });\n  })(M);\n\n  (function (a) {\n    var C = a.Chart,\n        A = a.each,\n        F = a.inArray,\n        E = a.isArray,\n        m = a.isObject,\n        f = a.pick,\n        l = a.splat;\n\n    C.prototype.setResponsive = function (f) {\n      var l = this.options.responsive,\n          m = [],\n          g = this.currentResponsive;\n      l && l.rules && A(l.rules, function (d) {\n        void 0 === d._id && (d._id = a.uniqueKey());\n        this.matchResponsiveRule(d, m, f);\n      }, this);\n      var d = a.merge.apply(0, a.map(m, function (d) {\n        return a.find(l.rules, function (a) {\n          return a._id === d;\n        }).chartOptions;\n      })),\n          m = m.toString() || void 0;\n      m !== (g && g.ruleIds) && (g && this.update(g.undoOptions, f), m ? (this.currentResponsive = {\n        ruleIds: m,\n        mergedOptions: d,\n        undoOptions: this.currentOptions(d)\n      }, this.update(d, f)) : this.currentResponsive = void 0);\n    };\n\n    C.prototype.matchResponsiveRule = function (a, l) {\n      var m = a.condition;\n      (m.callback || function () {\n        return this.chartWidth <= f(m.maxWidth, Number.MAX_VALUE) && this.chartHeight <= f(m.maxHeight, Number.MAX_VALUE) && this.chartWidth >= f(m.minWidth, 0) && this.chartHeight >= f(m.minHeight, 0);\n      }).call(this) && l.push(a._id);\n    };\n\n    C.prototype.currentOptions = function (f) {\n      function r(f, d, k, b) {\n        var e;\n        a.objectEach(f, function (a, g) {\n          if (!b && -1 < F(g, [\"series\", \"xAxis\", \"yAxis\"])) for (f[g] = l(f[g]), k[g] = [], e = 0; e < f[g].length; e++) {\n            d[g][e] && (k[g][e] = {}, r(a[e], d[g][e], k[g][e], b + 1));\n          } else m(a) ? (k[g] = E(a) ? [] : {}, r(a, d[g] || {}, k[g], b + 1)) : k[g] = d[g] || null;\n        });\n      }\n\n      var t = {};\n      r(f, this.options, t, 0);\n      return t;\n    };\n  })(M);\n\n  return M;\n});","map":null,"metadata":{},"sourceType":"script"}